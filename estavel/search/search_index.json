{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI do Zero!","text":"FastAPI do ZERO Caso prefira ver a apresenta\u00e7\u00e3o do curso em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides </p> <p>Esse material passa por atualiza\u00e7\u00f5es peri\u00f3dicas. Voc\u00ea pode acompanhar as notas de altera\u00e7\u00f5es aqui.</p> <p>Ol\u00e1, boas-vindas ao curso de FastAPI!</p> <p>A nossa inten\u00e7\u00e3o neste curso \u00e9 facilitar o aprendizado no desenvolvimento de APIs usando o FastAPI. Vamos explorar como integrar bancos de dados, criar testes e um sistema b\u00e1sico de autentica\u00e7\u00e3o com JWT. Tudo isso para oferecer uma boa base para quem quer trabalhar com desenvolvimento web com Python. A ideia desse curso \u00e9 apresentar os conceitos de forma pr\u00e1tica, construindo um projeto do zero e indo at\u00e9 a sua fase de produ\u00e7\u00e3o.</p>"},{"location":"#o-que-e-fastapi","title":"O que \u00e9 FastAPI?","text":"<p>FastAPI \u00e9 um framework Python moderno, projetado para simplicidade, velocidade e efici\u00eancia. A combina\u00e7\u00e3o de diversas funcionalidades modernas do Python, como anota\u00e7\u00f5es de tipo e suporte \u00e0 concorr\u00eancia. Simplificando o desenvolvimento de APIs.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi desenvolvido para oferecer uma experi\u00eancia pr\u00e1tica no uso do FastAPI. O objetivo \u00e9 que voc\u00ea obtenha uma compreens\u00e3o das funcionalidades do FastAPI e de boas pr\u00e1ticas associadas a ele.</p> <p>O projeto central do curso ser\u00e1 a constru\u00e7\u00e3o de um gerenciador de tarefas (uma lista de tarefas), come\u00e7ando do zero. Esse projeto incluir\u00e1 a implementa\u00e7\u00e3o da autentica\u00e7\u00e3o do usu\u00e1rio e das opera\u00e7\u00f5es CRUD completas.</p> <p>Para a constru\u00e7\u00e3o do projeto, ser\u00e3o utilizadas as vers\u00f5es mais recentes das ferramentas, dispon\u00edveis em 2025, como a vers\u00e3o 0.115 do FastAPI, a vers\u00e3o 2.0+ do Pydantic, a vers\u00e3o 2.0+ do SQLAlchemy ORM, al\u00e9m do Python 3.11/3.12/3.13 e do Alembic para gerenciamento de migra\u00e7\u00f5es.</p> <p>Al\u00e9m da constru\u00e7\u00e3o do projeto, o curso tamb\u00e9m incluir\u00e1 a pr\u00e1tica de testes, utilizando o pytest. Essa abordagem planeja garantir que as APIs desenvolvidas sejam n\u00e3o somente funcionais, mas tamb\u00e9m robustas e confi\u00e1veis.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Aqui est\u00e1 uma vis\u00e3o geral dos t\u00f3picos que abordaremos neste curso:</p> <ol> <li> <p>Configura\u00e7\u00e3o do ambiente e gerenciamento de um projeto Python: come\u00e7aremos do zero, configurando o ambiente de desenvolvimento. Escolheremos ferramentas adequadas, aplicaremos boas pr\u00e1ticas na constru\u00e7\u00e3o de projetos e integraremos um gerenciador de projetos, task manager, ferramentas de an\u00e1lise est\u00e1tica e formata\u00e7\u00e3o de c\u00f3digo.</p> </li> <li> <p>Primeiros Passos com FastAPI: introduziremos os conceitos do desenvolvimento web com FastAPI, ensinando como criar endpoints, realizar opera\u00e7\u00f5es CRUD, aplicar inje\u00e7\u00e3o de depend\u00eancia, criar schemas e outros fundamentos.</p> </li> <li> <p>Modelagem de Dados com Pydantic, SQLAlchemy e Alembic: aprenderemos a criar e manipular modelos de dados utilizando Pydantic e SQLAlchemy, al\u00e9m de configurar um esquema de migra\u00e7\u00f5es de banco de dados utilizando Alembic.</p> </li> <li> <p>Programa\u00e7\u00e3o Ass\u00edncrona: a partir da metade do curso, focaremos em tornar nosso projeto totalmente ass\u00edncrono, aproveitando os recursos do FastAPI e do SQLAlchemy para opera\u00e7\u00f5es mais eficientes e escal\u00e1veis.</p> </li> <li> <p>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o em FastAPI: construiremos um sistema completo de autentica\u00e7\u00e3o para proteger nossas rotas e garantir que apenas usu\u00e1rios autenticados tenham acesso a dados e funcionalidades espec\u00edficas.</p> </li> <li> <p>Foco em testes: faremos uma introdu\u00e7\u00e3o detalhada ao desenvolvimento orientado a testes, utilizando pytest e coverage, e aprenderemos a configurar um pipeline de integra\u00e7\u00e3o cont\u00ednua com GitHub Actions para garantir a qualidade do c\u00f3digo.</p> </li> <li> <p>Conteinerizando e Fazendo Deploy de sua Aplica\u00e7\u00e3o FastAPI: por fim, aprenderemos a criar um container Docker para nossa aplica\u00e7\u00e3o FastAPI e realizaremos o deploy utilizando Fly.io, preparando a aplica\u00e7\u00e3o para produ\u00e7\u00e3o.</p> </li> </ol>"},{"location":"#esse-curso-e-gratuito","title":"\ud83d\udcb0 Esse curso \u00e9 gratuito?","text":"<p>SIM! Esse curso foi todo desenvolvido de forma aberta e com a ajuda financeira de pessoas incr\u00edveis. Caso voc\u00ea sinta vontade de contribuir, voc\u00ea pode me pagar um caf\u00e9 por pix (pix.dunossauro@gmail.com) ou apoiar a campanha recorrente de financiamento coletivo da live de python que \u00e9 o que paga as contas aqui de casa.</p>"},{"location":"#onde-o-curso-sera-disponibilizado","title":"Onde o curso ser\u00e1 disponibilizado?","text":"<p>Esse material ser\u00e1 disponibilizado em duas formas diferentes:</p> <ol> <li>Em livro texto: todo o material est\u00e1 dispon\u00edvel nessa p\u00e1gina;</li> <li> <p>Em aulas s\u00edncronas ao vivo: para quem prefere o compromisso de acompanhar em grupo.</p> <ul> <li> <p>Playlist das apresenta\u00e7\u00f5es de 2025:     </p> <p>Referente a vers\u00e3o 4.1 do texto</p> </li> <li> <p>Playlist das apresenta\u00e7\u00f5es de 2024:     </p> <p>Referente a vers\u00e3o 1.0 do texto</p> </li> </ul> </li> </ol>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para aproveitar ao m\u00e1ximo este curso, \u00e9 recomendado que voc\u00ea j\u00e1 tenha algum conhecimento pr\u00e9vio em python. Se pudesse listar o que considero importante para n\u00e3o se perder, os t\u00f3picos em python importantes s\u00e3o:</p> <ul> <li>O funcionamento de fun\u00e7\u00f5es: como criar e usar (refer\u00eancia);</li> <li>O funcionamento das estruturas de dados: como listas, dicion\u00e1rios, etc.;</li> <li>Uma pitada sobre objetos: saber o que s\u00e3o m\u00e9todos e atributos (refer\u00eancia);</li> <li>Classes de dados: o funcionamento b\u00e1sico das dataclasses (refer\u00eancia).</li> </ul> <p>As refer\u00eancias servem como base caso voc\u00ea ainda n\u00e3o tenha estudado esses assuntos.</p> <p>Alguns outros t\u00f3picos n\u00e3o relativos a python tamb\u00e9m ser\u00e3o abordados. Ent\u00e3o, \u00e9 interessante que voc\u00ea tenha algum entendimento b\u00e1sico sobre:</p> <ul> <li>Desenvolvimento Web e APIs RESTful: n\u00e3o essencial, pois iremos abordar, mas quanto mais voc\u00ea souber, melhor para acompanhar.</li> <li>Banco de dados / SQL: Um conhecimento b\u00e1sico sobre cria\u00e7\u00e3o e busca de dados usando SQL j\u00e1 \u00e9 suficiente, embora esse t\u00f3pico tamb\u00e9m seja como o anterior, quanto mais voc\u00ea souber, melhor.</li> <li>Git: n\u00e3o nos aprofundaremos nesse t\u00f3pico durante o curso, mas usaremos opera\u00e7\u00f5es elementares de git (como commit e push).</li> <li>Docker: tamb\u00e9m n\u00e3o nos aprofundaremos nesse t\u00f3pico e ele s\u00f3 ser\u00e1 abordado nas aulas finais. Mas, tamb\u00e9m, s\u00f3 usaremos comandos b\u00e1sicos de docker e docker-compose.</li> </ul> Caso esteja iniciando seus estudos em Python! <p>Caso voc\u00ea ainda n\u00e3o se sinta uma pessoa preparada, ou caiu aqui sem saber exatamente o que esperar. Temos um pequeno curso introdut\u00f3rio. Destinado aos primeiros passos com python. </p> <p> Link direto</p> <p>Tamb\u00e9m temos uma live focada em dicas para iniciar os estudos em python</p> <p></p> <p> Link direto</p> <p>Ou ent\u00e3o a leitura do livro Pense em python</p>"},{"location":"#aulas","title":"Aulas","text":"<ol> <li>Configurando o ambiente de desenvolvimento</li> <li>Introdu\u00e7\u00e3o ao desenvolvimento WEB</li> <li>Estruturando seu projeto e criando rotas CRUD</li> <li>Configurando o banco de dados e gerenciando migra\u00e7\u00f5es com Alembic</li> <li>Integrando o banco de dados \u00e0 API</li> <li>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT</li> <li>Refatorando a estrutura do projeto</li> <li>Tornando o projeto ass\u00edncrono</li> <li>Tornando o sistema de autentica\u00e7\u00e3o robusto</li> <li>Criando rotas CRUD para gerenciamento de tarefas</li> <li>Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL</li> <li>Automatizando os testes com integra\u00e7\u00e3o cont\u00ednua</li> <li>Fazendo o deploy no Fly.io</li> <li>Despedida e pr\u00f3ximos passos</li> </ol> <p>Ap\u00f3s todas as aulas, se voc\u00ea sentir que ainda quer evoluir mais e testar seus conhecimentos, temos um projeto final para avaliar o quanto voc\u00ea aprendeu.</p>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"\ud83e\udd96 Quem vai ministrar essas aulas?","text":"<p>Prazer! Eu me chamo Eduardo. As pessoas me conhecem na internet como @dunossauro.</p> <p></p> <p>Sou um programador Python muito apaixonado e curioso. Toco um projeto pessoal semanal chamado Live de Python h\u00e1 pouco mais de 8 anos. Onde conversamos sobre tudo e mais um pouco quando o assunto \u00e9 Python.</p> <p>Adoro escrever (estamos aqui, n\u00e3o \u00e9 mesmo?), programar coisas malucas, fazer m\u00fasica com programa\u00e7\u00e3o e papear sobre software livre, computabilidade e IndieWeb.</p> <p>T\u00f4 sempre pela web e nos eventos de Python, a gente pode se conectar nessa imensa rede mundial de computadores. Meus links!.</p>"},{"location":"#revisao-e-contribuicoes","title":"Revis\u00e3o e contribui\u00e7\u00f5es","text":"<p>Esse material contou com a revis\u00e3o e contribui\u00e7\u00f5es inestim\u00e1veis de pessoas incr\u00edveis:</p> <p>@0xluc, @adorilson, @aguynaldo, @alphabraga, @andrespp, @azmovi, @bugelseif, @EvandroNetoo, @FtxDante, @gabrielhardcore, @gbpagano, @henriqueccda, @henriquesebastiao, @ig0r-ferreira, @itsGab, @ivansantiagojr, @jlplautz, @jonathanscheibel, @jpsalviano, @julioformiga, @kylefelipe, @KennedyRichard, @lbmendes, @lucasmpavelski, @lucianoratamero, @marythealice, @matheusalmeida28, matheussricardoo, @me15degrees, @mmaachado, @NatalNW7, @raiguilhermems, @renan-asantos, @rennerocha, @ricardo-emanuel01, @rodbv, @rodrigosbarretos, @taconi, @thiagonebuloni, @ThiagoEidi, @wanderleihuttel, @williangl, @vcwild, @vdionysio, @ViniciusSouzaRoque</p> <p>Muito obrigado! </p>"},{"location":"#licenca","title":"\ud83d\udcd6 Licen\u00e7a","text":"<p>Todo esse curso foi escrito e produzido por Eduardo Mendes (@dunossauro).</p> <p>Todo esse material \u00e9 gratuito e est\u00e1 sob licen\u00e7a Creative Commons BY-NC-SA. O que significa que:</p> <ul> <li>Voc\u00ea pode copiar e reproduzir esse material em qualquer meio e em qualquer formato;</li> <li>Voc\u00ea pode adaptar esse material e construir outros materiais usando esse material.</li> </ul> <p>Pontos de aten\u00e7\u00e3o:</p> <ul> <li>Voc\u00ea precisa dar os devidos cr\u00e9ditos a esse material onde for usar ou adaptar;</li> <li>Voc\u00ea n\u00e3o pode usar para fins comerciais. Como vender ou usar para obter vantagens comerciais;</li> <li>Todo o material derivado desse material deve ser redistribu\u00eddo com a licen\u00e7a CC BY-NC-SA.</li> </ul>"},{"location":"#ferramentas-necessarias-para-acompanhar-o-curso","title":"\ud83e\uddf0 Ferramentas necess\u00e1rias para acompanhar o curso","text":"<ol> <li>Um editor de texto ou IDE de sua escolha. Estou usando o GNU/Emacs enquanto escrevo as aulas;</li> <li>Um terminal. Todos os exemplos do curso s\u00e3o executados e explicados no terminal. Voc\u00ea pode usar o que se sentir mais a vontade e for compat\u00edvel com seu sistema operacional;</li> <li>Ter o interpretador Python instalado em uma vers\u00e3o oficialmente suportada, atualmente 3.10+.</li> <li>Uma conta no Github: para podermos testar com Github Actions;</li> <li>Uma conta no Fly.io: ferramenta que usaremos para fazer deploy.</li> </ol>"},{"location":"#conclusao","title":"Conclus\u00e3o","text":"<p>Neste curso, a inten\u00e7\u00e3o \u00e9 fornecer uma compreens\u00e3o completa do framework FastAPI, utilizando-o para construir uma aplica\u00e7\u00e3o de gerenciamento de tarefas. O aprendizado ser\u00e1 focado na pr\u00e1tica, e cada conceito ser\u00e1 acompanhado por exemplos e exerc\u00edcios relevantes.</p> <p>A jornada come\u00e7ar\u00e1 com a configura\u00e7\u00e3o do ambiente de desenvolvimento e introdu\u00e7\u00e3o ao FastAPI. Ao longo das aulas, abordaremos t\u00f3picos como autentica\u00e7\u00e3o, opera\u00e7\u00f5es CRUD, testes com pytest e deploy. A \u00eanfase ser\u00e1 colocada na aplica\u00e7\u00e3o de boas pr\u00e1ticas e no entendimento das ferramentas e tecnologias atualizadas, incluindo as vers\u00f5es mais recentes do FastAPI, Pydantic, SQLAlchemy ORM, Python e Alembic.</p> <p>Este conte\u00fado foi pensado para auxiliar na compreens\u00e3o de como criar uma API eficiente e confi\u00e1vel, dando aten\u00e7\u00e3o a aspectos importantes como testes e integra\u00e7\u00e3o com banco de dados.</p> <p>Nos vemos na primeira aula. \u2764</p>"},{"location":"#ferramentas-de-apoio","title":"\ud83d\udd27 Ferramentas de apoio","text":"<p>Todo o conte\u00fado deste material foi produzido intencionalmente com ferramentas FLOSS.</p>"},{"location":"#para-a-pagina","title":"\ud83d\udcdd Para a p\u00e1gina","text":"<p>Toda essa p\u00e1gina foi escrita em markdown usando as seguintes bibliotecas:</p> <ul> <li>MkDocs: Para gera\u00e7\u00e3o das p\u00e1ginas est\u00e1ticas usando Markdown</li> <li>Mkdocs-material: Tema para o MkDocs</li> <li>Pymdown-extensions: Extens\u00f5es para MkDocs, como emojis, diagramas e blocos estilizados de c\u00f3digo</li> <li>Markdown-exec: Utilit\u00e1rios para executar snippets din\u00e2micos de c\u00f3digo e adicionar o resultado em markdown</li> <li>Python-Markdown: Extens\u00e3o do Python para Markdown</li> <li>Mkdocs-video: Extens\u00e3o para o MkDocs exibir os v\u00eddeos na p\u00e1gina</li> <li>mkdocs-towncrier: Extens\u00e3o para exibir os changelogs do towncrier no mkdocs</li> <li>Mkdocs-quiz: Para os question\u00e1rios sobre as aulas</li> <li>mkdocs-video: Para exibir os v\u00eddeos do youtube nas p\u00e1ginas</li> <li>mkdocs-macros: Para cria\u00e7\u00e3o de macros e varia\u00e7\u00f5es de textos usando vari\u00e1veis</li> <li>mike: Para manter m\u00faltiplas vers\u00f5es do mkdocs online</li> </ul> <p>Ferramentas que n\u00e3o fazem parte do ecossistema markdown, mas se misturam:</p> <ul> <li>jinja2: Para escrever blocos reutiliz\u00e1veis</li> <li>Mermaid.js: Constru\u00e7\u00e3o dos diagramas</li> <li>Glaxnimate: Para criar a anima\u00e7\u00e3o no topo dessa p\u00e1gina</li> <li>Lottie-Player: Para exibir a anima\u00e7\u00e3o do Glaxnimate</li> </ul>"},{"location":"#para-os-slides","title":"\ud83d\udcac Para os slides","text":"<p>Tudo tamb\u00e9m feito com markdown, usando:</p> <ul> <li>marp: Onde preparei os slides</li> <li>Rose-Pine: Tema que usei no marp</li> </ul>"},{"location":"#para-as-transmissoes","title":"\ud83d\udcfa Para as transmiss\u00f5es","text":"<p>Foi utilizado o Open Broadcaster Software (OBS).</p>"},{"location":"#thumbnails-para-youtube","title":"\ud83d\uddbc\ufe0f Thumbnails para YouTube","text":"<p>Para tratamento das imagens foi usado o Darktable, para a composi\u00e7\u00e3o das thumbnails foi usado o Inkscape.</p>"},{"location":"#repositorio","title":"\ud83d\udcc1 Reposit\u00f3rio","text":"<p>O versionamento de tudo est\u00e1 sendo feito pelo git e est\u00e1 dispon\u00edvel no reposit\u00f3rio do curso Github.</p>"},{"location":"#deploy","title":"\ud83d\ude80 Deploy","text":"<p>Os deploys das p\u00e1ginas est\u00e1ticas geradas pelo MkDocs est\u00e3o sendo feitos no Netlify</p>"},{"location":"#faq","title":"\u2753 F.A.Q.","text":"<p>Perguntas frequentes n\u00e3o t\u00e9cnicas que me fizeram durante as aulas:</p> <ul> <li>Que papel de parede \u00e9 esse? \u00c9 uma foto do Liam Wong.</li> <li>Qual sistema operacional est\u00e1 usando? Eu uso GNU/Linux, a distribui\u00e7\u00e3o \u00e9 o EndeavourOS.</li> <li>Qual terminal est\u00e1 usando? O Terminator.</li> <li>Qual editor de texto est\u00e1 usando? O GNU/Emacs.</li> <li>Qual o tema que est\u00e1 suando no sistema? O Catppuccin Mocha. Eu uso ele no shell e no editor de texto.</li> <li>Onde est\u00e3o suas configura\u00e7\u00f5es do sistema? Em https://dunossauro.com/dotfiles.</li> </ul>"},{"location":"01/","title":"Configurando o ambiente de desenvolvimento","text":""},{"location":"01/#configurando-o-ambiente-de-desenvolvimento","title":"Configurando o ambiente de desenvolvimento","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao ambiente de desenvolvimento (terminal, ferramentas, etc.)</li> <li>Instala\u00e7\u00e3o do FastAPI e suas depend\u00eancias</li> <li>Configura\u00e7\u00e3o das ferramentas de desenvolvimento</li> <li>Execu\u00e7\u00e3o do primeiro \"Hello, World!\" com FastAPI com testes!</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Nesta aula, iniciaremos nossa jornada na constru\u00e7\u00e3o de uma API com FastAPI. Partiremos do b\u00e1sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala\u00e7\u00e3o da vers\u00e3o correta do Python at\u00e9 a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Poetry, um gerenciador de pacotes e depend\u00eancias para Python. Al\u00e9m disso, instalaremos e configuraremos uma s\u00e9rie de ferramentas de desenvolvimento \u00fateis, como Ruff, pytest e Taskipy.</p> <p>Ap\u00f3s configurado o nosso ambiente, criaremos nosso primeiro programa \"Hello, World!\" com FastAPI. Isso nos permitir\u00e1 confirmar que tudo est\u00e1 funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.</p>"},{"location":"01/#ambiente-de-desenvolvimento","title":"Ambiente de Desenvolvimento","text":"<p>Para iniciar esse curso, voc\u00ea precisa de algumas ferramentas instaladas:</p> <ol> <li>Um editor de texto a sua escolha (Usarei o GNU/Emacs)</li> <li>Um terminal a sua escolha (Usarei o Terminator)</li> <li>Python, em uma vers\u00e3o oficialmente suportada, atualmente 3.10+</li> <li>Git: Para gerenciar vers\u00f5es do nosso projeto. (Caso precise de um tutorial legal sobre git, o TeoMeWhy fez uma playlist muito legal, totalmente de gra\u00e7a)</li> <li>Docker: Para criar um container da nossa aplica\u00e7\u00e3o (caso n\u00e3o tenha nenhuma experi\u00eancia com docker a Linuxtips tem uma playlist completa e gr\u00e1tis sobre docker no canal deles no YouTube)<sup>4</sup></li> <li>OPCIONAL (extremamente recomendado): O gh para criar o reposit\u00f3rio e fazer altera\u00e7\u00f5es sem precisar acessar a p\u00e1gina do Github</li> </ol> <p>\ud83d\udea8 Caso voc\u00ea precise de ajuda com a instala\u00e7\u00e3o dessas ferramentas, temos um ap\u00eandice especial para te ajudar com isso!. Basta clicar em achar a ferramenta que deseja instalar! \ud83d\udea8</p> Sobre as vers\u00f5es das bibliotecas instaladas <p>A \u00faltima atualiza\u00e7\u00e3o dos pacotes deste material foi feita em: 31/10/2025 \u00e0s 11:47.</p> <p>Caso voc\u00ea esteja lendo este material em um futuro distante ou enfrente erros de instala\u00e7\u00e3o, o ap\u00eandice C cont\u00e9m todas as vers\u00f5es usadas no ambiente de forma detalhada.</p>"},{"location":"01/#pipx","title":"pipx","text":"<p>O pipx \u00e9 uma ferramenta usada para instalar e executar ferramentas Python globalmente no sistema de forma segura. Diferente do pip, que instala ferramentas sem um ambiente virtual (por padr\u00e3o) e pode \"sujar\" nosso ambiente, o <code>pipx</code> cria um ambiente virtual e isola cada ferramenta dentro dele, facilitando a instala\u00e7\u00e3o de pacotes globais.</p> <p>Em nosso projeto, usaremos o pipx para instalar ferramentas globais e executar algumas que ser\u00e3o usadas apenas uma vez.</p> <p>Para instalar o pipx:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pip install --user pipx\n</code></pre> <p>Dessa forma, a \u00fanica depend\u00eancia global que teremos no nosso sistema ser\u00e1 o pr\u00f3prio <code>pipx</code>.</p> Existem outras formas de instalar o pipx <p>Caso voc\u00ea tenha um gerenciador de pacotes no seu sistema operacional, \u00e9 extremamente recomendado que voc\u00ea instale o <code>pipx</code> por ele.</p> <p>As instru\u00e7\u00f5es de instala\u00e7\u00e3o para cada sistema est\u00e3o dispon\u00edveis na documenta\u00e7\u00e3o do projeto.</p> <p>Para o nosso sistema reconhecer o caminho das ferramentas instaladas via <code>pipx</code> podemos executar o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx ensurepath #(1)!\n</code></pre> <ol> <li>Adiciona o diret\u00f3rio dos ambientes virtuais do <code>pipx</code> ao <code>PATH</code> do sistema.</li> </ol> <p>Esse comando adiciona ao <code>PATH</code> do sistema todos os bin\u00e1rios instalados pelo <code>pipx</code> \ud83d\udea8. Portanto, lembre-se de reiniciar o shell ap\u00f3s execut\u00e1-lo.</p>"},{"location":"01/#poetry","title":"Poetry","text":"<p>O Poetry \u00e9 um gerenciador de projetos para Python. Ele pode nos ajudar em diversas etapas do ciclo de desenvolvimento, como a instala\u00e7\u00e3o de vers\u00f5es espec\u00edficas do Python, a cria\u00e7\u00e3o e manuten\u00e7\u00e3o de projetos (incluindo a defini\u00e7\u00e3o de estruturas de pastas, o gerenciamento de ambientes virtuais e a instala\u00e7\u00e3o de bibliotecas), al\u00e9m de permitir a publica\u00e7\u00e3o de pacotes e muito mais.</p> <p>No nosso projeto, ele ser\u00e1 o componente central para agrupar e executar todas as tarefas relacionadas ao projeto.</p> Caso esse seja seu primeiro contato com o Poetry <p>Temos uma live de python explicando somente ele:</p> <p></p> <p> Link direto</p>"},{"location":"01/#instalacao-do-poetry","title":"Instala\u00e7\u00e3o do poetry","text":"<p>A instala\u00e7\u00e3o do Poetry pode ser feita de diversas maneiras, mas a forma que recomendo, para uma instala\u00e7\u00e3o global e isolada em um ambiente virtual, \u00e9 via <code>pipx</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx install poetry #(1)!\n</code></pre> <ol> <li>Cria um ambiente virtual isolado para poetry e o deixa dispon\u00edvel no sistema.</li> </ol> Coment\u00e1rios em blocos <p>Blocos de c\u00f3digo costumam ter coment\u00e1rios com informa\u00e7\u00f5es adicionais, como este: </p> <p>Ao clicar em  um bloco de coment\u00e1rio se abrir\u00e1, exibindo mais informa\u00e7\u00f5es:</p> <p></p> <p>E, para facilitar nosso fluxo de trabalho com ambientes virtuais, vamos instalar uma extens\u00e3o do Poetry para habilitar o shell:</p> via pipxvia poetry self $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx inject poetry poetry-plugin-shell #(1)!\n</code></pre> <ol> <li>O comando <code>inject</code> instala um pacote em um ambiente virtual \"global\" j\u00e1 criado. Neste caso, estamos injetando o comando <code>poetry shell</code>, que nos permite entrar nos ambientes virtuais.</li> </ol> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry self add poetry-plugin-shell #(1)!\n</code></pre> <ol> <li>A fun\u00e7\u00e3o <code>self add</code> do Poetry instala extens\u00f5es para podermos executar novos comandos com o Poetry, neste caso, o comando <code>poetry shell</code>, que nos permite entrar nos ambientes virtuais.</li> </ol> <p>Essa extens\u00e3o adiciona o comando <code>poetry shell</code>, que habilita o ambiente virtual no terminal.</p>"},{"location":"01/#gerenciamento-de-versoes-do-python","title":"Gerenciamento de vers\u00f5es do Python","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o do Poetry, podemos utiliz\u00e1-lo para gerenciar e instalar vers\u00f5es do Python que desejamos usar em um projeto. Para acompanhar este curso, a vers\u00e3o m\u00ednima do Python que voc\u00ea deve ter \u00e9 a <code>3.11</code>, pois alguns recursos que utilizaremos foram introduzidos nessa vers\u00e3o.</p> <p>Voc\u00ea pode, no entanto, instalar qualquer vers\u00e3o mais nova. Minha recomenda\u00e7\u00e3o \u00e9 sempre que poss\u00edvel, use a vers\u00e3o mais atualizada poss\u00edvel:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 <p>Para utilizarmos uma vers\u00e3o espec\u00edfica do Python em nosso ambiente, devemos solicitar ao Poetry que instale essa vers\u00e3o: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>poetry python install 3.14  #(1)!\n</code></pre><p></p> <ol> <li>Instala a \u00faltima release da vers\u00e3o 3.14 do python</li> </ol> <p>Uma resposta similar a esta deve ser retornada ao executar o comando:</p> Resposta do comando `poetry python install`<pre><code>Downloading and installing 3.14.0 (cpython) ... Done #(1)!\nTesting 3.14.0 (cpython) ... Done\n</code></pre> <ol> <li>3.14.0 \u00e9 a \u00faltima release da vers\u00e3o lan\u00e7ada enquanto esscrevia esse material.</li> </ol> <p>Para utilizarmos uma vers\u00e3o espec\u00edfica do Python em nosso ambiente, devemos solicitar ao Poetry que instale essa vers\u00e3o: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>poetry python install 3.13  #(1)!\n</code></pre><p></p> <ol> <li>Instala a \u00faltima release da vers\u00e3o 3.13 do python</li> </ol> <p>Uma resposta similar a esta deve ser retornada ao executar o comando:</p> Resposta do comando `poetry python install`<pre><code>Downloading and installing 3.13.2 (cpython) ... Done #(1)!\nTesting 3.13.2 (cpython) ... Done\n</code></pre> <ol> <li>3.13.2 \u00e9 a \u00faltima release da vers\u00e3o lan\u00e7ada enquanto esscrevia esse material.</li> </ol> <p>Para utilizarmos uma vers\u00e3o espec\u00edfica do Python em nosso ambiente, devemos solicitar ao Poetry que instale essa vers\u00e3o: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>poetry python install 3.12  #(1)!\n</code></pre><p></p> <ol> <li>Instala a \u00faltima release da vers\u00e3o 3.12 do python</li> </ol> <p>Uma resposta similar a esta deve ser retornada ao executar o comando:</p> Resposta do comando `poetry python install`<pre><code>Downloading and installing 3.12.9 (cpython) ... Done #(1)!\nTesting 3.12.9 (cpython) ... Done\n</code></pre> <ol> <li>3.12.9 \u00e9 a \u00faltima release da vers\u00e3o lan\u00e7ada enquanto esscrevia esse material.</li> </ol> <p>Para utilizarmos uma vers\u00e3o espec\u00edfica do Python em nosso ambiente, devemos solicitar ao Poetry que instale essa vers\u00e3o: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>poetry python install 3.11  #(1)!\n</code></pre><p></p> <ol> <li>Instala a \u00faltima release da vers\u00e3o 3.11 do python</li> </ol> <p>Uma resposta similar a esta deve ser retornada ao executar o comando:</p> Resposta do comando `poetry python install`<pre><code>Downloading and installing 3.11.11 (cpython) ... Done #(1)!\nTesting 3.11.11 (cpython) ... Done\n</code></pre> <ol> <li>3.11.11 \u00e9 a \u00faltima release da vers\u00e3o lan\u00e7ada enquanto esscrevia esse material.</li> </ol> <p>Dessa forma, garantimos que temos uma vers\u00e3o compat\u00edvel do Python instalada.</p>"},{"location":"01/#criando-um-projeto","title":"Criando um projeto","text":"<p>Agora que temos o poetry e a vers\u00e3o do python que usaremos dispon\u00edvel, podemos iniciar a cria\u00e7\u00e3o do nosso projeto. O primeiro passo \u00e9 criar um novo projeto utilizando o Poetry, com o comando <code>poetry new</code>. Em seguida, navegaremos at\u00e9 o diret\u00f3rio criado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry new --flat fast_zero #(1)!\ncd fast_zero\n</code></pre> <ol> <li>Cria um pacote python chamado <code>fast_zero</code> no formato <code>flat</code>. Por padr\u00e3o, o poetry utiliza o formato <code>src</code>. Mais informa\u00e7\u00f5es sobre isso aqui</li> </ol> <p>Ele criar\u00e1 uma estrutura de arquivos e pastas como essa:</p> <pre><code>.\n\u251c\u2500\u2500 fast_zero\n\u2502  \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Com a estrutura inicial do projeto criada e estando no diret\u00f3rio do projeto, podemos informar ao Poetry que queremos usar a vers\u00e3o do Python que instalamos. Para isso, utilizamos o seguinte comando:</p> Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry env use 3.13\n</code></pre> <p>Em conjunto com essa instru\u00e7\u00e3o, devemos tamb\u00e9m especificar no Poetry que usaremos exatamente a vers\u00e3o <code>3.13</code> em nosso projeto. Para isso, alteramos o arquivo de configura\u00e7\u00e3o pyproject.toml na raiz do projeto:</p> pyproject.toml<pre><code>[project]\n# ...\nrequires-python = \"&gt;=3.13,&lt;4.0\" # (1)!\n</code></pre> <ol> <li>A express\u00e3o <code>\"&gt;=3.13,&lt;4.0\"</code> significa que qualquer vers\u00e3o maior ou igual a <code>3.13</code> e menor que 4.0 ser\u00e1 v\u00e1lida para o projeto.</li> </ol> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry env use 3.12\n</code></pre> <p>Em conjunto com essa instru\u00e7\u00e3o, devemos tamb\u00e9m especificar no Poetry que usaremos exatamente a vers\u00e3o <code>3.12</code> em nosso projeto. Para isso, alteramos o arquivo de configura\u00e7\u00e3o pyproject.toml na raiz do projeto:</p> pyproject.toml<pre><code>[project]\n# ...\nrequires-python = \"&gt;=3.12,&lt;4.0\" # (1)!\n</code></pre> <ol> <li>A express\u00e3o <code>\"&gt;=3.12,&lt;4.0\"</code> significa que qualquer vers\u00e3o maior ou igual a <code>3.12</code> e menor que 4.0 ser\u00e1 v\u00e1lida para o projeto.</li> </ol> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry env use 3.11\n</code></pre> <p>Em conjunto com essa instru\u00e7\u00e3o, devemos tamb\u00e9m especificar no Poetry que usaremos exatamente a vers\u00e3o <code>3.11</code> em nosso projeto. Para isso, alteramos o arquivo de configura\u00e7\u00e3o pyproject.toml na raiz do projeto:</p> pyproject.toml<pre><code>[project]\n# ...\nrequires-python = \"&gt;=3.11,&lt;4.0\" # (1)!\n</code></pre> <ol> <li>A express\u00e3o <code>\"&gt;=3.11,&lt;4.0\"</code> significa que qualquer vers\u00e3o maior ou igual a <code>3.11</code> e menor que 4.0 ser\u00e1 v\u00e1lida para o projeto.</li> </ol> <p>Dessa forma, garantimos que o Poetry usar\u00e1 a vers\u00e3o correta do Python ao criar o ambiente virtual para o nosso projeto.</p>"},{"location":"01/#instalando-o-fastapi","title":"Instalando o FastAPI","text":"<p>Com toda a base do nosso projeto pronta, podemos finalmente instalar o FastAPI:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry install # (1)!\npoetry add 'fastapi[standard]' # (2)!\n</code></pre> <ol> <li>Cria o ambiente virtual com a vers\u00e3o que setamos no <code>env use</code></li> <li>Adiciona o FastAPI no nosso projeto e ambiente virtual</li> </ol>"},{"location":"01/#primeira-execucao-de-um-hello-world","title":"Primeira Execu\u00e7\u00e3o de um \"Hello, World!\"","text":"<p>Uma coisa bastante interessante sobre o FastAPI \u00e9 que ele \u00e9 um framework web baseado em fun\u00e7\u00f5es. Da mesma forma em que criamos fun\u00e7\u00f5es tradicionalmente em python, podemos estender essas fun\u00e7\u00f5es para que elas sejam servidas pelo servidor. Por exemplo:</p> fast_zero/app.py<pre><code>def read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Essa fun\u00e7\u00e3o em python basicamente retorna um dicion\u00e1rio com uma chave chamada <code>'message'</code> e uma mensagem <code>'Ol\u00e1 Mundo!'</code>. Se adicionarmos essa fun\u00e7\u00e3o em novo arquivo chamado <code>app.py</code> no diret\u00f3rio <code>fast_zero</code>. Podemos fazer a chamada dela pelo terminal interativo (REPL):</p> &gt;&gt;&gt; Terminal interativo!<pre><code>&gt;&gt;&gt; read_root()\n{'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>De forma tradicional, como todas as fun\u00e7\u00f5es em python.</p> Dica: Como abrir o terminal interativo (REPL) <p>Para abrir o terminal interativo com o seu c\u00f3digo carregado, voc\u00ea deve chamar o Python no terminal usando <code>-i</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python -i &lt;seu_arquivo.py&gt;\n</code></pre> <p>O interpretador do Python executa o c\u00f3digo do arquivo e retorna o shell ap\u00f3s executar tudo que est\u00e1 escrito no arquivo.</p> <p>Para o nosso caso espec\u00edfico, como o nome do arquivo \u00e9 <code>fast_zero/app.py</code>, devemos executar esse comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python -i fast_zero/app.py\n</code></pre> <p>Desta forma, usando somente um decorador do FastAPI, podemos fazer com que uma determinada fun\u00e7\u00e3o seja acess\u00edvel pela rede:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI # (1)!\n\napp = FastAPI()  # (2)!\n\n@app.get('/')  # (3)!\ndef read_root():  # (4)!\n    return {'message': 'Ol\u00e1 Mundo!'} # (5)!\n</code></pre> <ol> <li>Importando da biblioteca fastapi o objeto FastAPI</li> <li>Iniciando uma aplica\u00e7\u00e3o FastAPI</li> <li>Definindo um endpoint com o endere\u00e7o <code>/</code> acess\u00edvel pelo m\u00e9todo HTTP <code>GET</code></li> <li>Fun\u00e7\u00e3o que ser\u00e1 executada quando o endere\u00e7o <code>/</code> for acessado por um cliente</li> <li>Os dados que ser\u00e3o retornados pelo endere\u00e7o, quando o endpoint for chamado</li> </ol> <p>A linha em destaque <code>@app.get('/')</code> exp\u00f5e a nossa fun\u00e7\u00e3o para ser servida pelo FastAPI. Dizendo que quando um cliente acessar o nosso endere\u00e7o de rede no caminho <code>/</code>, usando o m\u00e9todo HTTP GET<sup>1</sup>, a fun\u00e7\u00e3o ser\u00e1 executada. Desta maneira, temos todo o c\u00f3digo necess\u00e1rio para criar nossa primeira aplica\u00e7\u00e3o web com FastAPI.</p> <p>Antes de iniciarmos nossa aplica\u00e7\u00e3o, temos que fazer um passo importante, habilitar o ambiente virtual, para que o python consiga enxergar nossas depend\u00eancias instaladas. O poetry tem um comando espec\u00edfico para isso:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry shell\n</code></pre> <p>Agora com o ambiente virtual ativo, podemos iniciar nosso servidor FastAPI para iniciar nossa aplica\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fastapi dev fast_zero/app.py\n</code></pre> <p>Esse comando diz ao FastAPI para iniciar o servidor de desenvolvimento (<code>dev</code>) usando o arquivo <code>fast_zero/app.py</code></p> Executar de fora do ambiente virtual <p>Tamb\u00e9m \u00e9 poss\u00edvel executar os comandos sem entrar no shell do ambiente virtual. \u00c9 mais verboso, mas funciona bem:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry run fastapi dev fast_zero/app.py\n</code></pre> <p>Isso evita rodar a combina\u00e7\u00e3o de comandos: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>poetry shell\nfastapi dev fast_zero/app.py\n</code></pre><p></p> <p>A resposta do comando no terminal deve ser parecida com essa:</p> Resposta do comando `fastapi dev fast_zero/app.py`<pre><code>INFO     Using path fast_zero/app.py\nINFO     Resolved absolute path /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01/fast_zero/app.py\nINFO     Searching for package file structure from directories with __init__.py files\nINFO     Importing from /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01\n\n \u256d\u2500 Python package file structure \u2500\u256e\n \u2502                                 \u2502\n \u2502  \ud83d\udcc1 fast_zero                   \u2502\n \u2502  \u251c\u2500\u2500 \ud83d\udc0d __init__.py             \u2502\n \u2502  \u2514\u2500\u2500 \ud83d\udc0d app.py                  \u2502\n \u2502                                 \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nINFO     Importing module fast_zero.app\nINFO     Found importable FastAPI app\n\n \u256d\u2500\u2500\u2500\u2500 Importable FastAPI app \u2500\u2500\u2500\u2500\u2500\u256e\n \u2502                                 \u2502\n \u2502  from fast_zero.app import app  \u2502\n \u2502                                 \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nINFO     Using import string fast_zero.app:app\n\n \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 FastAPI CLI - Development mode \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n \u2502                                                     \u2502\n \u2502  Serving at: http://127.0.0.1:8000                  \u2502\n \u2502                                                     \u2502\n \u2502  API docs: http://127.0.0.1:8000/docs               \u2502\n \u2502                                                     \u2502\n \u2502  Running in development mode, for production use:   \u2502\n \u2502                                                     \u2502\n \u2502  fastapi run                                        \u2502\n \u2502                                                     \u2502\n \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nINFO:     Will watch for changes in these directories: ['/home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01']\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [893203] using WatchFiles\nINFO:     Started server process [893207]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>A mensagem de resposta do CLI: <code>serving: http://127.0.0.1:8000</code> tem uma informa\u00e7\u00e3o bastante importante.</p> <p> </p> <ol> <li>Ela nos mostra qual protocolo est\u00e1 sendo utilizado, no caso o HTTP, que \u00e9 o protocolo padr\u00e3o da web;</li> <li>O endere\u00e7o de rede (IP) que est\u00e1 escutando, no caso <code>127.0.0.1</code>, endere\u00e7o especial (loopback) que aponta para a nossa pr\u00f3pria m\u00e1quina;</li> <li>A porta <code>:8000</code>, a qual \u00e9 a porta da nossa m\u00e1quina que est\u00e1 reservada para nossa aplica\u00e7\u00e3o.</li> </ol> <p>Agora, com o servidor inicializado, podemos usar um cliente para acessar o endere\u00e7o http://127.0.0.1:8000.</p> <p>O cliente mais tradicional da web \u00e9 o navegador, podemos digitar o endere\u00e7o na barra de navega\u00e7\u00e3o e se tudo ocorreu corretamente, voc\u00ea deve ver a mensagem \"Ol\u00e1 Mundo!\" em formato JSON.</p> <p></p> <p>Para parar a execu\u00e7\u00e3o do fastapi no shell, voc\u00ea pode digitar Ctrl+C e a mensagem <code>Shutting down</code> aparecer\u00e1, mostrando que o servidor foi finalizado.</p> Diferentes clientes para nossa aplica\u00e7\u00e3o <p>Caso exista uma curiosidade sobre outros clientes HTTP que n\u00e3o o browser, podemos usar aplica\u00e7\u00f5es de linha de comando como a tradicional curl:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>curl 127.0.0.1:8000\n{\"message\":\"Ol\u00e1 Mundo!\"}\n</code></pre> <p>Ou o meu cliente HTTP preferido (escrito em python), o HTTPie:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>http 127.0.0.1:8000\nHTTP/1.1 200 OK\ncontent-length: 25\ncontent-type: application/json\ndate: Thu, 11 Jan 2024 11:46:32 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 Mundo!\"\n}\n</code></pre> <p>Existem at\u00e9 mesmo aplica\u00e7\u00f5es gr\u00e1ficas de c\u00f3digo aberto pensadas para serem clientes HTTP para APIs. Como o hoppscotch:</p> <p></p> <p>Ou como o Bruno: </p>"},{"location":"01/#uvicorn","title":"Uvicorn","text":"<p>O FastAPI \u00e9 \u00f3timo para criar APIs, mas n\u00e3o pode disponibiliz\u00e1-las na rede sozinho. Embora o FastAPI tenha uma aplica\u00e7\u00e3o de terminal que facilita a execu\u00e7\u00e3o. Para podermos acessar essas APIs por um navegador ou de outras aplica\u00e7\u00f5es clientes, \u00e9 necess\u00e1rio um servidor. \u00c9 a\u00ed que o Uvicorn entra em cena. Ele atua como esse servidor, disponibilizando a API do FastAPI em rede. Isso permite que a API seja acessada de outros dispositivos ou programas.</p> <p>Como notamos na resposta do comando <code>fastapi dev fast_zero/app.py</code>:</p> Fim da resposta de `fastapi dev fast_zero/app.py`<pre><code>INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [893203] using WatchFiles\nINFO:     Started server process [893207]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>Sempre que usarmos o fastapi para inicializar a aplica\u00e7\u00e3o no shell, ele faz uma chamada interna para inicializar o uvicorn. Por esse motivo, ele aparece nas respostas HTTP e tamb\u00e9m na execu\u00e7\u00e3o do comando.</p> Voc\u00ea poderia chamar a aplica\u00e7\u00e3o diretamente pelo Uvicorn tamb\u00e9m <p></p>$ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn fast_zero.app:app\n</code></pre> Esse comando diz ao uvicorn o seguinte: na pasta fast_zero existe um arquivo chamado app. Dentro desse arquivo, temos uma aplica\u00e7\u00e3o para ser servida com o nome de app. O comando \u00e9 composto por uvicorn pasta.arquivo:vari\u00e1vel.<p></p> <p>A resposta do comando no terminal deve ser parecida com essa:</p> Resultado do comando<pre><code>INFO:     Started server process [127946]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre>"},{"location":"01/#instalando-as-ferramentas-de-desenvolvimento","title":"Instalando as ferramentas de desenvolvimento","text":"<p>As escolhas de ferramentas de desenvolvimento, de forma geral, s\u00e3o escolhas bem particulares. N\u00e3o costumam ser consensuais nem mesmo em times de desenvolvimento. Dito isso, selecionei algumas ferramentas que gosto de usar e alinhadas com a utilidade que elas apresentam no desenvolvimento do projeto.</p> <p>As ferramentas escolhidas s\u00e3o:</p> <ul> <li>taskipy: ferramenta usada para cria\u00e7\u00e3o de comandos. Como executar a aplica\u00e7\u00e3o, rodar os testes, etc.</li> <li>pytest: ferramenta para escrever e executar testes</li> <li>ruff: Uma ferramenta que tem duas fun\u00e7\u00f5es no nosso c\u00f3digo:<ol> <li>Um analisador est\u00e1tico de c\u00f3digo (um linter), para dizer se n\u00e3o estamos infringindo alguma boa pr\u00e1tica de programa\u00e7\u00e3o;</li> <li>Um formatador de c\u00f3digo. Para seguirmos um estilo \u00fanico de c\u00f3digo. Vamos nos basear na PEP-8.</li> </ol> </li> </ul> <p>Para instalar essas ferramentas que usaremos em desenvolvimento, podemos usar um grupo de depend\u00eancias (<code>--group dev</code> no poetry) focado nelas, para n\u00e3o serem instaladas quando nossa aplica\u00e7\u00e3o estiver em produ\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev pytest pytest-cov taskipy ruff\n</code></pre>"},{"location":"01/#configurando-as-ferramentas-de-desenvolvimento","title":"Configurando as ferramentas de desenvolvimento","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o das ferramentas de desenvolvimento, precisamos definir as configura\u00e7\u00f5es de cada uma individualmente no arquivo <code>pyproject.toml</code>.</p>"},{"location":"01/#ruff","title":"Ruff","text":"<p>O Ruff \u00e9 uma ferramenta moderna em python, escrita em rust, compat\u00edvel<sup>2</sup> com os projetos de an\u00e1lise est\u00e1tica escritos e mantidos originalmente pela comunidade no projeto PYCQA<sup>3</sup> e tem duas fun\u00e7\u00f5es principais:</p> <ol> <li>Analisar o c\u00f3digo de forma est\u00e1tica (Linter): Efetuar a verifica\u00e7\u00e3o se estamos programando de acordo com boas pr\u00e1ticas do python.</li> <li>Formatar o c\u00f3digo (Formatter): Efetuar a verifica\u00e7\u00e3o do c\u00f3digo para padronizar um estilo de c\u00f3digo pr\u00e9-definido.</li> </ol> <p>Para configurar o ruff montamos a configura\u00e7\u00e3o em 3 tabelas distintas no arquivo <code>pyproject.toml</code>. Uma para as configura\u00e7\u00f5es globais, uma para o linter e uma para o formatador.</p> <p>Configura\u00e7\u00e3o global</p> <p>Na configura\u00e7\u00e3o global do Ruff queremos alterar somente duas coisas. O comprimento de linha para 79 caracteres (conforme sugerido na PEP-8) e, em seguida, informaremos que o diret\u00f3rio de migra\u00e7\u00f5es de banco de dados ser\u00e1 ignorado na checagem e na formata\u00e7\u00e3o:</p> pyproject.toml<pre><code>[tool.ruff]\nline-length = 79\n</code></pre> Nota sobre \"migrations\" <p>Nessa fase de configura\u00e7\u00e3o, excluiremos a pasta <code>migrations</code>, isso pode n\u00e3o fazer muito sentido nesse momento. Contudo, quando iniciarmos o trabalho com o banco de dados, a ferramenta <code>Alembic</code> faz gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico. Por serem c\u00f3digos gerados automaticamente, n\u00e3o queremos alterar a configura\u00e7\u00e3o feita por ela.</p> <p>Linter</p> <p>Durante a an\u00e1lise est\u00e1tica do c\u00f3digo, queremos buscar por coisas espec\u00edficas. No Ruff, precisamos dizer exatamente o que ele deve analisar. Isso \u00e9 feito por c\u00f3digos. Usaremos estes:</p> <ul> <li><code>I</code> (Isort): Checagem de ordena\u00e7\u00e3o de imports em ordem alfab\u00e9tica</li> <li><code>F</code> (Pyflakes): Procura por alguns erros em rela\u00e7\u00e3o a boas pr\u00e1ticas de c\u00f3digo</li> <li><code>E</code> (Erros pycodestyle): Erros de estilo de c\u00f3digo</li> <li><code>W</code> (Avisos pycodestyle): Avisos de coisas n\u00e3o recomendadas no estilo de c\u00f3digo</li> <li><code>PL</code> (Pylint): Como o <code>F</code>, tamb\u00e9m procura por erros em rela\u00e7\u00e3o a boas pr\u00e1ticas de c\u00f3digo</li> <li><code>PT</code> (flake8-pytest): Checagem de boas pr\u00e1ticas do Pytest</li> </ul> pyproject.toml<pre><code>[tool.ruff.lint]\npreview = true\n</code></pre> <p>Para mais informa\u00e7\u00f5es sobre a configura\u00e7\u00e3o e sobre os c\u00f3digos do ruff e dos projetos do PyCQA, voc\u00ea pode checar a documenta\u00e7\u00e3o do ruff ou as documenta\u00e7\u00f5es originais dos projetos PyQCA.</p> <p>Formatter</p> <p>A formata\u00e7\u00e3o do Ruff praticamente n\u00e3o precisa ser alterada. Pois ele vai seguir as boas pr\u00e1ticas e usar a configura\u00e7\u00e3o global de <code>79</code> caracteres por linha. A \u00fanica altera\u00e7\u00e3o que farei \u00e9 o uso de aspas simples <code>'</code> no lugar de aspas duplas <code>\"</code>:</p> pyproject.toml<pre><code>[tool.ruff.format]\npreview = true\n</code></pre> <p>Lembrando que a op\u00e7\u00e3o de usar aspas simples \u00e9 totalmente pessoal, voc\u00ea pode usar aspas duplas se quiser.</p>"},{"location":"01/#pytest","title":"pytest","text":"<p>O Pytest \u00e9 uma framework de testes, que usaremos para escrever e executar nossos testes. O configuraremos para reconhecer o caminho base para execu\u00e7\u00e3o dos testes na raiz do projeto <code>.</code>:</p> pyproject.toml<pre><code>[tool.pytest.ini_options]\npythonpath = \".\"\n</code></pre> <p>Na segunda linha, dizemos para o pytest adicionar a op\u00e7\u00e3o <code>no:warnings</code>. Para ter uma visualiza\u00e7\u00e3o mais limpa dos testes, caso alguma biblioteca exiba uma mensagem de warning, isso ser\u00e1 suprimido pelo pytest.</p>"},{"location":"01/#taskipy","title":"Taskipy","text":"<p>A ideia do Taskipy \u00e9 ser um executor de tarefas (task runner) complementar em nossa aplica\u00e7\u00e3o. No lugar de ter que lembrar comandos como o do fastapi, que vimos na execu\u00e7\u00e3o da aplica\u00e7\u00e3o, que tal substituir ele simplesmente por <code>task run</code>?</p> <p>Isso funcionaria para qualquer comando complicado em nossa aplica\u00e7\u00e3o. Simplificando as chamadas e tamb\u00e9m para n\u00e3o termos que lembrar de como executar todos os comandos de cabe\u00e7a.</p> <p>Alguns comandos que criaremos agora no in\u00edcio:</p> pyproject.toml<pre><code>[tool.taskipy.tasks]\nlint = 'ruff check'\npre_format = 'ruff check --fix'\nformat = 'ruff format'\nrun = 'fastapi dev fast_zero/app.py'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\n</code></pre> <p>Os comandos definidos fazem o seguinte:</p> <ul> <li><code>lint</code>: Faz a checagem de boas pr\u00e1ticas do c\u00f3digo python</li> <li><code>pre_format</code>: Faz algumas corre\u00e7\u00f5es de boas pr\u00e1ticas automaticamente</li> <li><code>format</code>: Executa a formata\u00e7\u00e3o do c\u00f3digo em rela\u00e7\u00e3o \u00e0s conven\u00e7\u00f5es de estilo de c\u00f3digo</li> <li><code>run</code>: executa o servidor de desenvolvimento do FastAPI</li> <li><code>pre_test</code>: executa a camada de lint antes de executar os testes</li> <li><code>test</code>: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c\u00f3digo como base de cobertura</li> <li><code>post_test</code>: gera um report de cobertura ap\u00f3s os testes</li> </ul> <p>Para executar um comando, \u00e9 bem mais simples, precisando somente passar a palavra <code>task &lt;comando&gt;</code>.</p>"},{"location":"01/#comandos-com-prefixo-pre-e-pos","title":"Comandos com prefixo <code>pre</code> e <code>pos</code>","text":"<p>Todos os comandos do taskipy que apresentam prefixos como <code>pre_comando</code> ou <code>post_comando</code> n\u00e3o precisam ser executados diretamente. Por exemplo, se executarmos o comando <code>task test</code> ele executar\u00e1 o comando <code>pre_test</code> e caso tudo ocorra bem, sem erros, ele executar\u00e1 o <code>test</code>, caso n\u00e3o aconte\u00e7am erros, o <code>post_test</code> ser\u00e1 executado.</p> <p>Nada impede que os comandos com prefixos sejam executados diretamente, mas eles s\u00e3o montados para serem executados em cadeia.</p> Caso precise ver o arquivo de configura\u00e7\u00e3o por completo <p>O meu est\u00e1 exatamente assim:</p> pyproject.toml<pre><code>[project]\nname = \"fast_zero\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\n    {name = \"dunossauro\",email = \"mendesxeduardo@gmail.com\"}\n]\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11,&lt;4.0\"\ndependencies = [\n    \"fastapi[standard] (&gt;=0.116.2,&lt;0.117.0)\"\n]\n\n[dependency-groups]\ndev = [\n    \"pytest (&gt;=8.4.2,&lt;9.0.0)\",\n    \"pytest-cov (&gt;=7.0.0,&lt;8.0.0)\",\n    \"taskipy (&gt;=1.14.1,&lt;2.0.0)\",\n    \"ruff (&gt;=0.13.0,&lt;0.14.0)\"\n]\n\n[tool.ruff]\nline-length = 79\nextend-exclude = ['migrations']\n\n[tool.ruff.lint]\npreview = true\nselect = ['I', 'F', 'E', 'W', 'PL', 'PT']\n\n[tool.ruff.format]\npreview = true\nquote-style = 'single'\n\n[tool.pytest.ini_options]\npythonpath = \".\"\naddopts = '-p no:warnings'\n\n[tool.taskipy.tasks]\nlint = 'ruff check'\npre_format = 'ruff check --fix'\nformat = 'ruff format'\nrun = 'fastapi dev fast_zero/app.py'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n\n[build-system]\nrequires = [\"poetry-core&gt;=2.0.0,&lt;3.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> <p>Um ponto importante \u00e9 que as vers\u00f5es dos pacotes podem variar dependendo da data em que voc\u00ea fizer a instala\u00e7\u00e3o dos pacotes. Esse arquivo \u00e9 somente um exemplo.</p>"},{"location":"01/#os-efeitos-dessas-configuracoes-de-desenvolvimento","title":"Os efeitos dessas configura\u00e7\u00f5es de desenvolvimento","text":"<p>Caso voc\u00ea tenha copiado o c\u00f3digo que usamos para definir <code>fast_zero/app.py</code>, pode testar os comandos que criamos para o <code>taskipy</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\n</code></pre> <p>Dessa forma, veremos que cometemos algumas infra\u00e7\u00f5es na formata\u00e7\u00e3o da PEP-8. O ruff nos informar\u00e1 que dever\u00edamos ter adicionado duas linhas antes de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o:</p> <pre><code>fast_zero/app.py:5:1: E302 [*] Expected 2 blank lines, found 1\n  |\n3 | app = FastAPI()\n4 | \n5 | @app.get('/')\n  | ^ E302\n6 | def read_root():\n7 |     return {'message': 'Ol\u00e1 Mundo!'}\n  |\n  = help: Add missing blank line(s)\n\nFound 1 error.\n[*] 1 fixable with the `--fix` option.\n</code></pre> <p>Para corrigir isso, podemos usar o nosso comando de formata\u00e7\u00e3o de c\u00f3digo:</p> ComandoResultado $ Execu\u00e7\u00e3o no terminal!<pre><code>task format\nFound 1 error (1 fixed, 0 remaining).\n3 files left unchanged\n</code></pre> fast_zero/app.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre>"},{"location":"01/#introducao-ao-pytest-testando-o-hello-world","title":"Introdu\u00e7\u00e3o ao Pytest: Testando o \"Hello, World!\"","text":"<p>Antes de entendermos a din\u00e2mica dos testes, precisamos entender o efeito que eles t\u00eam no nosso c\u00f3digo. Podemos come\u00e7ar analisando a cobertura (o quanto do nosso c\u00f3digo est\u00e1 sendo efetivamente testado). Vamos executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Teremos uma resposta como essa:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>=========================== test session starts ===========================\nplatform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fast_zero\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-4.2.0\ncollected 0 items\n\n---------- coverage: platform linux, python 3.11.7-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      5     0%\n-------------------------------------------\nTOTAL                       5      5     0%\n</code></pre> <p>As linhas no terminal s\u00e3o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.</p> Caso n\u00e3o tenha muita experi\u00eancia com Pytest <p>Temos uma live de Python explicando os conceitos b\u00e1sicos da biblioteca </p> <p> Link direto</p> <p>A parte importante dessa Mensagem est\u00e1 na tabela gerada pelo <code>coverage</code>. Que diz que temos 5 linhas de c\u00f3digo (Stmts) no arquivo <code>fast_zero/app.py</code> e nenhuma delas est\u00e1 coberta pelos nossos testes. Como podemos ver na coluna <code>Miss</code>.</p> <p>Por n\u00e3o encontrar nenhum teste, o pytest retornou um \"erro\". Isso significa que nossa tarefa <code>post_test</code> n\u00e3o foi executada. Podemos execut\u00e1-la manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Isso gera um relat\u00f3rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c\u00f3digo n\u00e3o est\u00e3o sendo testadas.</p> <p></p> <p>Se clicarmos no arquivo <code>fast_zero/app.py</code> podemos ver em vermelho as linhas que n\u00e3o est\u00e3o sendo testadas:</p> <p></p> <p>Isto significa que precisamos testar todo esse arquivo.</p>"},{"location":"01/#escrevendo-o-teste","title":"Escrevendo o teste","text":"<p>Agora, escreveremos nosso primeiro teste com Pytest. Mas, antes de escrever o teste, precisamos criar um arquivo espec\u00edfico para eles. Na pasta <code>tests</code>, vamos criar um arquivo chamado <code>test_app.py</code>.</p> <p>Por conven\u00e7\u00e3o, todos os arquivos de teste do pytest devem iniciar com um prefixo test_.py</p> <p>Para testar o c\u00f3digo feito com FastAPI, precisamos de um cliente de teste. A grande vantagem \u00e9 que o FastAPI j\u00e1 conta com um cliente de testes no m\u00f3dulo <code>fastapi.testclient</code> com o objeto <code>TestClient</code>, que precisa receber nosso app como par\u00e2metro:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient  # (1)!\n\nfrom fast_zero.app import app  # (2)!\n\nclient = TestClient(app)  # (3)!\n</code></pre> <ol> <li>Importa do m\u00f3dulo <code>testclient</code> o objeto <code>TestClient</code></li> <li>Importa o nosso <code>app</code> definido em <code>fast_zero</code></li> <li>Cria um cliente de testes usando a nossa aplica\u00e7\u00e3o como base</li> </ol> <p>S\u00f3 o fato de termos definido um cliente j\u00e1 nos mostra uma cobertura bastante diferente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 0 items\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      1    80%\n-------------------------------------------\nTOTAL                       5      1    80%\n</code></pre> <p>Por n\u00e3o coletar nenhum teste, o pytest ainda retornou um \"erro\". Para ver a cobertura, precisaremos executar novamente o <code>post_test</code> manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>No navegador, podemos ver que a \u00fanica linha n\u00e3o \"testada\" \u00e9 aquela onde temos a l\u00f3gica (o corpo) da fun\u00e7\u00e3o <code>read_root</code>. As linhas de defini\u00e7\u00e3o est\u00e3o todas verdes:</p> <p></p> <p>No verde, vemos o que foi executado quando chamamos o teste, no vermelho o que n\u00e3o foi.</p> <p>Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:</p> tests/test_app.py<pre><code>from http import HTTPStatus  # (6)!\n\nfrom fastapi.testclient import TestClient\n\nfrom fast_zero.app import app\n\n\ndef test_root_deve_retornar_ok_e_ola_mundo():  # (1)!\n    client = TestClient(app)  # (2)!\n\n    response = client.get('/')  # (3)!\n\n    assert response.status_code == HTTPStatus.OK  # (4)!\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}  # (5)!\n</code></pre> <ol> <li>No nome da fun\u00e7\u00e3o, escrevemos geralmente o que o teste de fato faz. Aqui estamos dizendo que root deve retornar o status OK e a mensagem \"ol\u00e1 mundo\". Root \u00e9 o nome dado a raiz da URL. O caminho <code>/</code>, que colocamos na defini\u00e7\u00e3o do <code>@app.get('/')</code>. OK \u00e9 o status que diz que a requisi\u00e7\u00e3o aconteceu com sucesso no protocolo HTTP.</li> <li>Aqui criamos o cliente de teste do nosso app</li> <li>Nesse ponto, o <code>client</code> faz uma requisi\u00e7\u00e3o. Da mesma forma que o browser, um cliente da API. Nisso, chamamos o endere\u00e7o de root, usando o m\u00e9todo GET.</li> <li>Aqui fazemos a valida\u00e7\u00e3o do c\u00f3digo de resposta, para saber se a resposta \u00e9 referente ao c\u00f3digo <code>200</code>, que significa <code>OK</code>. Mais informa\u00e7\u00f5es sobre esse t\u00f3pico aqui.</li> <li>No final, validamos se o dicion\u00e1rio que enviamos na fun\u00e7\u00e3o \u00e9 o mesmo que recebemos quando fizemos a requisi\u00e7\u00e3o.</li> <li>Importa\u00e7\u00e3o da biblioteca nativa do python que abstrai os c\u00f3digos de resposta e nos apresenta o status. Mais informa\u00e7\u00f5es sobre esse t\u00f3pico aqui.</li> </ol> <p>Esse teste faz uma requisi\u00e7\u00e3o GET no endpoint <code>/</code> e verifica se o c\u00f3digo de status da resposta \u00e9 200 e se o conte\u00fado da resposta \u00e9 <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 1 item\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      0   100%\n-------------------------------------------\nTOTAL                       5      0   100%\n\n================ 1 passed in 1.39s ================\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n\u00e3o deixou de abranger nenhuma linha de c\u00f3digo.</p> <p>Como conseguimos coletar um item, o <code>post_test</code> foi executado e tamb\u00e9m gerou um HTML com a cobertura atualizada.</p> <p></p>"},{"location":"01/#estrutura-de-um-teste","title":"Estrutura de um teste","text":"<p>Agora que escrevemos nosso primeiro teste de forma intuitiva, podemos entender o que cada passo do teste faz. Essa compreens\u00e3o \u00e9 vital, pois nos ajudar\u00e1 a escrever testes com mais confian\u00e7a e efic\u00e1cia. Para desvendar o m\u00e9todo por tr\u00e1s da nossa abordagem, exploraremos uma estrat\u00e9gia conhecida como AAA, que divide o teste em tr\u00eas fases distintas: Arrange, Act, Assert.</p> Caso fazer testes ainda seja complicado para voc\u00ea <p>Temos uma live de python focada em ensinar os primeiros passos no mundo dos testes. </p> <p> Link direto</p> <p>Para analisar todas as etapas de um teste, usaremos como exemplo este primeiro teste que escrevemos:</p> tests/test_app.py<pre><code>from http import HTTPStatus\n\nfrom fastapi.testclient import TestClient\n\nfrom fast_zero.app import app\n\n\ndef test_root_deve_retornar_ok_e_ola_mundo():\n    client = TestClient(app)  # Arrange\n\n    response = client.get('/')  # Act\n\n    assert response.status_code == HTTPStatus.OK  # Assert\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}  # Assert\n</code></pre> <p>Com base nesse c\u00f3digo, podemos observar as tr\u00eas fases:</p>"},{"location":"01/#fase-1-organizar-arrange","title":"Fase 1 - Organizar (Arrange)","text":"<p>Nesta primeira etapa, estamos preparando o ambiente para o teste. No exemplo, a linha com o coment\u00e1rio <code>Arrange</code> n\u00e3o \u00e9 o teste em si, ela monta o ambiente para o teste poder ser executado. Estamos configurando um <code>client</code> de testes para fazer a requisi\u00e7\u00e3o ao <code>app</code>.</p>"},{"location":"01/#fase-2-agir-act","title":"Fase 2 - Agir (Act)","text":"<p>Aqui \u00e9 a etapa onde acontece a a\u00e7\u00e3o principal do teste, que consiste em chamar o Sistema Sob Teste (SUT). No nosso caso, o SUT \u00e9 a rota <code>/</code>, e a a\u00e7\u00e3o \u00e9 representada pela linha <code>response = client.get('/')</code>. Estamos exercitando a rota e armazenando sua resposta na vari\u00e1vel <code>response</code>. \u00c9 a fase em que o c\u00f3digo de testes executa o c\u00f3digo de produ\u00e7\u00e3o que est\u00e1 sendo testado. Agir aqui significa interagir diretamente com a parte do sistema que queremos avaliar, para ver como ela se comporta.</p>"},{"location":"01/#fase-3-afirmar-assert","title":"Fase 3 - Afirmar (Assert)","text":"<p>Esta \u00e9 a etapa de verificar se tudo correu como esperado. \u00c9 f\u00e1cil notar onde estamos fazendo a verifica\u00e7\u00e3o, pois essa linha sempre tem a palavra reservada <code>assert</code>. A verifica\u00e7\u00e3o \u00e9 booleana, ou est\u00e1 correta, ou n\u00e3o est\u00e1. Por isso, um teste deve sempre incluir um <code>assert</code> para verificar se o comportamento esperado est\u00e1 correto.</p> <p>Agora que compreendemos o que cada linha de teste faz em espec\u00edfico, podemos nos orientar de forma clara nos testes que escreveremos no futuro. Cada uma das linhas usadas tem uma raz\u00e3o de estar no teste, e conhecer essa estrutura n\u00e3o s\u00f3 nos d\u00e1 uma compreens\u00e3o mais profunda do que estamos fazendo, mas tamb\u00e9m nos d\u00e1 confian\u00e7a para explorar e escrever testes mais complexos.</p>"},{"location":"01/#criando-nosso-repositorio-no-git","title":"Criando nosso reposit\u00f3rio no git","text":"<p>Antes de concluirmos a aula, precisamos executar alguns passos:</p> <ol> <li>Criar um arquivo <code>.gitignore</code> para n\u00e3o adicionar o ambiente virtual e outros arquivos desnecess\u00e1rios no versionamento de c\u00f3digo.</li> <li>Criar um novo reposit\u00f3rio no GitHub para versionar o c\u00f3digo.</li> <li>Subir o c\u00f3digo que fizemos para o GitHub.</li> </ol> <p>Criando o arquivo .gitignore</p> <p>Vamos iniciar com a cria\u00e7\u00e3o de um arquivo <code>.gitignore</code> espec\u00edfico para Python. Existem diversos modelos dispon\u00edveis na internet, como os dispon\u00edveis pelo pr\u00f3prio GitHub, ou o gitignore.io. Uma ferramenta \u00fatil \u00e9 a <code>ignr</code>, feita em Python, que faz o download autom\u00e1tico do arquivo para a nossa pasta de trabalho atual:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx run ignr -p python &gt; .gitignore #(1)!\n</code></pre> <ol> <li>O comando <code>pipx run</code> vai baixar o <code>ignr</code> vai executar o comando e vai desinstalar. N\u00e3o existe a necessidade de termos ele instalado no sistema, pois s\u00f3 ser\u00e1 executado dessa vez.</li> </ol> <p>O <code>.gitignore</code> \u00e9 importante porque ele nos ajuda a evitar que arquivos desnecess\u00e1rios ou sens\u00edveis sejam enviados para o reposit\u00f3rio. Isso inclui o ambiente virtual, arquivos de configura\u00e7\u00e3o pessoal, entre outros.</p> <p>Criando um reposit\u00f3rio no github</p> <p>Agora, com nossos arquivos indesejados ignorados, podemos iniciar o versionamento de c\u00f3digo usando o <code>git</code>. Para criar um reposit\u00f3rio local, usamos o comando <code>git init .</code>. Para criar esse reposit\u00f3rio no GitHub, utilizaremos o <code>gh</code>, um utilit\u00e1rio de linha de comando que nos auxilia nesse processo:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git init .\ngh repo create\n</code></pre> <p>Ao executar <code>gh repo create</code>, algumas informa\u00e7\u00f5es ser\u00e3o solicitadas, como o nome do reposit\u00f3rio e se ele ser\u00e1 p\u00fablico ou privado. Isso ir\u00e1 criar um reposit\u00f3rio tanto localmente quanto no GitHub.</p> <p>Subindo nosso c\u00f3digo para o github</p> <p>Com o reposit\u00f3rio pronto, vamos versionar nosso c\u00f3digo. Primeiro, adicionamos o c\u00f3digo ao pr\u00f3ximo commit com <code>git add .</code>. Em seguida, criamos um ponto na hist\u00f3ria do projeto com <code>git commit -m \"Configura\u00e7\u00e3o inicial do projeto\"</code>. Por fim, sincronizamos o reposit\u00f3rio local com o remoto no GitHub usando <code>git push</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Configura\u00e7\u00e3o inicial do projeto\"\ngit push\n</code></pre> <p>Caso seja a primeira vez que est\u00e1 utilizando o <code>git push</code>, talvez seja necess\u00e1rio configurar suas credenciais do GitHub.</p> <p>Esses passos garantem que todo o c\u00f3digo criado na aula esteja versionado e dispon\u00edvel para compartilhamento no GitHub.</p>"},{"location":"01/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Caso o mundo dos testes ainda seja um pouco nebuloso para voc\u00ea, recomendo que, antes de partir para a pr\u00f3xima aula, voc\u00ea d\u00ea uma assistida em algumas lives de python de fora desse curso:</p> <ul> <li>Uma introdu\u00e7\u00e3o aos testes: Como fazer? | Live de Python #232</li> <li>Pytest: Uma introdu\u00e7\u00e3o - Live de Python #167</li> <li>Pytest Fixtures - Live de Python #168</li> </ul>"},{"location":"01/#exercicio","title":"Exerc\u00edcio","text":"<ol> <li>Crie um reposit\u00f3rio para acompanhar o curso e suba em alguma plataforma, como Github, gitlab, codeberg, etc. E compartilhe o link no reposit\u00f3rio do curso para podermos aprender juntos.</li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"01/#conclusao","title":"Conclus\u00e3o","text":"<p>Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come\u00e7ar a trabalhar com FastAPI e j\u00e1 fizemos nossa primeira imers\u00e3o no Desenvolvimento Orientado por Testes. Na pr\u00f3xima aula, nos aprofundaremos na estrutura\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI. At\u00e9 l\u00e1!</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p> <ol> <li> <p>Exploraremos mais a fundo a rela\u00e7\u00e3o de m\u00e9todos e o protocolo HTTP na pr\u00f3xima aula.\u00a0\u21a9</p> </li> <li> <p>Em alguns casos, existe uma diverg\u00eancia de opini\u00f5es entre os linters mais tradicionais. Mas, em geral, funciona bem.\u00a0\u21a9</p> </li> <li> <p>Em vers\u00f5es antigas do texto, us\u00e1vamos as ferramentas do PyCQA como o pylint e o isort.\u00a0\u21a9</p> </li> <li> <p>Voc\u00ea n\u00e3o precisa se preocupar com o docker inicialmente, ele ser\u00e1 usado da aula 11 em diante.\u00a0\u21a9</p> </li> </ol>"},{"location":"02/","title":"Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":""},{"location":"02/#introducao-ao-desenvolvimento-web","title":"Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":"<p>Objetivos dessa aula:</p> <ul> <li>Criar uma base te\u00f3rica sobre desenvolvimento web</li> <li>Apresentar o protocolo HTTP</li> <li>Introduzir os conceitos de APIs JSON</li> <li>Apresentar o OpenAPI</li> <li>Introduzir os schemas usando Pydantic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Boas-vindas \u00e0 segunda aula do nosso curso de FastAPI. Agora que j\u00e1 temos o ambiente preparado, com algum c\u00f3digo escrito e testado, \u00e9 o momento ideal para entendermos o que viemos fazer aqui. At\u00e9 este ponto, voc\u00ea j\u00e1 deve saber que o FastAPI \u00e9 um framework para desenvolvimento de aplica\u00e7\u00f5es web, mais especificamente para o desenvolvimento de APIs web. \u00c9 aqui que ter um bom referencial te\u00f3rico se torna importante para compreendermos exatamente o que o framework \u00e9 capaz de fazer.</p>"},{"location":"02/#a-web","title":"A web","text":"<p>Sempre que nos referimos a aplica\u00e7\u00f5es web, estamos falando de aplica\u00e7\u00f5es que funcionam em rede. Essa rede pode ser privativa, como a sua rede dom\u00e9stica ou uma rede empresarial, ou podemos estar nos referindo \u00e0 World Wide Web (WWW), comumente conhecida como \"internet\". A internet, que tem uma longa hist\u00f3ria iniciada na d\u00e9cada de 1960, possui diversos padr\u00f5es definidos e vem se aperfei\u00e7oando desde ent\u00e3o. Compreender completamente sua complexidade \u00e9 um desafio, especialmente 6 d\u00e9cadas ap\u00f3s seu in\u00edcio.</p> <p>Quando falamos em comunica\u00e7\u00e3o em rede, geralmente nos referimos \u00e0 comunica\u00e7\u00e3o entre dois ou mais dispositivos interconectados. A ideia \u00e9 que possamos nos comunicar com outros dispositivos usando a rede.</p>"},{"location":"02/#o-modelo-cliente-servidor","title":"O modelo cliente-servidor","text":"<p>No contexto de aplica\u00e7\u00f5es web, geralmente nos referimos a um modelo espec\u00edfico de comunica\u00e7\u00e3o: o cliente-servidor. Neste modelo, temos clientes, como aplicativos m\u00f3veis, terminais de comando, navegadores, etc., acessando recursos fornecidos por outro computador, conhecido como servidor.</p> <p>Neste modelo, fazemos chamadas de um cliente, via rede, seguindo alguns padr\u00f5es, e recebemos respostas da nossa aplica\u00e7\u00e3o, o servidor. Por exemplo, podemos enviar um comando ao servidor: \"Crie um usu\u00e1rio para mim\". Em resposta, ele nos fornece um retorno, seja uma confirma\u00e7\u00e3o de sucesso ou uma mensagem de erro.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Note left of Cliente: Fazendo a requisi\u00e7\u00e3o\n    Cliente-&gt;&gt;Servidor: Crie um usu\u00e1rio\n    activate Servidor\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Sucesso na requisi\u00e7\u00e3o: Usu\u00e1rio criado com sucesso\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta desejada\n\n    Cliente-&gt;&gt;Servidor: Crie o mesmo usu\u00e1rio\n    activate Servidor\n    Note left of Cliente: Fazendo uma nova requisi\u00e7\u00e3o\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Erro na requisi\u00e7\u00e3o: Usu\u00e1rio j\u00e1 existe\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta de erro</code></pre> <p>A comunica\u00e7\u00e3o \u00e9 bidirecional: um cliente faz uma requisi\u00e7\u00e3o ao servidor, que por sua vez emite uma resposta.</p> <p>Por exemplo, ao construir um servidor, precisamos de uma biblioteca que consiga \"servir\" nossa aplica\u00e7\u00e3o. \u00c9 a\u00ed que entra o Uvicorn, respons\u00e1vel por servir nossa aplica\u00e7\u00e3o com FastAPI.</p> <p>Quando executamos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fastapi dev fast_zero/app.py\n</code></pre> <p>Quando executamos esse comando. O FastAPI faz uma chamada ao <code>uvicorn</code> e iniciamos um servidor em loopback, acess\u00edvel apenas internamente no nosso computador. Por isso, ao acessarmos http://127.0.0.1:8000/ no navegador, estamos fazendo uma requisi\u00e7\u00e3o ao servidor em <code>127.0.0.1:8000</code>.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Note left of Cliente: Fazendo a requisi\u00e7\u00e3o\n    Cliente-&gt;&gt;Servidor: \n    activate Servidor\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Sucesso na requisi\u00e7\u00e3o: {\"message\":\"Ol\u00e1 Mundo!\"}\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta desejada</code></pre>"},{"location":"02/#usando-o-fastapi-na-rede-local","title":"Usando o fastapi na rede local","text":"<p>Falando em redes, o Uvicorn no seu PC tamb\u00e9m pode servir o FastAPI na sua rede local:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fastapi dev fast_zero/app.py --host 0.0.0.0\n</code></pre> Esse comando tamb\u00e9m poderia ser executado com <code>taskipy</code> <p>Uma caracter\u00edstica interessante do taskipy \u00e9 que qualquer continua\u00e7\u00e3o ap\u00f3s o comando da task \u00e9 passado para o comando original. Poder\u00edamos ent\u00e3o executar dessa forma tamb\u00e9m: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>task run --host 0.0.0.0\n</code></pre><p></p> <p>Assim, voc\u00ea pode acessar a aplica\u00e7\u00e3o de outro computador na sua rede usando o endere\u00e7o IP da sua m\u00e1quina.</p> Descobrindo o seu endere\u00e7o local usando python <p>Caso n\u00e3o esteja familiarizado com o terminal ou ferramentas para descobrir seu endere\u00e7o IP:</p> &gt;&gt;&gt; Terminal interativo!<pre><code>&gt;&gt;&gt; import socket\n&gt;&gt;&gt; s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n&gt;&gt;&gt; s.connect((\"8.8.8.8\", 80))\n&gt;&gt;&gt; s.getsockname()[0]\n'192.168.0.100'# (1)!\n</code></pre> <ol> <li>O endere\u00e7o do meu computador na rede local</li> </ol> <p></p>"},{"location":"02/#o-modelo-padrao-da-web","title":"O modelo padr\u00e3o da web","text":"<p>Ignorando muita hist\u00f3ria e diversas camadas de padr\u00f5es, podemos nos concentrar nos tr\u00eas padr\u00f5es principais que ser\u00e3o mais importantes para n\u00f3s agora:</p> <pre><code>graph\n    A[Web] --&gt; B[URL]\n    A --&gt; C[HTTP]\n    A --&gt; D[HTML]</code></pre> <ul> <li>URL: Localizador Uniforme de Recursos. Um endere\u00e7o de rede pelo qual podemos nos comunicar com um computador na rede.</li> <li>HTTP: um protocolo que especifica como deve ocorrer a comunica\u00e7\u00e3o entre dispositivos.</li> <li>HTML: a linguagem usada para criar e estruturar p\u00e1ginas na web.</li> </ul>"},{"location":"02/#url","title":"URL","text":"<p>Uma URL (Uniform Resource Locator) \u00e9 como um endere\u00e7o que nos ajuda a encontrar um recurso espec\u00edfico em uma rede, como a URL <code>http://127.0.0.1:8000</code> que usamos para acessar nossa aplica\u00e7\u00e3o.</p> <p>Uma URL \u00e9 composta por v\u00e1rias partes, como neste exemplo: <code>protocolo://endere\u00e7o:porta/caminho/recurso?query_string#fragmento</code>. Neste primeiro momento, focaremos nos primeiros quatro componentes, essenciais para o andamento da aula:</p> <ol> <li> <p>Protocolo: A primeira parte da URL, terminando com \"://\". Os mais comuns s\u00e3o \"http://\" e \"https://\". Este protocolo define como os dados s\u00e3o trocados entre seu computador e o local onde o recurso est\u00e1 armazenado, seja na internet ou numa rede local.</p> </li> <li> <p>Endere\u00e7o do Host: Pode ser um endere\u00e7o IP (como \"192.168.1.10\") ou um endere\u00e7o de DNS (como \"youtube.com\"). Ele identifica o dispositivo na rede que cont\u00e9m o recurso desejado.</p> </li> <li> <p>Porta (opcional): Ap\u00f3s o endere\u00e7o do host, pode haver um n\u00famero ap\u00f3s dois pontos, como em \"192.168.1.10:8080\". Este n\u00famero \u00e9 a porta, usada para direcionar sua solicita\u00e7\u00e3o ao servi\u00e7o espec\u00edfico no dispositivo. Por padr\u00e3o, as portas s\u00e3o <code>80</code> para HTTP e <code>443</code> para HTTPS, quando n\u00e3o especificadas.</p> </li> <li> <p>Caminho: Indica a localiza\u00e7\u00e3o exata do recurso no servidor ou dispositivo. Por exemplo, em \"192.168.1.10:8000/busca\", <code>/busca</code> \u00e9 o nome do recurso. Quando n\u00e3o especificado, o servidor responde com o recurso na raiz (<code>/</code>).</p> </li> </ol> <p>Ao acessarmos via navegador a URL <code>http://127.0.0.1:8000</code>, estamos acessando o servidor via protocolo <code>HTTP</code>, no endere\u00e7o do nosso pr\u00f3prio computador, na porta <code>8000</code>, solicitando o recurso <code>/</code>.</p>"},{"location":"02/#http","title":"HTTP","text":"<p>Quando o cliente inicia uma requisi\u00e7\u00e3o para um endere\u00e7o na rede, isso \u00e9 feito via um protocolo e direcionado ao servidor do recurso. Em aplica\u00e7\u00f5es web, a maioria da comunica\u00e7\u00e3o ocorre via protocolo HTTP ou sua vers\u00e3o segura, o HTTPS.</p> <p>HTTP, ou Hypertext Transfer Protocol (Protocolo de Transfer\u00eancia de Hipertexto), \u00e9 o protocolo fundamental na web para a transfer\u00eancia de dados e comunica\u00e7\u00e3o entre clientes e servidores. Ele baseia-se no modelo de requisi\u00e7\u00e3o-resposta: onde o cliente faz uma requisi\u00e7\u00e3o ao servidor, que responde a essa requisi\u00e7\u00e3o. Essas requisi\u00e7\u00f5es e respostas s\u00e3o formatadas conforme as regras do protocolo HTTP.</p>"},{"location":"02/#mensagens","title":"Mensagens","text":"<p>No contexto do HTTP, tanto requisi\u00e7\u00f5es quanto respostas s\u00e3o referidas como mensagens. As mensagens HTTP na vers\u00e3o 1 t\u00eam uma estrutura textual semelhante ao seguinte exemplo.</p> <p>Um exemplo de mensagem HTTP enviada pelo cliente:</p> Exemplo da mensagem emitada pelo cliente<pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nHost: 127.0.0.1:8000\nUser-Agent: HTTPie/3.2.2\n</code></pre> <p>Na primeira linha, temos o verbo GET, que solicita um recurso, neste caso, o recurso \u00e9 <code>/</code>. As linhas seguintes comp\u00f5em o cabe\u00e7alho da mensagem. Elas informam que o cliente aceita qualquer tipo de resposta (<code>Accept: */*</code>), indicam a URL destino (<code>Host: 127.0.0.1:8000</code>) e identificam o cliente que gerou a requisi\u00e7\u00e3o (<code>User-Agent: HTTPie/3.2.2</code>), que neste caso foi o cliente HTTPie.</p> <p>Em resposta a esta mensagem, o servidor enviou o seguinte:</p> Exemplo da mensagem de resposta do servidor<pre><code>HTTP/1.1 200 OK\ncontent-length: 24\ncontent-type: application/json\ndate: Fri, 19 Jan 2024 04:05:50 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 mundo\"\n}\n</code></pre> <p>Aqui, na primeira linha da resposta, temos a vers\u00e3o do protocolo HTTP utilizada e o c\u00f3digo de resposta <code>200 OK</code>, indicando que a requisi\u00e7\u00e3o foi bem-sucedida. O cabe\u00e7alho da resposta inclui informa\u00e7\u00f5es como o <code>content-length</code> e <code>content-type</code>, que especificam o tamanho e o tipo do conte\u00fado da resposta, respectivamente. A data e o servidor que processou a requisi\u00e7\u00e3o tamb\u00e9m s\u00e3o indicados. Finalmente, o corpo da resposta, formatado em JSON, cont\u00e9m a mensagem <code>\"Ol\u00e1 mundo\"</code>.</p> Como as mensagens do HTTP foram geradas? <p>A visualiza\u00e7\u00e3o das mensagens foram geradas com o cliente CLI do HTTPie: <code>http GET http://127.0.0.1:8000 -v</code></p> <pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nHost: 127.0.0.1:8000\nUser-Agent: HTTPie/3.2.2\n\nHTTP/1.1 200 OK\ncontent-length: 24\ncontent-type: application/json\ndate: Fri, 19 Jan 2024 04:05:50 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 mundo\"\n}\n</code></pre>"},{"location":"02/#cabecalho","title":"Cabe\u00e7alho","text":"<p>O cabe\u00e7alho de uma mensagem HTTP cont\u00e9m metadados essenciais sobre a requisi\u00e7\u00e3o ou resposta. Alguns elementos comuns que podem ser inclu\u00eddos no cabe\u00e7alho s\u00e3o:</p> <ul> <li>Content-Type: Especifica o tipo de m\u00eddia no corpo da mensagem. Por exemplo, <code>Content-Type: application/json</code> indica que o corpo da mensagem est\u00e1 em formato JSON. Ou <code>Content-Type: text/html</code>, para mensagens que cont\u00e9m HTML.</li> <li>Authorization: Usado para autentica\u00e7\u00e3o, como tokens ou credenciais. (veremos mais disso nas aulas seguintes)</li> <li>Accept: Especifica o tipo de m\u00eddia que o cliente aceita, como <code>application/json</code>.</li> <li>Server: Fornece informa\u00e7\u00f5es sobre o software do servidor.</li> </ul>"},{"location":"02/#corpo","title":"Corpo","text":"<p>O corpo da mensagem cont\u00e9m os dados propriamente ditos, variando conforme o tipo de m\u00eddia. Exemplos podem incluir um objeto JSON ou uma estrutura HTML.</p>"},{"location":"02/#verbos","title":"Verbos","text":"<p>Quando um cliente faz uma requisi\u00e7\u00e3o HTTP, ele indica sua inten\u00e7\u00e3o ao servidor utilizando verbos. Estes verbos sinalizam diferentes a\u00e7\u00f5es no protocolo HTTP. Vejamos alguns exemplos:</p> <ul> <li>GET: utilizado para recuperar recursos. Empregamos este verbo quando queremos solicitar um dado j\u00e1 existente no servidor.</li> <li>POST: permite criar um novo recurso. Por exemplo, enviar dados para registrar um novo usu\u00e1rio.</li> <li>PUT: Atualiza um recurso existente. Como, por exemplo, atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente.</li> <li>DELETE: Exclui um recurso. Por exemplo, remover um usu\u00e1rio espec\u00edfico do sistema.</li> </ul> <p>Na nossa aplica\u00e7\u00e3o FastAPI, definimos que a fun\u00e7\u00e3o <code>read_root</code> que  ser\u00e1 executada quando uma requisi\u00e7\u00e3o GET for feita por um cliente no caminho <code>/</code>:</p> fast_zero/app.py<pre><code>@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Quando realizamos a requisi\u00e7\u00e3o via navegador, o verbo padr\u00e3o \u00e9 o GET. Por isso, obtemos na tela a mensagem <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> <p></p> <p>Essa \u00e9 exatamente a resposta fornecida pela execu\u00e7\u00e3o da fun\u00e7\u00e3o <code>read_root</code>. No futuro, criaremos fun\u00e7\u00f5es para lidar com os outros verbos HTTP.</p>"},{"location":"02/#codigos-de-resposta","title":"C\u00f3digos de resposta","text":"<p>No mundo das requisi\u00e7\u00f5es usando o protocolo HTTP, al\u00e9m da resposta obtida quando nos comunicamos com o servidor, tamb\u00e9m recebemos um c\u00f3digo de resposta (status code). Os c\u00f3digos s\u00e3o formas de mostrar ao cliente como o servidor lidou com a sua requisi\u00e7\u00e3o. Os c\u00f3digos s\u00e3o divididos em classes e as classes s\u00e3o distribu\u00eddas por centenas:</p> <ul> <li>1xx: informativo \u2014 utilizada para enviar informa\u00e7\u00f5es para o cliente de que sua requisi\u00e7\u00e3o foi recebida e est\u00e1 sendo processada.</li> <li>2xx: sucesso \u2014 Indica que a requisi\u00e7\u00e3o foi bem-sucedida (por exemplo, 200 OK, 201 Created).</li> <li>3xx: redirecionamento \u2014 Informa que mais a\u00e7\u00f5es s\u00e3o necess\u00e1rias para completar a requisi\u00e7\u00e3o (por exemplo, 301 Moved Permanently, 302 Found).</li> <li>4xx: erro no cliente \u2014 Significa que houve um erro na requisi\u00e7\u00e3o feita pelo cliente (por exemplo, 400 Bad Request, 404 Not Found).</li> <li>5xx: erro no servidor \u2014 Indica um erro no servidor ao processar a requisi\u00e7\u00e3o v\u00e1lida do cliente (por exemplo, 500 Internal Server Error, 503 Service Unavailable).</li> </ul> <p>Para mais informa\u00e7\u00f5es a cerca do status code acesse a documenta\u00e7\u00e3o do iana</p> <p>Sempre que fazemos uma requisi\u00e7\u00e3o, obtemos um c\u00f3digo de resposta. Por exemplo, em nosso arquivo de teste, quando efetuamos a requisi\u00e7\u00e3o, fazemos a checagem para ver se recebemos um c\u00f3digo de sucesso, o c\u00f3digo <code>200 OK</code>:</p> tests/test_app.py<pre><code>def test_root_deve_retornar_ok_e_ola_mundo():\n    client = TestClient(app)\n\n    response = client.get('/')\n\n    assert response.status_code == 200\n</code></pre>"},{"location":"02/#boas-praticas-para-constantes","title":"Boas pr\u00e1ticas para constantes","text":"<p>Quando comparamos valores, a boa pr\u00e1tica \u00e9 que eles nunca sejam expl\u00edcitos no c\u00f3digo como <code>status_code == 200</code>. Neste caso em espec\u00edfico \u00e9 f\u00e1cil saber o que <code>200</code> significa pois estamos estudando exatamente essa parte. Mas, em alguns momentos podemos nos deparar com c\u00f3digos que n\u00e3o sabemos o significado. Por exemplo um c\u00f3digo <code>209</code>. O que ele significa?<sup>1</sup></p> <p>Quando trabalhamos com \"valores m\u00e1gicos\" no c\u00f3digo, a PEP-8 recomenda que criemos constantes que representem esses valores. Como por exemplo <code>OK = 200</code>.</p> <p>A boa pr\u00e1tica para lidar com c\u00f3digos de status \u00e9 usar a classe <code>http.HTTPStatus</code>, que j\u00e1 mapeia todos os status code em um \u00fanico objeto. Fazendo que a compara\u00e7\u00e3o seja feita de forma simples, como:</p> tests/test_app.py<pre><code>def test_root_deve_retornar_ok_e_ola_mundo():\n    client = TestClient(app)\n\n    response = client.get('/')\n\n    assert response.status_code == HTTPStatus.OK\n</code></pre>"},{"location":"02/#o-lado-do-servidor","title":"O lado do servidor","text":"<p>Para garantir que a resposta obtida pelo cliente seja considerada um sucesso, o FastAPI, por padr\u00e3o, envia o c\u00f3digo de sucesso <code>200</code> para o m\u00e9todo GET. No entanto, tamb\u00e9m podemos deixar isso expl\u00edcito na defini\u00e7\u00e3o da rota:</p> Apenas o d\u00edgitoUsando HTTPStatus fast_zero/app.py<pre><code>@app.get(\"/\", status_code=200)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> fast_zero/app.py<pre><code>@app.get(\"/\", status_code=HTTPStatus.OK)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Temos diversos c\u00f3digos a explorar durante nossa jornada, mas gostaria de listar os mais comuns dentro do nosso escopo:</p> <ul> <li>200 OK: a solicita\u00e7\u00e3o foi bem-sucedida. O significado exato depende do m\u00e9todo HTTP utilizado na solicita\u00e7\u00e3o.</li> <li>201 Created: a solicita\u00e7\u00e3o foi bem-sucedida e um novo recurso foi criado como resultado.</li> <li>404 Not Found: o recurso solicitado n\u00e3o p\u00f4de ser encontrado, sendo frequentemente usado quando o recurso \u00e9 inexistente.</li> <li>422 Unprocessable Entity: usado quando a requisi\u00e7\u00e3o est\u00e1 bem-formada, mas n\u00e3o pode ser seguida devido a erros sem\u00e2nticos. \u00c9 comum em APIs ao validar dados de entrada.</li> </ul> <p>Assim, podemos ir ao terceiro pilar do desenvolvimento web que s\u00e3o os conte\u00fados relacionados as respostas.</p>"},{"location":"02/#html","title":"HTML","text":"<p>Sobre o c\u00f3digo apresentado nesse t\u00f3pico!</p> <p>Todo o c\u00f3digo apresentado neste t\u00f3pico \u00e9 apenas um exemplo b\u00e1sico do uso de HTML com FastAPI e n\u00e3o ser\u00e1 utilizado no curso. No entanto, \u00e9 extremamente importante mencionar este t\u00f3pico. Para uma vis\u00e3o um pouco mais aprofundada, temos um t\u00f3pico no ap\u00eandice B focado em html + css.</p> <p>Embora este t\u00f3pico abranja apenas HTML puro, o FastAPI pode utilizar Jinja como sistema de templates para uma aplica\u00e7\u00e3o mais eficiente.</p> Interessado em aprender sobre a aplica\u00e7\u00e3o de templates? <p>Na live sobre websockets com FastAPI, discutimos bastante sobre templates. Voc\u00ea pode assistir ao v\u00eddeo aqui: </p> <p>A documenta\u00e7\u00e3o do FastAPI tamb\u00e9m oferece um t\u00f3pico focado em Templates.</p> <p>O terceiro pilar fundamental da web \u00e9 o HTML, sigla para Hypertext Markup Language. Trata-se da linguagem de marca\u00e7\u00e3o padr\u00e3o usada para criar e estruturar p\u00e1ginas na internet. Quando acessamos um site, o que vemos em nossos navegadores \u00e9 o resultado da interpreta\u00e7\u00e3o do HTML. Esta linguagem utiliza uma s\u00e9rie de 'tags' \u2013 como <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code> e outras \u2013 para definir a estrutura e o conte\u00fado de uma p\u00e1gina web.</p> <p>A beleza do HTML reside em sua simplicidade e efic\u00e1cia. Mais do que uma linguagem, \u00e9 uma forma de organizar e apresentar informa\u00e7\u00f5es na web. Cada tag tem um prop\u00f3sito espec\u00edfico: <code>&lt;h1&gt;</code> a <code>&lt;h6&gt;</code> s\u00e3o usadas para t\u00edtulos e subt\u00edtulos; <code>&lt;p&gt;</code> para par\u00e1grafos; <code>&lt;a&gt;</code> para links; enquanto <code>&lt;div&gt;</code> e <code>&lt;span&gt;</code> auxiliam na organiza\u00e7\u00e3o e estilo do conte\u00fado. Juntas, essas tags formam a espinha dorsal de quase todas as p\u00e1ginas da internet.</p> <p>Se nosso objetivo fosse apresentar um HTML simples, poder\u00edamos usar a classe de resposta <code>HTMLResponse</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\n\napp = FastAPI()\n\n\n@app.get('/', response_class=HTMLResponse)\ndef read_root():\n    return \"\"\"\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt; Nosso ol\u00e1 mundo!&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt; Ol\u00e1 Mundo &lt;/h1&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\"\"\"\n</code></pre> <p>Ao acessarmos nossa URL no navegador, podemos ver o HTML sendo renderizado:</p> <p></p> <p>Embora o HTML seja crucial para a estrutura\u00e7\u00e3o de p\u00e1ginas web, nosso curso foca em uma perspectiva diferente: a transfer\u00eancia de dados. Enquanto o HTML \u00e9 usado para apresentar dados visualmente nos navegadores, existe outra camada focada na transfer\u00eancia de informa\u00e7\u00f5es entre sistemas e servidores. Aqui entra o conceito de APIs (Application Programming Interfaces), que frequentemente utilizam JSON (JavaScript Object Notation) para a troca de dados. JSON \u00e9 um formato leve de troca de dados, f\u00e1cil de ler e escrever para humanos, e simples de interpretar e gerar para m\u00e1quinas.</p> <p>Portanto, embora n\u00e3o aprofundemos no HTML como linguagem, \u00e9 importante entender seu papel como a camada de apresenta\u00e7\u00e3o padr\u00e3o da web. Agora, direcionaremos nossa aten\u00e7\u00e3o para as APIs e a troca de dados em JSON, explorando como essas tecnologias permitem a comunica\u00e7\u00e3o eficiente entre diferentes sistemas e aplicativos.</p>"},{"location":"02/#apis","title":"APIs","text":"<p>Quando falamos sobre aplica\u00e7\u00f5es web que n\u00e3o envolvem uma camada de visualiza\u00e7\u00e3o, como HTML, geralmente estamos nos referindo a APIs. A sigla API vem de Application Programming Interface (Interface de Programa\u00e7\u00e3o de Aplica\u00e7\u00f5es). Uma API \u00e9 projetada para ser uma interface claramente definida e documentada, que facilita a intera\u00e7\u00e3o por meio do protocolo HTTP.</p> <p>A ess\u00eancia das APIs reside no modelo cliente-servidor, onde o cliente troca dados com o servidor atrav\u00e9s de endpoints, respeitando as regras estabelecidas pelo protocolo HTTP. Por exemplo, para solicitar dados ao servidor, usamos o verbo GET, direcionando a requisi\u00e7\u00e3o a um endpoint espec\u00edfico do servidor, que em resposta nos fornece o dado ou recurso solicitado.</p>"},{"location":"02/#endpoint","title":"Endpoint","text":"<p>O termo \"endpoint\" refere-se a um ponto espec\u00edfico em uma API para onde as requisi\u00e7\u00f5es s\u00e3o enviadas. Basicamente, \u00e9 um endere\u00e7o na web (URL) onde o servidor ou a API est\u00e1 ativo e pronto para responder a requisi\u00e7\u00f5es dos clientes. Cada endpoint est\u00e1 associado a uma fun\u00e7\u00e3o espec\u00edfica da API, como recuperar dados, criar novos registros, atualizar ou deletar dados existentes.</p> <p>A localiza\u00e7\u00e3o e estrutura de um endpoint, que incluem o caminho na URL e os m\u00e9todos HTTP permitidos, definem como os clientes devem formatar suas requisi\u00e7\u00f5es para serem compreendidas e processadas pelo servidor. Por exemplo, um endpoint para recuperar informa\u00e7\u00f5es de um usu\u00e1rio pode ter um endere\u00e7o como <code>https://api.exemplo.com/usuarios/{id}</code>, onde <code>{id}</code> \u00e9 o identificador \u00fanico do usu\u00e1rio desejado.</p> <p>Atualmente, em nossa aplica\u00e7\u00e3o, temos apenas um endpoint dispon\u00edvel: o <code>/</code>. Vejamos o exemplo:</p> C\u00f3digo de Exemplo<pre><code>@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Quando utilizamos o decorador <code>@app.get('/')</code>, estamos instruindo nossa API que, para chamadas de m\u00e9todo <code>GET</code> no endpoint <code>/</code>, a fun\u00e7\u00e3o <code>read_root</code> ser\u00e1 executada. O resultado dessa fun\u00e7\u00e3o, neste caso <code>{'message': 'Ol\u00e1 Mundo!'}</code>, \u00e9 o que ser\u00e1 retornado ao cliente.</p>"},{"location":"02/#documentacao","title":"Documenta\u00e7\u00e3o","text":"<p>Uma pergunta comum nesse est\u00e1gio \u00e9: \"Ok, mas como descobrir ou conhecer os endpoints dispon\u00edveis em uma API?\". A resposta reside na documenta\u00e7\u00e3o. Uma documenta\u00e7\u00e3o eficaz \u00e9 essencial em APIs, especialmente quando muitos clientes diferentes precisam se comunicar com o servidor. A melhor pr\u00e1tica \u00e9 fornecer uma documenta\u00e7\u00e3o detalhada, clara e acess\u00edvel sobre os endpoints dispon\u00edveis, incluindo informa\u00e7\u00f5es sobre o formato e a estrutura dos dados que podem ser enviados e recebidos.</p> <p>A documenta\u00e7\u00e3o de uma API serve como um guia ou um manual, facilitando o entendimento e a utiliza\u00e7\u00e3o por desenvolvedores e usu\u00e1rios finais. Ela desempenha um papel crucial ao:</p> <ul> <li>Definir claramente os endpoints e suas funcionalidades.</li> <li>Especificar os m\u00e9todos HTTP suportados (GET, POST, PUT, DELETE, etc.).</li> <li>Descrever os par\u00e2metros esperados em requisi\u00e7\u00f5es e respostas.</li> <li>Fornecer exemplos de requisi\u00e7\u00f5es e respostas para facilitar o entendimento.</li> </ul>"},{"location":"02/#openapi-e-documentacao-automatica","title":"OpenAPI e documenta\u00e7\u00e3o autom\u00e1tica","text":"<p>Uma das solu\u00e7\u00f5es mais eficazes para a documenta\u00e7\u00e3o de APIs \u00e9 a utiliza\u00e7\u00e3o da especifica\u00e7\u00e3o OpenAPI, dispon\u00edvel em OpenAPI Specification. Essa especifica\u00e7\u00e3o fornece um padr\u00e3o robusto para descrever APIs, permitindo aos desenvolvedores criar documenta\u00e7\u00f5es precisas e test\u00e1veis de forma autom\u00e1tica. Esta abordagem n\u00e3o apenas simplifica o processo de documenta\u00e7\u00e3o, mas tamb\u00e9m garante que a documenta\u00e7\u00e3o seja consistentemente atualizada e precisa.</p> <p>Para visualizar e interagir com essa documenta\u00e7\u00e3o, ferramentas como Swagger UI e Redoc s\u00e3o amplamente utilizadas. Elas transformam a especifica\u00e7\u00e3o OpenAPI em visualiza\u00e7\u00f5es interativas, fornecendo uma interface f\u00e1cil de navegar onde os usu\u00e1rios podem n\u00e3o apenas ler a documenta\u00e7\u00e3o, mas tamb\u00e9m experimentar a API diretamente na interface. Esta funcionalidade interativa \u00e9 fundamental para uma compreens\u00e3o pr\u00e1tica de como a API funciona, al\u00e9m de oferecer uma maneira eficiente de testar suas funcionalidades em tempo real.</p> <p>No contexto do FastAPI, h\u00e1 suporte autom\u00e1tico tanto para Swagger UI quanto para Redoc. Para explorar a documenta\u00e7\u00e3o atual da nossa aplica\u00e7\u00e3o, basta iniciar o servidor com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre>"},{"location":"02/#swagger-ui","title":"Swagger UI","text":"<p>Ao acessarmos o endere\u00e7o http://127.0.0.1:8000/docs, nos deparamos com a interface do Swagger UI:</p> <p></p> <p>Esta imagem nos d\u00e1 uma vis\u00e3o geral dos endpoints dispon\u00edveis na nossa aplica\u00e7\u00e3o, neste caso, o endpoint <code>/</code> que aceita o verbo HTTP <code>GET</code>. Ao explorar mais a fundo e clicar nesse m\u00e9todo:</p> <p></p> <p>Na documenta\u00e7\u00e3o, \u00e9 poss\u00edvel observar diversas informa\u00e7\u00f5es cruciais, como o c\u00f3digo de resposta <code>200</code>, que indica sucesso, o tipo de dado retornado pelo cabe\u00e7alho (<code>application/json</code>) e um exemplo do valor de retorno. Contudo, a documenta\u00e7\u00e3o atual sugere, incorretamente, que o retorno \u00e9 uma <code>string</code>, quando, na verdade, nossa aplica\u00e7\u00e3o retorna um objeto JSON. Essa diferen\u00e7a ser\u00e1 abordada em breve.</p> <p>Um aspecto interessante do Swagger UI \u00e9 a possibilidade de interagir diretamente com a API atrav\u00e9s da interface. Ao clicar em <code>Try it out</code>, um bot\u00e3o <code>Execute</code> se torna dispon\u00edvel:</p> <p></p> <p>Clicar em <code>Execute</code> faz do Swagger um cliente tempor\u00e1rio da nossa API, enviando uma requisi\u00e7\u00e3o ao servidor e exibindo a resposta:</p> <p></p> <p>A resposta ilustra como fazer a chamada usando o Curl, a URL utilizada, o c\u00f3digo de resposta 200, e detalhes da resposta do servidor, incluindo o corpo da mensagem (body) e os cabe\u00e7alhos (headers).</p> Caso queira saber mais sobre OpenAPI e Swagger <p>Temos uma live focada em OpenAPI, que s\u00e3o as especifica\u00e7\u00f5es do Swagger: </p>"},{"location":"02/#redoc","title":"Redoc","text":"<p>Assim como o Swagger UI, o Redoc \u00e9 outra ferramenta popular para visualizar a documenta\u00e7\u00e3o de APIs OpenAPI, mas com um foco em uma apresenta\u00e7\u00e3o mais limpa e leg\u00edvel. Para acessar a documenta\u00e7\u00e3o Redoc da nossa aplica\u00e7\u00e3o, podemos visitar o endere\u00e7o http://127.0.0.1:8000/redoc. O Redoc organiza a documenta\u00e7\u00e3o de uma maneira mais linear e de f\u00e1cil leitura, destacando as descri\u00e7\u00f5es dos endpoints, os m\u00e9todos HTTP dispon\u00edveis, os schemas dos dados de entrada e sa\u00edda, al\u00e9m de exemplos de requisi\u00e7\u00f5es e respostas.</p> <p></p>"},{"location":"02/#trafegando-json","title":"Trafegando JSON","text":"<p>Quando discutimos APIs \"modernas\"<sup>2</sup>, nos referimos a APIs que priorizam o tr\u00e1fego de dados, deixando de lado a camada de apresenta\u00e7\u00e3o, como o HTML. O objetivo \u00e9 transmitir dados de forma agn\u00f3stica para diferentes tipos de clientes. Nesse contexto, o JSON (JavaScript Object Notation) se tornou a m\u00eddia padr\u00e3o, gra\u00e7as \u00e0 sua leveza e facilidade de leitura tanto por humanos quanto por m\u00e1quinas.</p> <p>O JSON \u00e9 apreciado por sua simplicidade, apresentando dados em estruturas de documento chave-valor, onde os valores podem ser strings, n\u00fameros, booleanos, arrays, entre outros.</p> <p>Abaixo, um exemplo ilustra o formato JSON:</p> Exemplo de um JSON<pre><code>{\n    \"livros\": [\n        {\n            \"titulo\": \"O apanhador no campo de centeio\",\n            \"autor\": \"J.D. Salinger\",\n            \"ano\": 1945,\n            \"disponivel\": false\n        },\n        {\n            \"titulo\": \"O mestre e a margarida\",\n            \"autor\": \"Mikhail Bulg\u00e1kov\",\n            \"ano\": 1966,\n            \"disponivel\": true\n        }\n    ]\n}\n</code></pre> <p>Este exemplo demonstra como o JSON organiza dados de forma intuitiva e acess\u00edvel, tornando-o ideal para a comunica\u00e7\u00e3o de dados em uma ampla variedade de aplica\u00e7\u00f5es.</p>"},{"location":"02/#contratos-em-apis-json","title":"Contratos em APIs JSON","text":"<p>Quando falamos sobre o compartilhamento de JSON entre cliente e servidor, \u00e9 crucial estabelecer um entendimento m\u00fatuo sobre a estrutura dos dados que ser\u00e3o trocados. A este entendimento, denominamos schema, que atua como um contrato definindo a forma e o conte\u00fado dos dados trafegados.</p> <p>O schema de uma API desempenha um papel fundamental ao assegurar que ambos, cliente e servidor, estejam alinhados quanto \u00e0 estrutura dos dados. Este \"contrato\" especifica:</p> <ul> <li>Campos de Dados Esperados: quais campos s\u00e3o esperados na mensagem JSON, incluindo nomes de campos e tipos de dados (como strings, n\u00fameros, booleanos).</li> <li>Restri\u00e7\u00f5es Adicionais: como valida\u00e7\u00f5es para tamanhos de strings, formatos de n\u00fameros e outros tipos de valida\u00e7\u00e3o de dados.</li> <li>Estrutura de Objetos Aninhados: como os objetos s\u00e3o estruturados dentro do JSON, incluindo arrays e sub-objetos.</li> </ul> <p>Por exemplo, para nossa mensagem simples retornada por <code>read_root</code> (<code>{'message': 'Ol\u00e1 mundo!'}</code>), ter\u00edamos um schema assim:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"message\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"message\"]\n}\n</code></pre> <p>Onde estamos dizendo ao cliente que ao chamar a API, ser\u00e1 retornado um objeto, esse objeto cont\u00e9m a propriedade <code>\"message\"</code>, a mensagem ser\u00e1 do tipo <code>string</code>. Ao final, vemos que o campo <code>message</code> \u00e9 requerido. Isso quer dizer que ele sempre ser\u00e1 enviado na resposta.</p> E em casos mais complicados, como ficaria o schema? <p>Para o exemplo que fizemos antes, sobre os livros, o schema seria assim: </p><pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"livros\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"titulo\": {\n            \"type\": \"string\"\n          },\n          \"autor\": {\n            \"type\": \"string\"\n          },\n          \"ano\": {\n            \"type\": \"integer\"\n          },\n          \"disponivel\": {\n            \"type\": \"boolean\"\n          }\n        },\n        \"required\": [\"titulo\", \"autor\", \"ano\", \"disponivel\"]\n      }\n    }\n  },\n  \"required\": [\"livros\"]\n}\n</code></pre><p></p>"},{"location":"02/#pydantic","title":"Pydantic","text":"<p>No universo de APIs e contratos de dados, especialmente ao trabalhar com Python, o Pydantic se destaca como uma ferramenta poderosa e vers\u00e1til. Essa biblioteca, altamente integrada ao ecossistema Python, especializa-se na cria\u00e7\u00e3o de schemas de dados e na valida\u00e7\u00e3o de tipos. Com o Pydantic, \u00e9 poss\u00edvel expressar schemas JSON de maneira elegante e eficiente atrav\u00e9s de classes Python, proporcionando uma ponte robusta entre a flexibilidade do JSON e a seguran\u00e7a de tipos do Python.</p> <p>Sobre a terminologia</p> <p>Embora o termo <code>schema</code> seja bastante utilizado em python para se referir ao formato dos objetos transferidos, em alguns outros contextos e linguagens podemos nos referir a esses modelos com DTOs (objetos de transfer\u00eancia de dados). Pode ser que voc\u00ea j\u00e1 tenha ouvido esse termo antes.</p> <p>Por exemplo, o schema JSON <code>{'message': 'Ol\u00e1 mundo!'}</code>. Com o Pydantic, podemos representar esse schema na forma de uma classe Python chamada <code>Message</code>. Isso \u00e9 feito de maneira intuitiva e direta:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel\n\n\nclass Message(BaseModel):\n    message: str\n</code></pre> <p>Para iniciar o desenvolvimento com schemas no contexto do FastAPI, podemos criar um arquivo chamado <code>fast_zero/schemas.py</code> e definir a classe <code>Message</code>. Vale ressaltar que o Pydantic \u00e9 uma depend\u00eancia integrada do FastAPI (n\u00e3o precisa ser instalado), refletindo a import\u00e2ncia dessa biblioteca no processo de valida\u00e7\u00e3o de dados e na gera\u00e7\u00e3o de documenta\u00e7\u00e3o autom\u00e1tica para APIs, como a documenta\u00e7\u00e3o OpenAPI.</p>"},{"location":"02/#integrando-o-pydantic-com-o-fastapi","title":"Integrando o Pydantic com o FastAPI","text":"<p>A integra\u00e7\u00e3o do modelo Pydantic (ou schema JSON) com o FastAPI \u00e9 feita ao especificar o modelo no campo <code>response_model</code> do decorador do endpoint. Isso garante que a resposta da API esteja alinhada com o schema definido, al\u00e9m de auxiliar na valida\u00e7\u00e3o dos dados retornados:</p> fast_zero/app.py<pre><code>from http import HTTPStatus\n\nfrom fastapi import FastAPI\n\nfrom fast_zero.schemas import Message\n\napp = FastAPI()\n\n\n@app.get('/', status_code=HTTPStatus.OK, response_model=Message)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Com essa abordagem, ao iniciar o servidor (<code>task run</code>) e acessar a Swagger UI em http://127.0.0.1:8000/docs, observamos uma evolu\u00e7\u00e3o significativa na documenta\u00e7\u00e3o. Um novo campo <code>Schemas</code> \u00e9 exibido, destacando a estrutura do modelo <code>Message</code> que definimos:</p> <p></p> <p>Al\u00e9m disso, na se\u00e7\u00e3o de <code>Responses</code>, temos um exemplo claro da sa\u00edda esperada do endpoint: <code>{\"message\": \"string\"}</code>. Isso ilustra como a API ir\u00e1 responder, especificando que o campo obrigat\u00f3rio <code>\"message\"</code> ser\u00e1 retornado com um valor do tipo <code>\"string\"</code>.</p>"},{"location":"02/#exercicio","title":"Exerc\u00edcio","text":"<p>1.Crie um novo endpoint em <code>fast_zero/app.py</code> que retorne \"ol\u00e1 mundo\" usando HTML e escreva seu teste em <code>tests/test_app.py</code>.</p> <p>Dica: para capturar a resposta do HTML do cliente de testes, voc\u00ea pode usar <code>response.text</code></p> <p>Exerc\u00edcios resolvidos </p>"},{"location":"02/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, navegamos brevemente pelo vasto mundo do desenvolvimento web com foco em APIs, abra\u00e7ando desde os fundamentos da comunica\u00e7\u00e3o na web at\u00e9 as pr\u00e1ticas de troca de dados. Exploramos o modelo cliente-servidor, entendemos algumas das nuances das mensagens HTTP e tivemos uma introdu\u00e7\u00e3o sobre URLs e HTML. Embora o HTML desempenhe um papel central na camada de apresenta\u00e7\u00e3o, o nosso foco recaiu sobre as APIs, particularmente aquelas que trafegam JSON, um formato de dados.</p> <p>Aprofundamos no uso de ferramentas e conceitos vitais para a cria\u00e7\u00e3o de APIs, como o FastAPI e o Pydantic, que juntos oferecem uma poderosa combina\u00e7\u00e3o para a valida\u00e7\u00e3o de dados e a gera\u00e7\u00e3o autom\u00e1tica de documenta\u00e7\u00e3o. A explora\u00e7\u00e3o do Swagger UI e do Redoc enriqueceu nosso entendimento sobre a import\u00e2ncia da documenta\u00e7\u00e3o acess\u00edvel e clara para APIs, facilitando tanto o desenvolvimento quanto a usabilidade.</p> <p>Essa aula nos deu uma fundamenta\u00e7\u00e3o b\u00e1sica para avan\u00e7armos na constru\u00e7\u00e3o de APIs. Embora tenhamos exemplificado os conceitos com FastAPI, esses conceitos te\u00f3ricos podem ajudar voc\u00ea a desenvolver ferramentas web em qualquer tecnologia ou linguagem.</p> <p>Nos vemos nas pr\u00f3ximas aulas para aplicar todos esses conceitos de forma mais aprofundada!</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p> <ol> <li> <p>O c\u00f3digo 209 n\u00e3o \u00e9 um status code v\u00e1lido no http, por isso o usei como exemplo.\u00a0\u21a9</p> </li> <li> <p>Apesar da no\u00e7\u00e3o comum de que APIs modernas s\u00e3o projetadas para trafegar JSON, existem debates intensos sobre as melhores pr\u00e1ticas para a transfer\u00eancia de dados em APIs. Uma leitura recomendada \u00e9 o livro hypermedia systems, que \u00e9 gratuito e oferece percep\u00e7\u00f5es valiosas.\u00a0\u21a9</p> </li> </ol>"},{"location":"03/","title":"Estruturando o projeto e criando rotas CRUD","text":""},{"location":"03/#estruturando-o-projeto-e-criando-rotas-crud","title":"Estruturando o projeto e criando rotas CRUD","text":"<p>Objetivos dessa aula:</p> <ul> <li>Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)</li> <li>Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na valida\u00e7\u00e3o e serializa\u00e7\u00e3o de dados</li> <li>Implementa\u00e7\u00e3o de rotas CRUD em FastAPI</li> <li>Escrita e execu\u00e7\u00e3o de testes para validar o comportamento das rotas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Boas-vindas de volta \u00e0 nossa s\u00e9rie de aulas sobre a constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o utilizando FastAPI. Na \u00faltima aula, abordamos conceitos b\u00e1sicos do desenvolvimento web e finalizamos a configura\u00e7\u00e3o do nosso ambiente. Hoje, avan\u00e7aremos na estrutura\u00e7\u00e3o dos primeiros endpoints da nossa API, concentrando-nos nas quatro opera\u00e7\u00f5es fundamentais de CRUD - Criar, Ler, Atualizar e Deletar. Exploraremos como estas opera\u00e7\u00f5es se aplicam tanto \u00e0 comunica\u00e7\u00e3o web quanto \u00e0 intera\u00e7\u00e3o com o banco de dados.</p> <p>O objetivo desta aula \u00e9 implementar um sistema de cadastro de usu\u00e1rios na nossa aplica\u00e7\u00e3o. Ao final, voc\u00ea conseguir\u00e1 cadastrar, listar, alterar e deletar usu\u00e1rios, al\u00e9m de realizar testes para validar estas funcionalidades.</p> Nota para pessoas mais experiente sobre essa aula <p>O princ\u00edpio por tr\u00e1s dessa aula \u00e9 demonstrar como construir os endpoints e os testes mais b\u00e1sicos poss\u00edveis.</p> <p>Talvez lhe cause estranhamento o uso de um banco de dados em uma lista e os testes sendo constru\u00eddos a partir de efeitos colaterais. Mas o objetivo principal \u00e9 que as pessoas consigam se concentrar na cria\u00e7\u00e3o dos primeiros testes sem muito atrito.</p> <p>Estas quest\u00f5es ser\u00e3o resolvidas nas aulas seguintes.</p>"},{"location":"03/#crud-e-http","title":"CRUD e HTTP","text":"<p>No desenvolvimento de APIs, existem quatro a\u00e7\u00f5es principais que fazemos com os dados: criar, ler, atualizar e excluir. Essas a\u00e7\u00f5es ajudam a gerenciar os dados no banco de dados e na aplica\u00e7\u00e3o web. Vamos nos focar nesse primeiro momento nas rela\u00e7\u00f5es entre os dados.</p> <p>CRUD \u00e9 um acr\u00f4nimo que representa as quatro opera\u00e7\u00f5es b\u00e1sicas que voc\u00ea pode realizar em qualquer banco de dados persistente:</p> <ul> <li>Create (Criar): adicionar novos registros ao banco de dados.</li> <li>Read (Ler): recuperar registros existentes do banco de dados.</li> <li>Update (Atualizar): modificar registros existentes no banco de dados.</li> <li>Delete (Excluir): remover registros existentes do banco de dados.</li> </ul> <p>Com essas opera\u00e7\u00f5es podemos realizar qualquer tipo de comportamento em uma base dados. Podemos criar um registro, em seguida alter\u00e1-lo, quem sabe depois disso tudo delet\u00e1-lo.</p> <p>Quando falamos de APIs servindo dados, todas essas opera\u00e7\u00f5es t\u00eam alguma forma similar no protocolo HTTP. O protocolo tem verbos para indicar essas mesmas a\u00e7\u00f5es que queremos representar no banco de dados.</p> <ul> <li>POST: \u00e9 usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.</li> <li>GET: \u00e9 usado para quando o cliente deseja requisitar uma informa\u00e7\u00e3o do servidor.</li> <li>PUT: \u00e9 usando no momento em que o cliente deseja informar alguma altera\u00e7\u00e3o nos dados para o servidor.</li> <li>DELETE: usado para dizer ao servidor que delete determinado recurso.</li> </ul> <p>Dessa forma podemos criar associa\u00e7\u00f5es entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, n\u00f3s como clientes devemos comunicar essa inten\u00e7\u00e3o ao servidor usando o m\u00e9todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de create na base de dados.</p>"},{"location":"03/#respostas-da-api","title":"Respostas da API","text":"<p>Usamos c\u00f3digos de status para informar ao cliente o resultado das opera\u00e7\u00f5es no servidor, como se um dado foi criado, encontrado, atualizado ou exclu\u00eddo com sucesso. Por isso investiremos mais algum momento aqui.</p> <p>Os c\u00f3digos que devemos prestar aten\u00e7\u00e3o para responder corretamente as requisi\u00e7\u00f5es. Os casos de sucesso incluem:</p> <ul> <li>200 OK: Indica sucesso na requisi\u00e7\u00e3o.<ul> <li>GET: Quando um dado \u00e9 solicitado e retornado com sucesso.</li> <li>PUT: Quando dados s\u00e3o alterados com sucesso.</li> </ul> </li> <li>201 CREATED: Significa que a solicita\u00e7\u00e3o resultou na cria\u00e7\u00e3o de um novo recurso.<ul> <li>POST: Aplic\u00e1vel quando um dado \u00e9 enviado e criado com sucesso.</li> <li>PUT: Usado quando uma altera\u00e7\u00e3o resulta na cria\u00e7\u00e3o de um novo recurso.</li> </ul> </li> <li>204 NO CONTENT: Retorno do servidor sem conte\u00fado na mensagem.<ul> <li>PUT: Aplic\u00e1vel se a altera\u00e7\u00e3o n\u00e3o gerar um retorno.</li> <li>DELETE: Usado quando a a\u00e7\u00e3o de deletar n\u00e3o gera um retorno.</li> </ul> </li> </ul> <p>Os c\u00f3digos de erro mais comuns que temos que conhecer para lidar com poss\u00edveis erros na aplica\u00e7\u00e3o, s\u00e3o:</p> <ul> <li>404 NOT FOUND: O recurso solicitado n\u00e3o p\u00f4de ser encontrado.</li> <li>422 UNPROCESSABLE ENTITY: o pedido foi bem formado (ou seja, sintaticamente correto), mas n\u00e3o p\u00f4de ser processado.</li> <li>500 INTERNAL SERVER ERROR: Uma mensagem de erro gen\u00e9rica, dada quando uma condi\u00e7\u00e3o inesperada foi encontrada. Geralmente ocorre quando nossa aplica\u00e7\u00e3o apresenta um erro.</li> </ul> <p>Compreendendo esses c\u00f3digos, estamos prontos para iniciar a implementa\u00e7\u00e3o de alguns endpoints e colocar esses conceitos em pr\u00e1tica.</p>"},{"location":"03/#implementando-endpoints","title":"Implementando endpoints","text":"<p>Para facilitar o aprendizado, sugiro dividir a cria\u00e7\u00e3o de novos endpoints em tr\u00eas etapas:</p> <ol> <li>Rela\u00e7\u00e3o com o HTTP: Determinar o verbo HTTP esperado e os c\u00f3digos de resposta para situa\u00e7\u00f5es de sucesso e erro.</li> <li>Modelos de Dados: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de resposta para situa\u00e7\u00f5es de sucesso e erro.</li> <li>Implementa\u00e7\u00e3o do Corpo: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado.</li> </ol> <p>As duas primeiras etapas nos ajudam a definir a interface de comunica\u00e7\u00e3o e como ela ser\u00e1 documentada. A terceira etapa \u00e9 mais espec\u00edfica e envolve decis\u00f5es sobre a intera\u00e7\u00e3o com o banco de dados, valida\u00e7\u00f5es adicionais e a defini\u00e7\u00e3o do que constitui sucesso ou erro na requisi\u00e7\u00e3o.</p> <p>Essas etapas nos orientam na implementa\u00e7\u00e3o completa do endpoint, garantindo que nada seja esquecido.</p>"},{"location":"03/#iniciando-a-implementacao-da-rota-post","title":"Iniciando a implementa\u00e7\u00e3o da rota POST","text":"<p>Nesta aula, nosso foco principal ser\u00e1 desenvolver um sistema de cadastro de usu\u00e1rios. Para isso, a implementa\u00e7\u00e3o de uma forma eficiente para criar novos usu\u00e1rios na base de dados \u00e9 essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao servi\u00e7o a nossa inten\u00e7\u00e3o de enviar novos dados, como no cadastro de usu\u00e1rios.</p>"},{"location":"03/#implementacao-do-endpoint","title":"Implementa\u00e7\u00e3o do endpoint","text":"<p>Para iniciar, criaremos um endpoint que aceita o verbo <code>POST</code> com dados em formato JSON. Esse endpoint responder\u00e1 com o status <code>201</code> em caso de sucesso na cria\u00e7\u00e3o do recurso. Com isso, estabelecemos a base para a nossa funcionalidade de cadastro.</p> <p>Usaremos o decorador <code>@app.post()</code> do FastAPI para definir nosso endpoint, que come\u00e7ar\u00e1 com a URL <code>/users/</code>, indicando onde receberemos os dados para criar novos usu\u00e1rios:</p> fast_zero/app.py<pre><code>@app.post('/users/')\ndef create_user():\n    ...\n</code></pre>"},{"location":"03/#status-code-de-resposta","title":"Status code de resposta","text":"<p>\u00c9 crucial definir que, ao cadastrar um usu\u00e1rio com sucesso, o sistema deve retornar o c\u00f3digo de resposta <code>201 CREATED</code>, indicando a cria\u00e7\u00e3o bem-sucedida do recurso. Para isso, adicionamos o par\u00e2metro <code>status_code</code> ao decorador:</p> fast_zero/app.py<pre><code>@app.post('/users/', status_code=HTTPStatus.CREATED)\ndef create_user():\n    ...\n</code></pre> <p>Conversaremos em breve sobre os c\u00f3digos de resposta no t\u00f3pico do pydantic</p>"},{"location":"03/#modelo-de-dados","title":"Modelo de dados","text":"<p>O modelo de dados \u00e9 uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que ser\u00e3o retornados a ele. Esta abordagem assegura uma comunica\u00e7\u00e3o eficaz e clara.</p>"},{"location":"03/#modelo-de-entrada-de-dados","title":"Modelo de entrada de dados","text":"<p>Para os dados de entrada, como estamos pensando em um cadastro de usu\u00e1rio na aplica\u00e7\u00e3o, \u00e9 importante que tenhamos insumos para identific\u00e1-lo como o <code>email</code>, uma senha (<code>password</code>) para que ele consiga fazer o login no futuro e seu nome de usu\u00e1rio (<code>username</code>). Dessa forma, podemos imaginar um modelo de entrada desta forma:</p> <pre><code>{\n    \"username\": \"joao123\",\n    \"email\": \"joao123@email.com\",\n    \"password\": \"segredo123\"\n}\n</code></pre> <p>Para a aplica\u00e7\u00e3o conseguir expor esse modelo na documenta\u00e7\u00e3o, devemos criar uma classe do pydantic em nosso arquivo de schemas (<code>fast_zero/schemas.py</code>) que represente esse schema:</p> fast_zero/schemas.py<pre><code>class UserSchema(BaseModel):\n    username: str\n    email: str\n    password: str\n</code></pre> <p>Como j\u00e1 temos o endpoint definido, precisamos fazer a associa\u00e7\u00e3o do modelo com ele. Para fazer isso basta que o endpoint receba um par\u00e2metro e esse par\u00e2metro esteja associado a um modelo via anota\u00e7\u00e3o de par\u00e2metros:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserSchema\n\n# ...\n\n@app.post('/users/', status_code=HTTPStatus.CREATED)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Dessa forma, o modelo de entrada, o que o endpoint espera receber j\u00e1 est\u00e1 documentado e aparecer\u00e1 no swagger UI.</p> <p>Para visualizar, temos que iniciar o servidor:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre> <p>E acessar a p\u00e1gina http://127.0.0.1:8000/docs. Isso nos mostrar\u00e1 as defini\u00e7\u00f5es do nosso endpoint usando o modelo no swagger:</p> <p></p>"},{"location":"03/#modelo-de-saida-de-dados","title":"Modelo de sa\u00edda de dados","text":"<p>O modelo de sa\u00edda explica ao cliente quais dados ser\u00e3o retornados quando a chamada a esse endpoint for feita. Para a API ter um uso flu\u00eddo, temos que especificar o retorno corretamente na documenta\u00e7\u00e3o.</p> <p>Se dermos uma olhada no estado atual de resposta da nossa API, podemos ver que a resposta no swagger \u00e9 <code>\"string\"</code> para o c\u00f3digo de resposta <code>201</code>:</p> <p></p> <p>Quando fazemos uma chamada com o m\u00e9todo POST o esperado \u00e9 que os dados criados sejam retornados ao cliente. Poder\u00edamos usar o mesmo modelo de antes o <code>UserSchema</code>, por\u00e9m, por uma quest\u00e3o de seguran\u00e7a, seria ideal n\u00e3o retornar a senha do usu\u00e1rio. Quanto menos ela trafegar na rede, melhor.</p> <p>Desta forma, podemos pensar no mesmo schema, por\u00e9m, sem a senha. Algo como:</p> <pre><code>{\n    \"username\": \"joao123\",\n    \"email\": \"joao123@email.com\"\n}\n</code></pre> <p>Transcrevendo isso em um modelo do pydantic em nosso arquivo de schemas (<code>fast_zero/schemas.py</code>) temos isso:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\n    username: str\n    email: str\n</code></pre> <p>Para aplicar um modelo a resposta do endpoint, temos que passar o modelo ao par\u00e2metro <code>response_model</code>, como fizemos na aula passada:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserPublic, UserSchema\n\n# C\u00f3digo omitido\n\n@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Tendo um modelo descritivo de resposta para o cliente na documenta\u00e7\u00e3o:</p> <p></p>"},{"location":"03/#validacao-e-pydantic","title":"Valida\u00e7\u00e3o e pydantic","text":"<p>Um ponto crucial do Pydantic \u00e9 sua habilidade de checar se os dados est\u00e3o corretos enquanto o programa est\u00e1 rodando, garantindo que tudo esteja conforme esperado. Fazendo com que, caso o cliente envie um dado que n\u00e3o corresponde com o schema definido, seja levantado um erro <code>422</code>. E caso a nossa resposta como servidor tamb\u00e9m n\u00e3o siga o schema, ser\u00e1 levantado um erro <code>500</code>. Fazendo com que ele seja uma garantia de duas vias, nossa API segue a especifica\u00e7\u00e3o da documenta\u00e7\u00e3o.</p> <p>Quando relacionamos um modelo \u00e0 resposta do endpoint, o Pydantic de forma autom\u00e1tica, cria um schema chamado <code>HTTPValidationError</code>:</p> <p></p> <p>Esse modelo \u00e9 usado quando o JSON enviado na requisi\u00e7\u00e3o n\u00e3o cumpre os requisitos do schema.</p> <p>Por exemplo, se fizermos uma requisi\u00e7\u00e3o que foge dos padr\u00f5es definidos no schema:</p> <p></p> <p>Essa requisi\u00e7\u00e3o foge dos padr\u00f5es, pois n\u00e3o envia o campo <code>password</code> e envia o tipo de dado errado para <code>email</code>.</p> <p>Com isso, receberemos um erro <code>422 UNPROCESSABLE ENTITY</code>, dizendo que nosso schema foi violado e a resposta cont\u00e9m os detalhes dos campos faltantes ou mal formatados:</p> <p></p> <p>A mensagem completa de retorno do servidor mostra de forma detalhada os erros de valida\u00e7\u00e3o encontrados em cada campo, individualmente no campo <code>details</code>:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"type\": \"string_type\", # (1)!\n      \"loc\": [\n        \"body\",\n        \"email\" # (2)!\n      ],\n      \"msg\": \"Input should be a valid string\", #(3)!\n      \"input\": 1,\n      \"url\": \"https://errors.pydantic.dev/2.5/v/string_type\"\n    },\n    {\n      \"type\": \"missing\", #(4)!\n      \"loc\": [\n        \"body\",\n        \"password\" #(5)!\n      ],\n      \"msg\": \"Field required\", #(6)!\n      \"input\": {\n        \"username\": \"string\",\n        \"email\": 1\n      },\n      \"url\": \"https://errors.pydantic.dev/2.5/v/missing\"\n    }\n  ]\n}\n</code></pre> <ol> <li>Tipo de erro no campo: Era esperado que o valor fosse string (string_type)</li> <li>Campo notificado</li> <li>Mensagem que acompanha o erro</li> <li>Tipo de erro no campo: Era esperado que o valor fosse enviado (missing)</li> <li>Campo notificado</li> <li>Mensagem que acompanha o erro</li> </ol> <p>Vemos que o pydantic desempenha um papel bastante importante no funcionamento da API. Pois ele consegue \"barrar\" o request antes dele ser exposto \u00e0 nossa fun\u00e7\u00e3o de endpoint. Evitando que diversos casos estranhos sejam cobertos de forma transparente. Tanto em rela\u00e7\u00e3o aos tipos dos campos, quanto em rela\u00e7\u00e3o aos campos que deveriam ser enviados, mas n\u00e3o foram.</p>"},{"location":"03/#estendendo-a-validacao-com-e-mail","title":"Estendendo a valida\u00e7\u00e3o com e-mail","text":"<p>Outro ponto que deve ser considerado \u00e9 a capacidade de estender os campos usados pelo pydantic nas anota\u00e7\u00f5es de tipo.</p> <p>Para garantir que o campo <code>email</code> realmente contenha um e-mail v\u00e1lido, podemos usar uma ferramenta especial do Pydantic que verifica se o e-mail tem o formato correto, como a presen\u00e7a de <code>@</code> e um dom\u00ednio v\u00e1lido.</p> <p>Para isso, o pydantic tem um tipo de dado espec\u00edfico, o <code>EmailStr</code>. Que garante que o valor que ser\u00e1 recebido pelo schema, seja de fato um e-mail em formato v\u00e1lido. Podemos adicion\u00e1-lo ao campo <code>email</code> nos modelos <code>UserSchema</code> e <code>UserPublic</code>:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\n# C\u00f3digo omitido\n\nclass UserSchema(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserPublic(BaseModel):\n    username: str\n    email: EmailStr\n</code></pre> <p>Com isso, o pydantic ir\u00e1 oferecer um exemplo de email no swagger <code>\"user@example.com\"</code> e acerta os schemas para fazer essas valida\u00e7\u00f5es:</p> <p></p> <p>Dessa forma, o campo esperar\u00e1 n\u00e3o somente uma string como antes, mas um endere\u00e7o de email v\u00e1lido.</p>"},{"location":"03/#validacao-da-resposta","title":"Valida\u00e7\u00e3o da resposta","text":"<p>Ap\u00f3s aperfei\u00e7oarmos nossos modelos do Pydantic para garantir que os dados de entrada e sa\u00edda estejam corretamente validados, chegamos a um ponto crucial: a implementa\u00e7\u00e3o do corpo do nosso endpoint. At\u00e9 agora, nosso endpoint est\u00e1 definido, mas sem uma l\u00f3gica de processamento real, conforme mostrado abaixo:</p> fast_zero/app.py<pre><code>@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Este \u00e9 o momento perfeito para realizar um request e observar diretamente a atua\u00e7\u00e3o do Pydantic na valida\u00e7\u00e3o da resposta. Ao tentarmos executar um request v\u00e1lido, sem a implementa\u00e7\u00e3o adequada do endpoint, nos deparamos com uma situa\u00e7\u00e3o interessante: o Pydantic tenta validar a resposta que o nosso endpoint deveria fornecer, mas, como ainda n\u00e3o implementamos essa l\u00f3gica, o resultado n\u00e3o atende ao schema definido.</p> <p></p> <p>A tentativa resulta em uma mensagem de erro exibida diretamente no Swagger, indicando um erro de servidor interno (HTTP 500). Esse tipo de erro sugere que algo deu errado no lado do servidor, mas n\u00e3o oferece detalhes espec\u00edficos sobre a natureza do problema para o cliente. O erro 500 \u00e9 uma resposta gen\u00e9rica para indicar falhas no servidor.</p> <p></p> <p>Para investigar a causa exata do erro 500, \u00e9 necess\u00e1rio consultar o console ou os logs de nossa aplica\u00e7\u00e3o, onde os detalhes do erro s\u00e3o registrados. Neste caso, o erro apresentado nos logs \u00e9 o seguinte:</p> <pre><code>raise ResponseValidationError( # (1)!\nfastapi.exceptions.ResponseValidationError: 1 validation errors:\n{\n  \"type\":\"model_attributes_type\",\n  \"loc\": (\"response\"),\n  \"msg\":\"Input should be a valid dictionary or object to extract fields from\",#(2)!\n  \"input\":\"None\", #(3)!\n  \"url\":\"https://errors.pydantic.dev/2.6/v/model_attributes_type\"\n}\n</code></pre> <ol> <li>O json dessa mensagem de erro aparece em uma \u00fanica linha. Eu fiz a quebra para que ficasse mais f\u00e1cil de lermos a resposta.</li> <li>A mensagem de erro diz que o input passado ao modelo do pydantic deveria ser um dicion\u00e1rio v\u00e1lido ou um objeto onde os campos poderiam ser extra\u00eddos.</li> <li>O objeto enviado ao modelo</li> </ol> <p>Essencialmente, o erro nos informa que o modelo esperava receber um objeto v\u00e1lido para processamento, mas, em vez disso, recebeu <code>None</code>. Isso ocorre porque ainda n\u00e3o implementamos a l\u00f3gica para processar o input recebido e retornar uma resposta adequada que corresponda ao modelo <code>UserPublic</code>.</p> <p>Agora, tendo identificado a capacidade do Pydantic em validar as respostas e encontrarmos um erro devido \u00e0 falta de implementa\u00e7\u00e3o, podemos proceder com uma solu\u00e7\u00e3o simples. Para come\u00e7ar, podemos utilizar diretamente os dados recebidos em <code>user</code> e retorn\u00e1-los. Esta a\u00e7\u00e3o simples j\u00e1 \u00e9 suficiente para satisfazer o schema, pois o objeto <code>user</code> cont\u00e9m os atributos <code>email</code> e <code>username</code>, esperados pelo modelo <code>UserPublic</code>:</p> fast_zero/app.py<pre><code>@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    return user\n</code></pre> <p>Este retorno simples do objeto <code>user</code> garante que o schema seja cumprido. Agora, ao realizarmos novamente a chamada no Swagger, o objeto que enviamos \u00e9 retornado conforme esperado, mas sem expor a senha, alinhado ao modelo <code>UserPublic</code> e emitindo uma resposta com o c\u00f3digo 201:</p> <p></p> <p>Essa abordagem nos permite fechar o ciclo de valida\u00e7\u00e3o, demonstrando a efic\u00e1cia do Pydantic na garantia de que os dados de resposta estejam corretos. Com essa implementa\u00e7\u00e3o simples, estabelecemos a base para o desenvolvimento real do c\u00f3digo do endpoint POST, preparando o terreno para uma l\u00f3gica mais complexa que envolver\u00e1 a cria\u00e7\u00e3o e o manejo de usu\u00e1rios dentro de nossa aplica\u00e7\u00e3o.</p>"},{"location":"03/#de-volta-ao-post","title":"De volta ao POST","text":"<p>Agora que j\u00e1 dominamos a defini\u00e7\u00e3o dos modelos, podemos prosseguir com a aula e a implementa\u00e7\u00e3o dos endpoints. Vamos retomar a implementa\u00e7\u00e3o do POST, adicionando um banco de dados falso/simulado em mem\u00f3ria. Isso nos permitir\u00e1 explorar as opera\u00e7\u00f5es do CRUD sem a complexidade da implementa\u00e7\u00e3o de um banco de dados real, facilitando a assimila\u00e7\u00e3o dos muitos conceitos discutidos nesta aula.</p>"},{"location":"03/#criando-um-banco-de-dados-falso","title":"Criando um banco de dados falso","text":"<p>Para interagir com essas rotas de maneira pr\u00e1tica, vamos criar uma lista provis\u00f3ria que simular\u00e1 um banco de dados. Isso nos permitir\u00e1 adicionar dados e entender o funcionamento do FastAPI. Portanto, introduzimos uma lista provis\u00f3ria para atuar como nosso \"banco\" e modificamos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserDB, UserPublic, UserSchema\n\n# c\u00f3digo omitido\n\ndatabase = []  #(1)!\n\n# c\u00f3digo omitido\n\n@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)  #(2)!\n\n    database.append(user_with_id)\n\n    return user_with_id\n</code></pre> <ol> <li> <p>A lista <code>database</code> \u00e9 provis\u00f3ria. Ela est\u00e1 aqui s\u00f3 para entendermos os conceitos de crud, nas pr\u00f3ximas aulas vamos trabalhar com a cria\u00e7\u00e3o do banco de dados definitivo.</p> </li> <li> <p><code>.model_dump()</code> \u00e9 um m\u00e9todo de modelos do pydantic que converte o objeto em dicion\u00e1rio. Por exemplo, <code>user.model_dump()</code> faria a convers\u00e3o em <code>{'username': 'nome do usu\u00e1rio', 'password': 'senha do usu\u00e1rio', 'email': 'email do usu\u00e1rio'}</code>. Os <code>**</code> querem dizer que o dicion\u00e1rio ser\u00e1 desempacotado em par\u00e2metros. Fazendo com que a chamada seja equivalente a <code>UserDB(username='nome do usu\u00e1rio', password='senha do usu\u00e1rio', email='email do usu\u00e1rio', id=len(database) + 1)</code></p> </li> </ol> <p>Para simular um banco de dados de forma mais realista, \u00e9 essencial que cada usu\u00e1rio tenha um ID \u00fanico. Portanto, ajustamos nosso modelo de resposta p\u00fablica (<code>UserPublic</code>) para incluir o ID do usu\u00e1rio. Tamb\u00e9m introduzimos um novo modelo, <code>UserDB</code>, que inclui tanto a senha do usu\u00e1rio quanto seu identificador \u00fanico:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n\nclass UserDB(UserSchema):\n    id: int\n</code></pre> <p>Essa abordagem simples nos permite avan\u00e7ar na constru\u00e7\u00e3o dos outros endpoints. \u00c9 crucial testar esse endpoint para assegurar seu correto funcionamento.</p>"},{"location":"03/#implementando-o-teste-da-rota-post","title":"Implementando o teste da rota POST","text":"<p>Antes de prosseguir, vamos verificar a cobertura de nossos testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# parte da resposta foi omitida\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      3    75%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      3    87%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever. Podemos olhar o HTML do coverage para ter certeza:</p> <p></p> <p>Ent\u00e3o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria\u00e7\u00e3o de um novo usu\u00e1rio funciona corretamente. Enviamos uma solicita\u00e7\u00e3o POST com um novo usu\u00e1rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont\u00e9m o novo usu\u00e1rio criado.</p> tests/test_app.py<pre><code>def test_create_user():\n    client = TestClient(app)\n\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CREATED\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Ao executar o teste:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# parte da resposta foi omitida\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      0   100%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      0   100%\n\n# parte da resposta foi omitida\n</code></pre>"},{"location":"03/#nao-se-repita-dry","title":"N\u00e3o se repita (DRY)","text":"<p>Voc\u00ea deve ter notado que a linha <code>client = TestClient(app)</code> est\u00e1 repetida na primeira linha dos dois testes que fizemos. Repetir c\u00f3digo pode tornar o gerenciamento de testes mais complexo \u00e0 medida que cresce, e \u00e9 aqui que o princ\u00edpio de \"N\u00e3o se repita\" (DRY) entra em jogo. DRY incentiva a redu\u00e7\u00e3o da repeti\u00e7\u00e3o, criando um c\u00f3digo mais limpo e manuten\u00edvel.</p> <p>Para solucionar essa repeti\u00e7\u00e3o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture \u00e9 como uma fun\u00e7\u00e3o que prepara dados ou estado necess\u00e1rios para o teste. Pode ser pensada como uma forma de n\u00e3o repetir a fase de Arrange de um teste, simplificando a chamada e n\u00e3o repetindo c\u00f3digo.</p> Se fixtures s\u00e3o uma novidade para voc\u00ea <p>Existe uma live de Python onde discutimos especificamente sobre fixtures </p> <p> Link direto </p> <p>Neste caso, criaremos uma fixture que retorna nosso <code>client</code>. Para fazer isso, precisamos criar o arquivo <code>tests/conftest.py</code>. O arquivo <code>conftest.py</code> \u00e9 um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes m\u00f3dulos de teste em um projeto. \u00c9 uma forma de centralizar recursos comuns de teste.</p> tests/conftest.py<pre><code>import pytest\nfrom fastapi.testclient import TestClient\n\nfrom fast_zero.app import app\n\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n</code></pre> <p>Agora, em vez de repetir a cria\u00e7\u00e3o do <code>client</code> em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:</p> tests/test_app.py<pre><code>from http import HTTPStatus\n\n\ndef test_root_deve_retornar_ok_e_ola_mundo(client):\n    response = client.get('/')\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}\n\n\ndef test_create_user(client):\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CREATED\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Com essa simples mudan\u00e7a, conseguimos tornar nosso c\u00f3digo mais limpo e f\u00e1cil de manter, seguindo o princ\u00edpio DRY.</p> <p>Vemos que estamos no caminho certo. Agora que a rota POST est\u00e1 implementada, seguiremos para a pr\u00f3xima opera\u00e7\u00e3o CRUD: Read.</p>"},{"location":"03/#implementando-a-rota-get","title":"Implementando a Rota GET","text":"<p>A rota GET \u00e9 usada para recuperar informa\u00e7\u00f5es de um ou mais usu\u00e1rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Read\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).</p> <p>Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado <code>UserList</code>. Este modelo representar\u00e1 uma lista de usu\u00e1rios e cont\u00e9m apenas um campo chamado <code>users</code>, que \u00e9 uma lista de <code>UserPublic</code>. Isso nos permite retornar m\u00faltiplos usu\u00e1rios de uma vez.</p> fast_zero/schemas.py<pre><code>class UserList(BaseModel):\n    users: list[UserPublic]\n</code></pre> <p>Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar\u00e1 uma inst\u00e2ncia de <code>UserList</code>, que por sua vez cont\u00e9m uma lista de <code>UserPublic</code>. Cada <code>UserPublic</code> \u00e9 criado a partir dos dados de um usu\u00e1rio em nosso banco de dados fict\u00edcio.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserDB, UserList, UserPublic, UserSchema\n\n# c\u00f3digo omitido\n\n@app.get('/users/', response_model=UserList)\ndef read_users():\n    return {'users': database}\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, nossa API agora pode retornar uma lista de usu\u00e1rios. No entanto, nosso trabalho ainda n\u00e3o acabou. A pr\u00f3xima etapa \u00e9 escrever testes para garantir que nossa rota GET est\u00e1 funcionando corretamente. Isso nos ajudar\u00e1 a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa\u00e7\u00e3o de outras rotas.</p>"},{"location":"03/#implementando-o-teste-da-rota-de-get","title":"Implementando o teste da rota de GET","text":"<p>Nosso teste da rota GET tem que verificar se a recupera\u00e7\u00e3o dos usu\u00e1rios est\u00e1 funcionando corretamente. Enviamos uma solicita\u00e7\u00e3o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m a lista de usu\u00e1rios.</p> tests/test_app.py<pre><code>def test_read_users(client):\n    response = client.get('/users/')\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'users': [\n            {\n                'username': 'alice',\n                'email': 'alice@example.com',\n                'id': 1,\n            }\n        ]\n    }\n</code></pre> <p>Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu\u00e1rios. Implementaremos a pr\u00f3xima opera\u00e7\u00e3o CRUD: Update.</p> <p>Coisas que devemos considerar sobre este e os pr\u00f3ximos testes</p> <p>Note que para que esse teste seja executado com sucesso o teste do endpoint de <code>POST</code> tem que ser executado antes. Isso \u00e9 problem\u00e1tico no mundo dos testes. Pois cada teste deve estar isolado e n\u00e3o depender da execu\u00e7\u00e3o de nada externo a ele.</p> <p>Para que isso aconte\u00e7a, precisaremos de um mecanismo que reinicie o banco de dados a cada teste, mas ainda n\u00e3o temos um banco de dados real. O banco de dados ser\u00e1 introduzido na aplica\u00e7\u00e3o na aula 04.</p> <p>O mecanismo que far\u00e1 com que os testes n\u00e3o interfiram em outros e sejam independentes ser\u00e1 introduzido na aula 05.</p>"},{"location":"03/#implementando-a-rota-put","title":"Implementando a Rota PUT","text":"<p>A rota PUT \u00e9 usada para atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente. No contexto do CRUD, o verbo HTTP PUT est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Update\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> <p>Uma caracter\u00edstica importante do verbo PUT \u00e9 que ele \u00e9 direcionado a um recurso em espec\u00edfico. Nesse caso, estamos direcionando a altera\u00e7\u00e3o a um <code>user</code> em espec\u00edfico na base de dados. O identificador de <code>user</code> \u00e9 o campo <code>id</code> que estamos usando nos modelos do Pydantic. Nesse caso, nosso endpoint deve receber o identificador de quem ser\u00e1 alterado.</p> <p>Para fazer essa identifica\u00e7\u00e3o do recurso na URL usamos a seguinte combina\u00e7\u00e3o <code>/caminho/recurso</code>. Mas, como o recurso \u00e9 din\u00e2mico, ele deve ser enviado pelo cliente. Fazendo com que o valor tenha que ser uma vari\u00e1vel.</p> <p>Dentro do FastAPI, as vari\u00e1veis de recursos s\u00e3o descritas dentro de {}, como <code>{user_id}</code>. Fazendo com que o caminho completo do nosso endpoint seja <code>'/users/{user_id}'</code>. Da seguinte forma:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI, HTTPException\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(user_id: int, user: UserSchema):\n    if user_id &gt; len(database) or user_id &lt; 1: #(1)!\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        ) #(2)!\n\n    user_with_id = UserDB(**user.model_dump(), id=user_id)\n    database[user_id - 1] = user_with_id #(3)!\n\n    return user_with_id\n</code></pre> <ol> <li>Aqui fazemos uma valida\u00e7\u00e3o simples, verificamos se o id n\u00e3o \u00e9 maior que o tamanho da lista <code>user_id &gt; len(database)</code> e o n\u00famero enviado para o <code>user_id</code> \u00e9 um valor positivo <code>user_id &lt; 1</code>.</li> <li>Levantamos um erro do tipo <code>HTTPException</code> para dizer que o usu\u00e1rio n\u00e3o existe na base de dados. Esse modelo j\u00e1 est\u00e1 presente no swagger com <code>HTTPValidationError</code>.</li> <li>Nessa linha, estamos substituindo a posi\u00e7\u00e3o (<code>user_id - 1</code>) na lista pelo novo objeto.</li> </ol> <p>Para que essa vari\u00e1vel definida na URL seja transferida para nosso endpoint, devemos adicionar um par\u00e2metro na fun\u00e7\u00e3o com o mesmo nome da vari\u00e1vel definida. Como <code>def update_user(user_id: int)</code> na linha em destaque.</p>"},{"location":"03/#implementando-o-teste-da-rota-de-put","title":"Implementando o teste da rota de PUT","text":"<p>Nosso teste da rota PUT precisa verificar se a atualiza\u00e7\u00e3o de um usu\u00e1rio existente funciona corretamente. Enviamos uma solicita\u00e7\u00e3o PUT com as novas informa\u00e7\u00f5es do usu\u00e1rio para a rota <code>/users/{user_id}</code>. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m o usu\u00e1rio atualizado.</p> tests/test_app.py<pre><code>def test_update_user(client):\n    response = client.put(\n        '/users/1',\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu\u00e1rios. A \u00faltima opera\u00e7\u00e3o CRUD que precisamos implementar \u00e9 Delete.</p>"},{"location":"03/#implementando-a-rota-delete","title":"Implementando a Rota DELETE","text":"<p>A rota DELETE \u00e9 usada para excluir um usu\u00e1rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Delete\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> <p>Este endpoint receber\u00e1 o ID do usu\u00e1rio que queremos excluir. Note que, estamos lan\u00e7ando uma exce\u00e7\u00e3o HTTP quando o ID do usu\u00e1rio est\u00e1 fora do range da nossa lista (simula\u00e7\u00e3o do nosso banco de dados). Quando conseguimos excluir o usu\u00e1rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo <code>Message</code>.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int):\n    if user_id &gt; len(database) or user_id &lt; 1:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    del database[user_id - 1]\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Com a implementa\u00e7\u00e3o da rota DELETE conclu\u00edda, \u00e9 fundamental garantirmos que essa rota est\u00e1 funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.</p>"},{"location":"03/#implementando-o-teste-da-rota-de-delete","title":"Implementando o teste da rota de DELETE","text":"<p>Nosso teste da rota DELETE precisa verificar se a exclus\u00e3o de um usu\u00e1rio existente funciona corretamente. Enviamos uma solicita\u00e7\u00e3o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m uma mensagem informando que o usu\u00e1rio foi exclu\u00eddo.</p> tests/test_app.py<pre><code>def test_delete_user(client):\n    response = client.delete('/users/1')\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'User deleted'}\n</code></pre>"},{"location":"03/#checando-tudo-antes-do-commit","title":"Checando tudo antes do commit","text":"<p>Antes de fazermos o commit, \u00e9 uma boa pr\u00e1tica checarmos todo o c\u00f3digo, e podemos fazer isso com as a\u00e7\u00f5es que criamos com o taskipy.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>$ task lint\n</code></pre> $ Execu\u00e7\u00e3o no terminal!<pre><code>$ task format\n6 files left unchanged\n</code></pre> $ Execu\u00e7\u00e3o no terminal!<pre><code>$ task test\n...\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\n\n---------- coverage: platform linux, python 3.11.4-final-0 -----------\nName                   Stmts   Miss  Cover\n------------------------------------------\nfastzero/__init__.py       0      0   100%\nfastzero/app.py           28      2    93%\nfastzero/schemas.py       15      0   100%\n------------------------------------------\nTOTAL                     43      2    95%\n\n\n============================ 5 passed in 1.48s =============================\nWrote HTML report to htmlcov/index.html\n</code></pre>"},{"location":"03/#commit","title":"Commit","text":"<p>Ap\u00f3s toda essa jornada de aprendizado, constru\u00e7\u00e3o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares \u00e9 uma boa pr\u00e1tica, pois mant\u00e9m um hist\u00f3rico detalhado das altera\u00e7\u00f5es e facilita a volta a uma vers\u00e3o anterior do c\u00f3digo, se necess\u00e1rio.</p> <p>Primeiramente, verificaremos as altera\u00e7\u00f5es feitas no projeto com o comando <code>git status</code>. Este comando nos mostrar\u00e1 todos os arquivos modificados que ainda n\u00e3o foram inclu\u00eddos em um commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Em seguida, adicionaremos todas as altera\u00e7\u00f5es para o pr\u00f3ximo commit. O comando <code>git add .</code> adiciona todas as altera\u00e7\u00f5es feitas em todos os arquivos do projeto.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit. Com o comando <code>git commit</code>, criamos uma nova entrada no hist\u00f3rico do nosso projeto. \u00c9 importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou n\u00f3s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser \"Implementando rotas CRUD\".</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Implementando rotas CRUD\"\n</code></pre> <p>Por fim, enviamos nossas altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code>. Se voc\u00ea tiver v\u00e1rias branches, certifique-se de estar na branch correta antes de executar este comando.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As altera\u00e7\u00f5es est\u00e3o seguras no hist\u00f3rico do git, e podemos continuar com o pr\u00f3ximo passo do projeto.</p>"},{"location":"03/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Para pr\u00f3xima aula, caso voc\u00ea n\u00e3o tenha nenhuma familiaridade com o SQLAlchemy ou com o Alembic, recomendo que assista a essas lives para se preparar e nivelar um pouco o conhecimento sobre essas ferramentas:</p> <ul> <li>SQLAlchemy: conceitos b\u00e1sicos, uma introdu\u00e7\u00e3o a vers\u00e3o 2 | Live de Python #258</li> <li>Migra\u00e7\u00f5es, bancos de dados evolutivos (Alembic e SQLAlchemy) | Live de Python #211</li> </ul> <p>Outro recurso que usaremos na pr\u00f3xima aula e pode te ajudar saber um pouco, s\u00e3o as vari\u00e1veis de ambiente. Tema abordado em:</p> <ul> <li>Vari\u00e1veis de ambiente, dotenv, constantes e configura\u00e7\u00f5es | Live de Python #207</li> </ul>"},{"location":"03/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Escrever um teste para o erro de <code>404</code> (NOT FOUND) para o endpoint de PUT;</li> <li>Escrever um teste para o erro de <code>404</code> (NOT FOUND) para o endpoint de DELETE;</li> <li>Criar um endpoint de GET para pegar um \u00fanico recurso como <code>users/{id}</code> e fazer seus testes para <code>200</code> e <code>404</code>.</li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"03/#conclusao","title":"Conclus\u00e3o","text":"<p>Com a implementa\u00e7\u00e3o bem-sucedida das rotas CRUD, demos um passo significativo na constru\u00e7\u00e3o de uma API funcional com FastAPI. Agora podemos manipular usu\u00e1rios - criar, ler, atualizar e excluir - o que \u00e9 fundamental para muitos sistemas de informa\u00e7\u00e3o.</p> <p>O papel dos testes em cada etapa n\u00e3o pode ser subestimado. Testes n\u00e3o apenas nos ajudam a assegurar que nosso c\u00f3digo est\u00e1 funcionando como esperado, mas tamb\u00e9m nos permitem refinar nossas solu\u00e7\u00f5es e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import\u00e2ncia de executar seus testes sempre que fizer uma altera\u00e7\u00e3o em seu c\u00f3digo!</p> <p>At\u00e9 aqui, no entanto, trabalhamos com um \"banco de dados\" provis\u00f3rio, na forma de uma lista Python, que \u00e9 vol\u00e1til e n\u00e3o persiste os dados de uma execu\u00e7\u00e3o do aplicativo para outra. Para nosso aplicativo ser \u00fatil em um cen\u00e1rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. \u00c9 a\u00ed que os bancos de dados entram.</p> <p>Outro ponto que deve ser destacado \u00e9 que nossas implementa\u00e7\u00f5es de testes sofrem interfer\u00eancia dos testes anteriores. Testes devem funcionar de forma isolada, sem a depend\u00eancia de um teste anterior. Vamos ajustar isso no futuro.</p> <p>No pr\u00f3ximo t\u00f3pico, exploraremos uma das partes mais cr\u00edticas de qualquer aplicativo - a conex\u00e3o e intera\u00e7\u00e3o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist\u00eancia de nossos dados de usu\u00e1rio entre as sess\u00f5es do aplicativo.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"04/","title":"Configurando o banco de dados e gerenciando migra\u00e7\u00f5es com Alembic","text":""},{"location":"04/#configurando-o-banco-de-dados-e-gerenciando-migracoes-com-alembic","title":"Configurando o banco de dados e gerenciando migra\u00e7\u00f5es com Alembic","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao SQLAlchemy e Alembic</li> <li>Instalando SQLAlchemy e Alembic</li> <li>Configurando e criando o banco de dados</li> <li>Criando e localizando tabelas utilizando SQLAlchemy</li> <li>Testando a cria\u00e7\u00e3o de tabelas</li> <li>Eventos do SQLAlchemy</li> <li>Gerenciando migra\u00e7\u00f5es do banco de dados com Alembic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Com os endpoints da nossa API j\u00e1 estabelecidos, estamos, por ora, utilizando um banco de dados simulado, armazenando uma lista em mem\u00f3ria. Nesta aula, iniciaremos o processo de configura\u00e7\u00e3o do nosso banco de dados real. Nossa agenda inclui a instala\u00e7\u00e3o do SQLAlchemy, a defini\u00e7\u00e3o do modelo de usu\u00e1rios, e a execu\u00e7\u00e3o da primeira migra\u00e7\u00e3o com o Alembic para um banco de dados evolutivo. Al\u00e9m disso, exploraremos como desacoplar as configura\u00e7\u00f5es do banco de dados da aplica\u00e7\u00e3o, seguindo os princ\u00edpios dos 12 fatores.</p> <p>Antes de prosseguirmos com a instala\u00e7\u00e3o e a configura\u00e7\u00e3o, \u00e9 crucial entender alguns conceitos fundamentais sobre ORMs (Object-Relational Mapping).</p>"},{"location":"04/#o-que-e-um-orm-e-por-que-usamos-um","title":"O que \u00e9 um ORM e por que usamos um?","text":"<p>ORM significa Mapeamento Objeto-Relacional. \u00c9 uma t\u00e9cnica de programa\u00e7\u00e3o que vincula (ou mapeia) objetos a registros de banco de dados. Em outras palavras, um ORM permite que voc\u00ea interaja com seu banco de dados, como se voc\u00ea estivesse trabalhando com objetos Python.</p> <p>O SQLAlchemy \u00e9 um exemplo de ORM. Ele permite que voc\u00ea trabalhe com bancos de dados SQL de maneira mais natural aos programadores Python. Em vez de escrever consultas SQL cruas, voc\u00ea pode usar m\u00e9todos e atributos Python para manipular seus registros de banco de dados.</p> <p>Mas por que usar\u00edamos um ORM? Aqui est\u00e3o algumas raz\u00f5es:</p> <ul> <li> <p>Abstra\u00e7\u00e3o de banco de dados: ORMs permitem que voc\u00ea mude de um tipo de banco de dados para outro com poucas altera\u00e7\u00f5es no c\u00f3digo.</p> </li> <li> <p>Seguran\u00e7a: ORMs lidam geralmente com escapagem de consultas e para prevenir inje\u00e7\u00f5es SQL, um tipo comum de vulnerabilidade de seguran\u00e7a.</p> </li> <li> <p>Efici\u00eancia no desenvolvimento: ORMs podem gerar automaticamente esquemas, realizar migra\u00e7\u00f5es e outras tarefas que seriam demoradas para fazer manualmente.</p> </li> </ul>"},{"location":"04/#configuracoes-de-ambiente-e-os-12-fatores","title":"Configura\u00e7\u00f5es de ambiente e os 12 fatores","text":"<p>Uma boa pr\u00e1tica no desenvolvimento de aplica\u00e7\u00f5es \u00e9 separar as configura\u00e7\u00f5es do c\u00f3digo, especialmente para dados sens\u00edveis como credenciais de banco de dados. Essa abordagem resolve dois futuros problemas:</p> <ol> <li>Varia\u00e7\u00e3o entre ambientes: Configura\u00e7\u00f5es costumam mudar entre ambientes diferentes (desenvolvimento, teste e produ\u00e7\u00e3o), e mistur\u00e1-las com o c\u00f3digo pode tornar o processo de mudan\u00e7a entre esses ambientes complicado e propenso a erros.</li> <li>Seguran\u00e7a: Expor credenciais de banco de dados e outras informa\u00e7\u00f5es sens\u00edveis no c\u00f3digo-fonte \u00e9 uma pr\u00e1tica de seguran\u00e7a ruim, pois se um vazamento acontecesse comprometeria o acesso aos seus recursos.</li> </ol> <p>Essa pr\u00e1tica est\u00e1 alinhada com a metodologia dos 12 fatores (especificamente o 3\u00ba fator: Config), que recomenda armazenar configura\u00e7\u00f5es vari\u00e1veis no ambiente e n\u00e3o no c\u00f3digo.</p> Caso queira saber mais sobre 12 fatores <p>Temos uma live focada nesse assunto com a participa\u00e7\u00e3o especial do Bruno Rocha</p> <p></p> <p> Link direto</p> <p>Para gerenciar e separar nossas configura\u00e7\u00f5es do c\u00f3digo de forma segura e estruturada, usaremos o <code>pydantic-settings</code>. Essa biblioteca permite que voc\u00ea defina configura\u00e7\u00f5es tanto em vari\u00e1veis de ambiente quanto em arquivos separados (como <code>.env</code>), evitando a escrita de configura\u00e7\u00f5es diretamente no c\u00f3digo-fonte.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add pydantic-settings\n</code></pre> <p>Agora que entendemos melhor esses conceitos, come\u00e7aremos instalando o SQLAlchemy, um ORM que nos permite trabalhar com bancos de dados SQL de maneira Pythonica. Al\u00e9m disso, o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados, funciona muito bem com o SQLAlchemy e nos ajudar\u00e1 a gerenciar as altera\u00e7\u00f5es do esquema do nosso banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add sqlalchemy\n</code></pre> <p>Agora estamos prontos para mergulhar na configura\u00e7\u00e3o do nosso banco de dados! Vamos em frente.</p>"},{"location":"04/#o-basico-sobre-sqlalchemy","title":"O b\u00e1sico sobre SQLAlchemy","text":"<p>SQLAlchemy \u00e9 uma biblioteca Python vers\u00e1til, concebida para intermediar a intera\u00e7\u00e3o entre Python e bancos de dados relacionais, como MySQL, PostgreSQL e SQLite. A biblioteca \u00e9 constitu\u00edda por duas partes principais: o Core e o ORM (Object Relational Mapper).</p> <ul> <li> <p>Core: O Core do SQLAlchemy disponibiliza uma interface SQL abstrata, que possibilita a manipula\u00e7\u00e3o de bancos de dados relacionais de maneira segura, alinhada com as conven\u00e7\u00f5es do Python. Atrav\u00e9s do Core, \u00e9 poss\u00edvel construir, analisar e executar instru\u00e7\u00f5es SQL, al\u00e9m de conectar-se a diversos tipos de bancos de dados utilizando a mesma API.</p> </li> <li> <p>ORM: ORM, ou Mapeamento Objeto-Relacional, \u00e9 uma t\u00e9cnica que facilita a comunica\u00e7\u00e3o entre o c\u00f3digo orientado a objetos e bancos de dados relacionais. Com o ORM do SQLAlchemy, os desenvolvedores podem interagir com o banco de dados utilizando classes e objetos Python, eliminando a necessidade de escrever instru\u00e7\u00f5es SQL diretamente.</p> </li> </ul> Caso nunca tenha trabalhado com SQLAlchemy <p>Temos uma live de Python cobrindo as mudan\u00e7as e o b\u00e1sico sobre o SQLAlchemy na vers\u00e3o 2+:</p> <p></p> <p>Al\u00e9m do Core e do ORM, o SQLAlchemy conta com outros componentes cruciais que ser\u00e3o foco desta aula, a Engine e a Session:</p>"},{"location":"04/#engine","title":"Engine","text":"<p>A 'Engine' do SQLAlchemy \u00e9 o ponto de contato com o banco de dados, estabelecendo e gerenciando as conex\u00f5es. Ela \u00e9 instanciada atrav\u00e9s da fun\u00e7\u00e3o <code>create_engine()</code>, que recebe as credenciais do banco de dados, o endere\u00e7o de conex\u00e3o (URI) e configura o pool de conex\u00f5es.</p>"},{"location":"04/#session","title":"Session","text":"<p>Quanto \u00e0 persist\u00eancia de dados e consultas ao banco de dados utilizando o ORM, a Session \u00e9 a principal interface. Ela atua como um intermedi\u00e1rio entre o aplicativo Python e o banco de dados, mediada pela Engine. A Session \u00e9 encarregada de todas as transa\u00e7\u00f5es, fornecendo uma API para conduzi-las.</p> <p>Agora que conhecemos a Engine e a Session, vamos explorar a defini\u00e7\u00e3o de modelos de dados.</p>"},{"location":"04/#definindo-os-modelos-de-dados-com-sqlalchemy","title":"Definindo os Modelos de Dados com SQLAlchemy","text":"<p>Os modelos de dados definem a estrutura de como os dados ser\u00e3o armazenados no banco de dados. No ORM do SQLAlchemy, esses modelos s\u00e3o definidos como classes Python que podem ser herdados ou registradas (isso depende de como voc\u00ea usa o ORM). Vamos usar o registrador de tabelas, que j\u00e1 faz a convers\u00e3o autom\u00e1tica das classes em dataclasses</p> <p>Cada classe que \u00e9 registrada pelo objeto <code>registry</code> \u00e9 automaticamente mapeada para uma tabela no banco de dados. Adicionalmente, a classe base inclui um objeto de metadados que \u00e9 uma cole\u00e7\u00e3o de todas as tabelas declaradas. Este objeto \u00e9 utilizado para gerenciar opera\u00e7\u00f5es como cria\u00e7\u00e3o, modifica\u00e7\u00e3o e exclus\u00e3o de tabelas.</p> <p>Agora definiremos nosso modelo <code>User</code>. No diret\u00f3rio <code>fast_zero</code>, crie um novo arquivo chamado <code>models.py</code> e incluiremos o seguinte c\u00f3digo no arquivo:</p> fast_zero/models.py<pre><code>from datetime import datetime\nfrom sqlalchemy.orm import Mapped, mapped_as_dataclass, registry\n\ntable_registry = registry()\n\n\n@mapped_as_dataclass(table_registry)\nclass User:\n    __tablename__ = 'users'\n\n    id: Mapped[int]\n    username: Mapped[str]\n    password: Mapped[str]\n    email: Mapped[str]\n    created_at: Mapped[datetime]\n</code></pre> <p>Aqui, <code>Mapped</code> refere-se a um atributo Python que \u00e9 associado (ou mapeado) a uma coluna espec\u00edfica em uma tabela de banco de dados. Por exemplo, <code>Mapped[int]</code> indica que este atributo \u00e9 um inteiro que ser\u00e1 mapeado para uma coluna correspondente em uma tabela de banco de dados. Da mesma forma, <code>Mapped[str]</code> se referiria a um atributo de string que seria mapeado para uma coluna de string correspondente. Esta abordagem permite ao SQLAlchemy realizar a convers\u00e3o entre os tipos de dados Python e os tipos de dados do banco de dados, al\u00e9m de oferecer uma interface Pythonica para a intera\u00e7\u00e3o entre eles.</p> <p>Em especial, devemos nos atentar com o campo <code>__tablename__</code>. Ele \u00e9 referente ao nome que a tabela ter\u00e1 no banco de dados. Como geralmente um objeto no python representa somente uma entidade, usarei <code>'users'</code> no plural para representar a tabela.</p>"},{"location":"04/#o-uso-do-modelo","title":"O uso do modelo","text":"<p>Se quisermos usar esse objeto, ela se comporta como uma dataclass tradicional. Podendo ser instanciada da forma tradicional:</p> C\u00f3digo de exemplo<pre><code>eduardo = User(\n    id=1,\n    username='dunossauro',\n    password='senha123',\n    email='duno@ssauro.com',\n    created_at=datetime.now()\n)\n</code></pre> <p>Por padr\u00e3o, todos os atributos precisam ser especificados. O que pode n\u00e3o ser muito interessante, pois alguns dados devem ser preenchidos pelo banco de dados. Como o identificador da linha no banco ou a hora em que o registro foi criado.</p> <p>Para isso, precisamos adicionar mais informa\u00e7\u00f5es ao modelo.</p>"},{"location":"04/#configuracoes-de-colunas","title":"Configura\u00e7\u00f5es de colunas","text":"<p>Quando definimos tabelas no banco de dados, as colunas podem apresentar propriedades espec\u00edficas. Por exemplo:</p> <ul> <li>Um valor que n\u00e3o deve se repetir em outros registros (<code>unique</code>)</li> <li>Valores padr\u00f5es para quando n\u00e3o forem passados (<code>default</code>)</li> <li>Identificadores para os registros (<code>primary_key</code>)</li> </ul> <p>Para esses casos, o SQLAlchemy conta com a fun\u00e7\u00e3o <code>mapped_column</code>. Dentro dela, voc\u00ea pode definir diversas propriedades.</p> <p>Para o nosso caso, gostaria que <code>email</code> e <code>username</code> n\u00e3o se repetissem na base de dados e que as colunas <code>id</code> e <code>created_at</code> tivessem o valor definido pelo pr\u00f3prio banco de dados, quando o registro fosse criado.</p> <p>Para isso, vamos aplicar alguns par\u00e2metros nas colunas usando <code>mapped_column</code>:</p> fast_zero/models.py<pre><code>from datetime import datetime\n\nfrom sqlalchemy import func\nfrom sqlalchemy.orm import Mapped, mapped_as_dataclass, mapped_column, registry\n\ntable_registry = registry()\n\n\n@mapped_as_dataclass(table_registry)\nclass User:\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(init=False, primary_key=True)#(1)!\n    username: Mapped[str] = mapped_column(unique=True)#(2)!\n    password: Mapped[str]\n    email: Mapped[str] = mapped_column(unique=True)\n    created_at: Mapped[datetime] = mapped_column(#(3)!\n        init=False, server_default=func.now()\n    )\n</code></pre> <ol> <li><code>init=False</code> diz que, quando o objeto for instanciado, esse par\u00e2metro n\u00e3o deve ser passado. <code>primary_key=True</code> diz que o campo <code>id</code> \u00e9 a chave prim\u00e1ria dessa tabela.</li> <li><code>unique=True</code> diz que esse campo n\u00e3o deve se repetir na tabela. Por exemplo, se tivermos um username \"dunossauro\", n\u00e3o podemos ter outro com o mesmo valor.</li> <li><code>server_default=func.now()</code> diz que, quando a classe for instanciada, o resultado de <code>func.now()</code> ser\u00e1 o valor atribu\u00eddo a esse atributo. No caso, a data e hora em que ele foi instanciado.</li> </ol> <p>Desta forma, unimos tanto o uso que queremos ter no python, quanto a configura\u00e7\u00e3o esperada da tabela no banco de dados. Os par\u00e2metros de mapeamento dizem:</p> <ul> <li><code>primary_key</code>: diz que o campo ser\u00e1 a chave prim\u00e1ria da tabela</li> <li><code>unique</code>: diz que o campo s\u00f3 pode ter um valor \u00fanico em toda a tabela. N\u00e3o podemos ter um <code>username</code> repetido no banco, por exemplo.</li> <li><code>server_default</code>: executa uma fun\u00e7\u00e3o no momento em que o objeto for instanciado.</li> </ul> <p>O campo <code>init</code> n\u00e3o tem uma rela\u00e7\u00e3o direta com o banco de dados, mas sim com a forma em que vamos usar o objeto do modelo no c\u00f3digo. Ele diz que os atributos marcados com <code>init=false</code> n\u00e3o devem ser passados no momento em que <code>User</code> for instanciado. Por exemplo:</p> C\u00f3digo de exemplo<pre><code>eduardo = User(\n    username='dunossauro', password='senha123', email='duno@ssauro.com',\n)\n</code></pre> <p>Por n\u00e3o passarmos estes par\u00e2metros para <code>User</code>, o SQLAlchemy se encarregar\u00e1 de atribuir os valores a eles de forma autom\u00e1tica.</p> <p>O campo <code>created_at</code> ser\u00e1 preenchido pelo resultado da fun\u00e7\u00e3o passada em <code>server_default</code>. O campo <code>id</code>, por contar com <code>primary_key=True</code>, ser\u00e1 autopreenchido com o id correspondente quando for armazenado no banco de dados.</p> <p>Existem diversas op\u00e7\u00f5es nessa fun\u00e7\u00e3o. Caso queira ver mais possibilidades de mapeamento, aqui est\u00e1 a referencia para mais campos</p>"},{"location":"04/#testando-as-tabelas","title":"Testando as Tabelas","text":"<p>Antes de prosseguirmos, uma boa pr\u00e1tica seria criar um teste para validar se toda a estrutura do banco de dados funciona. Criaremos um arquivo para validar isso: <code>test_db.py</code>.</p> <p>A partir daqui, voc\u00ea pode prosseguir com a estrutura\u00e7\u00e3o do conte\u00fado desse arquivo para definir os testes necess\u00e1rios para validar o seu modelo de usu\u00e1rio e sua intera\u00e7\u00e3o com o banco de dados.</p>"},{"location":"04/#antes-de-escrever-os-testes","title":"Antes de Escrever os Testes","text":"<p>A essa altura, se estiv\u00e9ssemos buscando apenas cobertura, poder\u00edamos simplesmente testar utilizando o modelo, e isso seria suficiente. No entanto, queremos verificar se toda a nossa intera\u00e7\u00e3o com o banco de dados ocorrer\u00e1 com sucesso. Isso inclui saber se os tipos de dados na tabela foram mapeados corretamente, se \u00e9 poss\u00edvel interagir com o banco de dados, se o ORM est\u00e1 estruturado adequadamente com a classe base. Precisamos garantir que todo esse esquema funcione.</p> <pre><code>graph\n  A[Aplicativo Python] -- utiliza --&gt; B[SQLAlchemy ORM]\n  B -- fornece --&gt; D[Session]\n  D -- eventos --&gt; D\n  D -- interage com --&gt; C[Modelos]\n  C -- eventos --&gt; C\n  C -- mapeados para --&gt; G[Tabelas no Banco de Dados]\n  D -- depende de --&gt; E[Engine]\n  E -- conecta-se com --&gt; F[Banco de Dados]\n  C -- associa-se a --&gt; H[Metadata]\n  H -- mant\u00e9m informa\u00e7\u00f5es de --&gt; G[Tabelas no Banco de Dados]</code></pre> <p>Neste diagrama, vemos a rela\u00e7\u00e3o completa entre o aplicativo Python e o banco de dados. A conex\u00e3o \u00e9 estabelecida atrav\u00e9s do SQLAlchemy ORM, que fornece uma Session para interagir com os Modelos. Esses modelos s\u00e3o mapeados para as tabelas no banco de dados, enquanto a Engine se conecta com o banco de dados e depende de Metadata para manter as informa\u00e7\u00f5es das tabelas.</p> <p>Portanto, criaremos uma fixture para podermos usar todo esse esquema sempre que necess\u00e1rio.</p>"},{"location":"04/#criando-uma-fixture-para-interacoes-com-o-banco-de-dados","title":"Criando uma Fixture para intera\u00e7\u00f5es com o Banco de Dados","text":"<p>Para testar o banco, temos que fazer diversos passos, e isso pode tornar nosso teste bastante grande. Uma fixture pode ajudar a isolar toda essa configura\u00e7\u00e3o do banco de dados fora do teste. Assim, evitamos repetir o mesmo c\u00f3digo em todos os testes e ainda garantimos que cada teste tenha sua pr\u00f3pria vers\u00e3o limpa do banco de dados.</p> <p>Criaremos uma fixture para a conex\u00e3o com o banco de dados chamada <code>session</code>:</p> tests/conftest.py<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.app import app\nfrom fast_zero.models import table_registry\n\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n\n\n@pytest.fixture\ndef session():\n    engine = create_engine('sqlite:///:memory:')#(1)!\n    table_registry.metadata.create_all(engine)#(2)!\n\n    with Session(engine) as session:#(3)!\n        yield session#(4)!\n\n    table_registry.metadata.drop_all(engine)#(5)!\n    engine.dispose()#(6)!\n</code></pre> <p>Aqui, estamos utilizando o SQLite como o banco de dados em mem\u00f3ria para os testes. Essa \u00e9 uma pr\u00e1tica comum em testes unit\u00e1rios, pois a utiliza\u00e7\u00e3o de um banco de dados em mem\u00f3ria \u00e9 mais r\u00e1pida do que um banco de dados persistido em disco. Com o SQLite em mem\u00f3ria, podemos criar e destruir bancos de dados facilmente, o que \u00e9 \u00fatil para isolar os testes e garantir que os dados de um teste n\u00e3o afetem outros testes. Al\u00e9m disso, n\u00e3o precisamos nos preocupar com a limpeza dos dados ap\u00f3s a execu\u00e7\u00e3o dos testes, j\u00e1 que o banco de dados em mem\u00f3ria \u00e9 descartado quando o programa \u00e9 encerrado.</p> <p>O que cada linha da fixture faz?</p> <ol> <li> <p><code>create_engine('sqlite:///:memory:')</code>: cria um mecanismo de banco de dados SQLite em mem\u00f3ria usando SQLAlchemy. Este mecanismo ser\u00e1 usado para criar uma sess\u00e3o de banco de dados para nossos testes.</p> </li> <li> <p><code>table_registry.metadata.create_all(engine)</code>: cria todas as tabelas no banco de dados de teste antes de cada teste que usa a fixture <code>session</code>.</p> </li> <li> <p><code>Session(engine)</code>: cria uma sess\u00e3o <code>Session</code> para que os testes possam se comunicar com o banco de dadosvia <code>engine</code>.</p> </li> <li> <p><code>yield session</code>: fornece uma inst\u00e2ncia de Session que ser\u00e1 injetada em cada teste que solicita a fixture <code>session</code>. Essa sess\u00e3o ser\u00e1 usada para interagir com o banco de dados de teste.</p> </li> <li> <p><code>table_registry.metadata.drop_all(engine)</code>: ap\u00f3s cada teste que usa a fixture <code>session</code>, todas as tabelas do banco de dados de teste s\u00e3o eliminadas, garantindo que cada teste seja executado contra um banco de dados limpo.</p> </li> <li> <p><code>engine.dispose()</code>: fecha todas as conex\u00f5es abertas associadas ao <code>engine</code>, liberando os recursos do sistema. Isso garante que o mecanismo de banco de dados seja completamente encerrado ap\u00f3s o teste, evitando vazamentos de conex\u00e3o e outros problemas relacionados \u00e0 persist\u00eancia de estado entre testes.</p> </li> </ol> <p>Resumindo, essa fixture est\u00e1 configurando e limpando um banco de dados de teste para cada teste que o solicita, assegurando que cada teste seja isolado e tenha seu pr\u00f3prio ambiente limpo para trabalhar. Isso \u00e9 uma boa pr\u00e1tica em testes de unidade, j\u00e1 que queremos que cada teste seja independente e n\u00e3o afete os demais.</p>"},{"location":"04/#criando-um-teste-para-a-nossa-tabela","title":"Criando um Teste para a Nossa Tabela","text":"<p>Agora, no arquivo <code>test_db.py</code>, escreveremos um teste para a cria\u00e7\u00e3o de um usu\u00e1rio. Este teste adiciona um novo usu\u00e1rio ao banco de dados, faz commit das mudan\u00e7as, e depois verifica se o usu\u00e1rio foi devidamente criado consultando-o pelo nome de usu\u00e1rio. Se o usu\u00e1rio foi criado corretamente, o teste passa. Caso contr\u00e1rio, o teste falha, indicando que h\u00e1 algo errado com nossa fun\u00e7\u00e3o de cria\u00e7\u00e3o de usu\u00e1rio.</p> tests/test_db.py<pre><code>from sqlalchemy import select\n\nfrom fast_zero.models import User\n\n\ndef test_create_user(session):\n    new_user = User(username='alice', password='secret', email='teste@test')\n    session.add(new_user)#(1)!\n    session.commit()#(2)!\n\n    user = session.scalar(select(User).where(User.username == 'alice'))#(3)!\n\n    assert user.username == 'alice'\n</code></pre> <ol> <li>O m\u00e9todo <code>.add</code> da sess\u00e3o, adiciona o registro a sess\u00e3o. O dado fica em um estado transiente. Ele n\u00e3o foi adicionado ao banco de dados ainda. Mas j\u00e1 est\u00e1 reservado na sess\u00e3o. Ele \u00e9 uma aplica\u00e7\u00e3o do padr\u00e3o de projeto Unidade de trabalho.</li> <li>No momento em que existem dados transientes na sess\u00e3o e queremos \"performar\" efetivamente as a\u00e7\u00f5es no banco de dados. Usamos o m\u00e9todo <code>.commit</code>.</li> <li>O m\u00e9todo <code>.scalar</code> \u00e9 usado para performar buscas no banco (queries). Ele pega o primeiro resultado da busca e faz uma opera\u00e7\u00e3o de converter o resultado do banco de dados em um Objeto criado pelo SQLAlchemy, nesse caso, caso encontre um resultado, ele ir\u00e1 converter na classe <code>User</code>. A fun\u00e7\u00e3o de <code>select</code> \u00e9 uma fun\u00e7\u00e3o de busca de dados no banco. Nesse caso estamos procurando em todos os <code>Users</code> onde (<code>where</code>) o nome \u00e9 igual a <code>\"alice\"</code>.</li> </ol>"},{"location":"04/#executando-o-teste","title":"Executando o teste","text":"<p>A execu\u00e7\u00e3o de testes \u00e9 uma parte vital do desenvolvimento de qualquer aplica\u00e7\u00e3o. Os testes nos ajudam a identificar e corrigir problemas antes que eles se tornem mais s\u00e9rios. Eles tamb\u00e9m fornecem a confian\u00e7a de que nossas mudan\u00e7as n\u00e3o quebraram nenhuma funcionalidade existente. No nosso caso, executaremos os testes para validar nossos modelos de usu\u00e1rio e garantir que eles estejam funcionando como esperado.</p> <p>Para executar os testes, digite o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <pre><code># ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_db.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           28      2    93%\nfast_zero/models.py        11      0   100%\nfast_zero/schemas.py       15      0   100%\n-------------------------------------------\nTOTAL                      54      2    96%\n</code></pre> <p>Neste caso, podemos ver que todos os nossos testes passaram com sucesso. Isso significa que nossa funcionalidade de cria\u00e7\u00e3o de usu\u00e1rio est\u00e1 funcionando corretamente e que nosso modelo de usu\u00e1rio est\u00e1 sendo corretamente persistido no banco de dados.</p> <p>Embora tudo esteja se encaixando bem, esse teste n\u00e3o \u00e9 muito legal, pois n\u00e3o faz a valida\u00e7\u00e3o do objeto como um todo. Conseguimos garantir que toda a estrutura do banco de dados funciona, por\u00e9m, n\u00e3o conseguimos garantir ainda que todos os valores est\u00e3o corretos.</p>"},{"location":"04/#eventos-do-orm","title":"Eventos do ORM","text":"<p>Embora nossos testes tenham sido executados corretamente, temos um problema se quisermos validar o objeto como um todo, por existirem alguns campos da tabela que fogem do mecanismo da cria\u00e7\u00e3o do objeto <code>(init=False)</code>.</p> <p>Um desses casos \u00e9 o campo <code>created_at</code>. Quando configuramos o modelo, deixamos que o banco de dados defina seu hor\u00e1rio e data atual para preencher esse campo. Ser\u00e1 que existe uma forma de alterar esse comportamento durante os testes? Pra podermos validar quando o objeto foi criado? A resposta \u00e9 sim.</p> <p>O SQLAlchemy tem um sistema de eventos. Eventos s\u00e3o blocos de c\u00f3digo que podem ser inseridos ou removidos antes e depois de uma opera\u00e7\u00e3o.</p> <pre><code>flowchart TD\n   subgraph Opera\u00e7\u00e3o\n     direction LR\n     A[Hook] --&gt; B[Opera\u00e7\u00e3o]\n     B --&gt; C[Hook]\n   end</code></pre> <p>Isso nos permite modificar os dados antes ou depois de determinadas opera\u00e7\u00f5es serem executadas pelo SQLAlchemy.</p> <p>Por exemplo, nosso modelo de <code>User</code> n\u00e3o permite que sejam enviados os campos <code>id</code> e <code>created_at</code> no momento em que a inst\u00e2ncia de <code>User</code> \u00e9 criada. Por conta da restri\u00e7\u00e3o <code>init=False</code> no <code>mapped_column</code>.</p> <p>Ao escrever testes, essa restri\u00e7\u00e3o pode nos trazer algumas dificuldades no momento das valida\u00e7\u00f5es (asserts). Ent\u00e3o vamos programar um evento para acontecer antes que o dado seja inserido no banco de dados.</p> <pre><code>flowchart TD\n   commit --&gt; Z[\"Inserir registro no banco (opera\u00e7\u00e3o)\"]\n   subgraph Z[\"Inserir registro no banco (opera\u00e7\u00e3o)\"]\n     direction LR\n     A[Hook - before_insert] --&gt; B[insert]\n   end</code></pre> <p>Um hook \u00e9 basicamente uma fun\u00e7\u00e3o python que registramos como um evento no sqlalchemy. Nesse caso, como queremos um evento de insert, devemos fornecer o modelo que queremos que seja atrelado ao evento:</p> C\u00f3digo de exemplo<pre><code>from sqlalchemy import event\n\n\ndef hook(mapper, connection, target): #(1)!\n   ...\n\n\nevent.listen(User, 'before_insert', hook)  #(2)!\n</code></pre> <ol> <li>Qualquer fun\u00e7\u00e3o que for usada como um hook do evento de <code>before_insert</code> tem que receber os par\u00e2metros <code>mapper</code>, <code>connextion</code> e <code>target</code>, mesmo que n\u00e3o os use.</li> <li>Nesse exemplo o evento \"ouvir\u00e1\" [listen] o modelo <code>User</code> e toda vez que o ORM for inserir um registro desse modelo no banco (<code>before_insert</code>) ele executar\u00e1 a fun\u00e7\u00e3o <code>hook</code>.</li> </ol> <p>A ideia por tr\u00e1s dos eventos \u00e9 simplesmente passar algum modelo ou a sess\u00e3o para que o ORM observe todas \u00e0s vezes em que uma determinada opera\u00e7\u00e3o foi executada e se ela tem algum hook sendo \"ouvido\" para aquela opera\u00e7\u00e3o. Falando de forma clara, todas \u00e0s vezes que <code>User</code> for inserido na base, antes disso a fun\u00e7\u00e3o <code>hook</code> ser\u00e1 executada.</p> <p>Voc\u00ea pode buscar por outros eventos de mapeamento na Documenta\u00e7\u00e3o do SQLAlchemy</p>"},{"location":"04/#evento-para-manipular-o-tempo","title":"Evento para manipular o tempo","text":"<p>Para fazer a valida\u00e7\u00e3o de todos os campos do objeto durante os testes, podemos criar um evento que ser\u00e1 executado durante o teste que fa\u00e7a que com os registros inseridos nesse teste tenham o hor\u00e1rio manipulado, facilitando a compara\u00e7\u00e3o com um <code>created_at</code> fixo:</p> tests/conftest.py<pre><code>from contextlib import contextmanager\nfrom datetime import datetime\n\n# ...\nfrom sqlalchemy import create_engine, event\n\n# ...\n\n@contextmanager #(1)!\ndef _mock_db_time(*, model, time=datetime(2024, 1, 1)): #(2)!\n\n    def fake_time_hook(mapper, connection, target): #(3)!\n        if hasattr(target, 'created_at'):\n            target.created_at = time\n\n    event.listen(model, 'before_insert', fake_time_hook) #(4)!\n\n    yield time #(5)!\n\n    event.remove(model, 'before_insert', fake_time_hook) #(6)!\n</code></pre> <ol> <li>O decorador <code>@contextmanager</code> cria um gerenciador de contexto para que a fun\u00e7\u00e3o <code>_mock_db_time</code> seja usada com um bloco <code>with</code>. Caso voc\u00ea n\u00e3o tenha experi\u00eancia com gerenciadores de contexto, voc\u00ea pode assistir a essa Live.</li> <li>Todos os par\u00e2metros ap\u00f3s <code>*</code> devem ser chamados de forma nomeada, para ficarem expl\u00edcitos na fun\u00e7\u00e3o. Ou seja <code>mock_db_time(model=User)</code>. Os par\u00e2metros n\u00e3o podem ser chamados de forma posicional <code>_mock_db_time(User)</code>, isso acarretar\u00e1 em um erro.</li> <li>Fun\u00e7\u00e3o para alterar alterar o m\u00e9todo <code>created_at</code> do objeto de target.</li> <li><code>event.listen</code> adiciona um evento rela\u00e7\u00e3o a um <code>model</code> que ser\u00e1 passado a fun\u00e7\u00e3o. Esse evento \u00e9 o <code>before_insert</code>, ele executar\u00e1 uma fun\u00e7\u00e3o (hook) antes de inserir o registro no banco de dados. O hook \u00e9 a fun\u00e7\u00e3o <code>fake_time_hook</code>.</li> <li>Retorna o datetime na abertura do gerenciamento de contexto.</li> <li>Ap\u00f3s o final do gerenciamento de contexto o hook dos eventos \u00e9 removido.</li> </ol> <p>A ideia por tr\u00e1s dessa fun\u00e7\u00e3o \u00e9 ser um gerenciador de contexto (para ser chamado em um bloco <code>with</code>). Toda vezes que um registro de <code>model</code> for inserido no banco de dados, se ele tiver o campo <code>created_at</code>, por padr\u00e3o, o campo ser\u00e1 cadastrado com a sua data pr\u00e9-fixada '01/01/2024'. Facilitando a manuten\u00e7\u00e3o dos testes que precisam da compara\u00e7\u00e3o de data, pois ser\u00e1 determin\u00edstica.</p>"},{"location":"04/#transformando-o-evento-em-uma-fixture","title":"Transformando o evento em uma fixture","text":"<p>Agora que temos a fun\u00e7\u00e3o gerenciadora de contexto, para evitar o sistema de importa\u00e7\u00e3o durante os testes, podemos criar uma fixture para ele. De forma bem simples, somente retornando a fun\u00e7\u00e3o <code>_mock_db_time</code>:</p> tests/conftest.py<pre><code>@pytest.fixture\ndef mock_db_time():\n    return _mock_db_time\n</code></pre> <p>Dessa forma podemos fazer a chamada direta no teste.</p>"},{"location":"04/#adicionando-o-evento-ao-teste","title":"Adicionando o evento ao teste","text":"<p>Agora que temos uma fixture para tratar o caso da data de cria\u00e7\u00e3o, podemos fazer a compara\u00e7\u00e3o do objeto completo:</p> tests/test_db.py<pre><code>from dataclasses import asdict\n\nfrom sqlalchemy import select\n\nfrom fast_zero.models import User\n\n\ndef test_create_user(session, mock_db_time):\n    with mock_db_time(model=User) as time: #(1)!\n        new_user = User(\n            username='alice', password='secret', email='teste@test'\n        )\n        session.add(new_user)\n        session.commit()\n\n    user = session.scalar(select(User).where(User.username == 'alice'))\n\n    assert asdict(user) == { #(2)!\n        'id': 1,\n        'username': 'alice',\n        'password': 'secret',\n        'email': 'teste@test',\n        'created_at': time,  #(3)!\n    }\n</code></pre> <ol> <li>Inicia o gerenciador de contexto <code>mock_db_time</code> usando o modelo <code>User</code> como base.</li> <li>Converte o <code>user</code> em um dicion\u00e1rio para simplificar a valida\u00e7\u00e3o no teste.</li> <li>Usa o time gerado por <code>mock_db_time</code> para validar o campo <code>created_at</code>.</li> </ol> <p>O teste permanece praticamente igual, com a diferen\u00e7a de que todas as opera\u00e7\u00f5es envolvendo a cria\u00e7\u00e3o de <code>User</code> no banco de dados acontecem no escopo de <code>mock_db_time</code>.</p> <p>Isso faz com que durante o <code>commit</code>, quando os objetos s\u00e3o persistidos da sess\u00e3o para o banco de dados, o evento de <code>before_insert</code> seja executado para cada objeto do modelo passado em <code>mock_db_time(model=*MODEL*)</code>.</p> <p>Por conta do campo <code>created_at</code> agora ser determin\u00edstico podemos fazer uma compara\u00e7\u00e3o completa dos campos.</p> <p>Para simplificar a compara\u00e7\u00e3o de todos os campos, como nossos objetos de modelo s\u00e3o dataclasses, a fun\u00e7\u00e3o <code>dataclass.asdict()</code>, converte uma dataclass para um dicion\u00e1rio:</p> Estudando a compara\u00e7\u00e3o<pre><code>    assert asdict(user) == {\n        'id': 1,\n        'username': 'alice',\n        'password': 'secret',\n        'email': 'teste@test',\n        'created_at': time,\n    }\n</code></pre> <p>Como o tempo agora \u00e9 determin\u00edstico e contido no nosso gerenciador de contexto, podemos fazer a compara\u00e7\u00e3o exata entre todos os campos. Inclusive <code>created_at</code>.</p> <p>Desta forma, com nossos modelos e testes de banco de dados em ordem, estamos prontos para avan\u00e7ar para a pr\u00f3xima fase de configura\u00e7\u00e3o de nosso banco de dados e gerenciamento de migra\u00e7\u00f5es.</p>"},{"location":"04/#configuracao-do-ambiente-do-banco-de-dados","title":"Configura\u00e7\u00e3o do ambiente do banco de dados","text":"<p>Por fim, configuraremos nosso banco de dados. Primeiro, criaremos um novo arquivo chamado <code>settings.py</code> dentro do diret\u00f3rio <code>fast_zero</code>. Aqui, usaremos o Pydantic para criar uma classe <code>Settings</code> que ir\u00e1 pegar as configura\u00e7\u00f5es do nosso arquivo <code>.env</code>. Neste arquivo, a classe <code>Settings</code> \u00e9 definida como:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict( #(1)!\n        env_file='.env', env_file_encoding='utf-8'#(2)!\n    )\n\n    DATABASE_URL: str#(3)!\n</code></pre> <ol> <li><code>SettingsConfigDict</code>: \u00e9 um objeto do pydantic-settings que carrega as vari\u00e1veis em um arquivo de configura\u00e7\u00e3o. Por exemplo, um <code>.env</code>.</li> <li>Aqui definimos o caminho para o arquivo de configura\u00e7\u00e3o e o encoding dele.</li> <li><code>DATABASE_URL</code>: Essa vari\u00e1vel sera preenchida com o valor encontrado com o mesmo nome no arquivo <code>.env</code>.</li> </ol> <p>Agora, definiremos o <code>DATABASE_URL</code> no nosso arquivo de ambiente <code>.env</code>. Crie o arquivo na raiz do projeto e adicione a seguinte linha:</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\n</code></pre> <p>Com isso, quando a classe <code>Settings</code> for instanciada, ela ir\u00e1 automaticamente carregar as configura\u00e7\u00f5es do arquivo <code>.env</code>.</p> <p>Finalmente, adicione o arquivo de banco de dados, <code>database.db</code>, ao <code>.gitignore</code> para garantir que n\u00e3o seja inclu\u00eddo no controle de vers\u00e3o. Adicionar informa\u00e7\u00f5es sens\u00edveis ou arquivos bin\u00e1rios ao controle de vers\u00e3o \u00e9 geralmente considerado uma pr\u00e1tica ruim.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>echo 'database.db' &gt;&gt; .gitignore\n</code></pre>"},{"location":"04/#instalando-o-alembic-e-criando-a-primeira-migracao","title":"Instalando o Alembic e Criando a Primeira Migra\u00e7\u00e3o","text":"<p>Antes de avan\u00e7armos, \u00e9 importante entender o que s\u00e3o migra\u00e7\u00f5es de banco de dados e por que s\u00e3o \u00fateis. As migra\u00e7\u00f5es s\u00e3o uma maneira de fazer altera\u00e7\u00f5es ou atualiza\u00e7\u00f5es no banco de dados, como adicionar uma tabela ou uma coluna a uma tabela, ou alterar o tipo de dados de uma coluna. Elas s\u00e3o extremamente \u00fateis, pois nos permitem manter o controle de todas as altera\u00e7\u00f5es feitas no esquema do banco de dados ao longo do tempo. Elas tamb\u00e9m nos permitem reverter para uma vers\u00e3o anterior do esquema do banco de dados, se necess\u00e1rio.</p> Caso nunca tenha trabalhado com Migra\u00e7\u00f5es <p>Temos uma live de Python focada nesse assunto em espec\u00edfico</p> <p></p> <p> Link direto</p> <p>Agora, come\u00e7aremos instalando o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usaremos o Poetry para adicionar o Alembic ao nosso projeto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add alembic\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o do Alembic, precisamos inici\u00e1-lo em nosso projeto. O comando de inicializa\u00e7\u00e3o criar\u00e1 um diret\u00f3rio <code>migrations</code> e um arquivo de configura\u00e7\u00e3o <code>alembic.ini</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic init migrations\n</code></pre> <p>Com isso, a estrutura do nosso projeto sofre algumas altera\u00e7\u00f5es e novos arquivos s\u00e3o criados:</p> <pre><code>.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 __init__.py\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u251c\u2500\u2500 schemas.py\n\u2502  \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 migrations\n\u2502  \u251c\u2500\u2500 env.py\n\u2502  \u251c\u2500\u2500 README\n\u2502  \u251c\u2500\u2500 script.py.mako\n\u2502  \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u251c\u2500\u2500 __init__.py\n   \u251c\u2500\u2500 conftest.py\n   \u251c\u2500\u2500 test_app.py\n   \u2514\u2500\u2500 test_db.py\n</code></pre> <p>No arquivo <code>alembic.ini</code>: ficam as configura\u00e7\u00f5es gerais das nossas migra\u00e7\u00f5es. Na pasta <code>migrations</code> foram criados dois arquivos, um chamado <code>env.py</code> que \u00e9 respons\u00e1vel por como as migra\u00e7\u00f5es ser\u00e3o feitas, e o outro chamado <code>script.py.mako</code> que \u00e9 um template para as novas migra\u00e7\u00f5es.</p>"},{"location":"04/#criando-uma-migracao-automatica","title":"Criando uma migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Com o Alembic devidamente instalado e iniciado, agora \u00e9 o momento de gerar nossa primeira migra\u00e7\u00e3o. Mas, antes disso, precisamos garantir que o Alembic consiga acessar nossas configura\u00e7\u00f5es e modelos corretamente. Para isso, faremos algumas altera\u00e7\u00f5es no arquivo <code>migrations/env.py</code>.</p> <p>Neste arquivo, precisamos:</p> <ol> <li>Importar as <code>Settings</code> do nosso arquivo <code>settings.py</code> e a <code>table_registry</code> dos nossos modelos.</li> <li>Configurar a URL do SQLAlchemy para ser a mesma que definimos em <code>Settings</code>.</li> <li>Verificar a exist\u00eancia do arquivo de configura\u00e7\u00e3o do Alembic e, se presente, l\u00ea-lo.</li> <li>Definir os metadados de destino como <code>table_registry.metadata</code>, que \u00e9 o que o Alembic utilizar\u00e1 para gerar automaticamente as migra\u00e7\u00f5es.</li> </ol> <p>O arquivo <code>migrations/env.py</code> modificado ficar\u00e1 assim:</p> migrations/env.py<pre><code>from logging.config import fileConfig\n\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\nfrom fast_zero.models import table_registry\nfrom fast_zero.settings import Settings\n\nconfig = context.config\nconfig.set_main_option('sqlalchemy.url', Settings().DATABASE_URL)\n\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\ntarget_metadata = table_registry.metadata\n\n# other values from the config, defined by the needs of env.py,\n# ...\n</code></pre> <p>Feitas essas altera\u00e7\u00f5es, estamos prontos para gerar nossa primeira migra\u00e7\u00e3o autom\u00e1tica. O Alembic \u00e9 capaz de gerar migra\u00e7\u00f5es a partir das mudan\u00e7as detectadas nos nossos modelos do SQLAlchemy.</p> <p>Para criar a migra\u00e7\u00e3o, utilizamos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create users table\"\n</code></pre> <p>Este comando instrui o Alembic a criar uma nova revis\u00e3o de migra\u00e7\u00e3o no diret\u00f3rio <code>migrations/versions</code>. A revis\u00e3o gerada conter\u00e1 os comandos SQL necess\u00e1rios para aplicar a migra\u00e7\u00e3o (criar a tabela de usu\u00e1rios) e para reverter essa migra\u00e7\u00e3o, caso seja necess\u00e1rio.</p>"},{"location":"04/#analisando-a-migracao-automatica","title":"Analisando a migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Ao criar uma migra\u00e7\u00e3o autom\u00e1tica com o Alembic, um arquivo \u00e9 gerado dentro da pasta <code>migrations/versions</code>. O nome deste arquivo come\u00e7a com um ID de revis\u00e3o (um hash \u00fanico gerado pelo Alembic), seguido por uma breve descri\u00e7\u00e3o que fornecemos no momento da cria\u00e7\u00e3o da migra\u00e7\u00e3o, neste caso, <code>create_users_table</code>.</p> <p>Vamos analisar o arquivo de migra\u00e7\u00e3o:</p> migrations/versions/e018397cecf4_create_users_table.py<pre><code>\"\"\"create users table\n\nRevision ID: e018397cecf4\nRevises:\nCreate Date: 2023-07-13 03:43:03.730534\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'e018397cecf4'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('username', sa.String(), nullable=False),\n    sa.Column('password', sa.String(), nullable=False),\n    sa.Column('email', sa.String(), nullable=False),\n    sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('email'),\n    sa.UniqueConstraint('username')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('users')\n    # ### end Alembic commands ###\n</code></pre> <p>Esse arquivo descreve as mudan\u00e7as a serem feitas no banco de dados. Ele usa a linguagem core do SQLAlchemy, que \u00e9 mais baixo n\u00edvel que o ORM. As fun\u00e7\u00f5es <code>upgrade</code> e <code>downgrade</code> definem, respectivamente, o que fazer para aplicar e para desfazer a migra\u00e7\u00e3o. No nosso caso, a fun\u00e7\u00e3o <code>upgrade</code> cria a tabela 'users' com os campos que definimos em <code>fast_zero/models.py</code>e a fun\u00e7\u00e3o <code>downgrade</code> a remove.</p>"},{"location":"04/#analisando-o-banco-de-dados","title":"Analisando o banco de dados","text":"<p>Ao criar a migra\u00e7\u00e3o, o Alembic teve que observar se j\u00e1 existiam migra\u00e7\u00f5es anteriores no banco de dados. Como o banco de dados n\u00e3o existia, ele criou um novo banco sqlite com o nome que definimos na vari\u00e1vel de ambiente <code>DATABASE_URL</code>. No caso <code>database.db</code>.</p> <p>Se olharmos a estrutura de pastas, esse arquivo agora existe:</p> <pre><code>.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 database.db\n\u251c\u2500\u2500 fast_zero\n\u2502  \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 migrations\n\u2502  \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u2514\u2500\u2500 ...\n</code></pre> <p>Pelo fato do sqlite3 ser um banco baseado em um \u00fanico arquivo, no momento das migra\u00e7\u00f5es, o sqlalchemy faz a cria\u00e7\u00e3o do arquivo de banco de dados caso ele n\u00e3o exista.</p> <p>No momento da verifica\u00e7\u00e3o, caso n\u00e3o exista a tabela de migra\u00e7\u00f5es, ela ser\u00e1 criada. A tabela de migra\u00e7\u00f5es \u00e9 nomeada como <code>alembic_version</code>.</p> <p>Vamos acessar o console do sqlite e verificar se isso foi feito. Precisamos chamar <code>sqlite3 nome_do_arquivo.db</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n</code></pre> Caso n\u00e3o tenha o SQLite instalado na sua m\u00e1quina: Arch<pre><code>pacman -S sqlite\n</code></pre> Debian/Ubuntu<pre><code>sudo apt install sqlite3\n</code></pre> Mac<pre><code>brew install sqlite\n</code></pre> Windows<pre><code>winget install --id SQLite.SQLite\n</code></pre> <p>Quando executamos esse comando, o console do sqlite ser\u00e1 inicializado. E dentro dele podemos executar alguns comandos. Como fazer consultas, ver as tabelas criadas, adicionar dados, etc.</p> <p>A cara do console \u00e9 essa: </p><pre><code>SQLite version 3.45.1 2024-01-30 16:01:20\nEnter \".help\" for usage hints.\nsqlite&gt;\n</code></pre><p></p> <p>Aqui voc\u00ea pode digitar comandos, da mesma forma em que fazemos no terminal interativo do python. O comando <code>.schema</code> nos mostra todas as tabelas criadas no banco de dados:</p> <pre><code>sqlite&gt; .schema\nCREATE TABLE alembic_version (\n    version_num VARCHAR(32) NOT NULL,\n    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\n</code></pre> <p>Nisso vemos que o Alembic criou uma tabela chamada <code>alembic_version</code> no banco de dados. Nessa tabela temos um \u00fanico campo chamado <code>version_num</code> que \u00e9 o campo que marca a vers\u00e3o atual da migra\u00e7\u00e3o no banco.</p> <p>Para ver a vers\u00e3o atual do banco, podemos executar uma busca no campo e ver o resultado:</p> <pre><code>sqlite&gt; select version_num from alembic_version;\n</code></pre> <p>O resultado deve ser vazio, pois n\u00e3o aplicamos nenhuma migra\u00e7\u00e3o, ele somente criou a tabela de migra\u00e7\u00f5es.</p> <p>Para sair do console do sqlite temos que digitar o comando <code>.quit</code>:</p> <pre><code>sqlite&gt; .quit\n</code></pre> <p>Agora que temos o terminal de volta, podemos aplicar as migra\u00e7\u00f5es.</p>"},{"location":"04/#aplicando-a-migracao","title":"Aplicando a migra\u00e7\u00e3o","text":"<p>Para aplicar as migra\u00e7\u00f5es, usamos o comando <code>upgrade</code> do CLI Alembic. O argumento <code>head</code> indica que queremos aplicar todas as migra\u00e7\u00f5es que ainda n\u00e3o foram aplicadas:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\n</code></pre> <p>Teremos a seguinte resposta:</p> <pre><code>INFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\n</code></pre> <p>Vemos na \u00faltima linha executada a migra\u00e7\u00e3o de c\u00f3digo <code>e018397cecf4</code>, com o nome <code>create users table</code>.</p> <p>Agora, se examinarmos nosso banco de dados novamente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n</code></pre> <p>Podemos verificar se a tabela <code>users</code> foi criada no schema do banco:</p> <pre><code>sqlite&gt; .schema\nCREATE TABLE alembic_version (\n    version_num VARCHAR(32) NOT NULL,\n    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nCREATE TABLE users (\n        id INTEGER NOT NULL,\n        username VARCHAR NOT NULL,\n        password VARCHAR NOT NULL,\n        email VARCHAR NOT NULL,\n        created_at DATETIME DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n        PRIMARY KEY (id),\n        UNIQUE (email),\n        UNIQUE (username)\n);\n</code></pre> <p>Se examinarmos os dados da tabela <code>alembic_version</code> podemos ver que o n\u00famero da migra\u00e7\u00e3o \u00e9 referente ao valor criado no arquivo de migra\u00e7\u00e3o <code>e018397cecf4_create_users_table.py</code></p> <pre><code>sqlite&gt; select version_num from alembic_version;\ne018397cecf4\nsqlite&gt; .quit\n</code></pre> <p>Com isso, finalizamos a cria\u00e7\u00e3o do banco de dados. Lembre-se de que todas essas mudan\u00e7as que fizemos s\u00f3 existem localmente no seu ambiente de trabalho at\u00e9 agora. Para serem compartilhadas com outras pessoas, precisamos fazer commit dessas mudan\u00e7as no nosso sistema de controle de vers\u00e3o.</p>"},{"location":"04/#commit","title":"Commit","text":"<p>Primeiro, verificaremos o status do nosso reposit\u00f3rio para ver as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Voc\u00ea ver\u00e1 uma lista de arquivos modificados ou adicionados. As altera\u00e7\u00f5es devem incluir os arquivos de migra\u00e7\u00e3o que criamos, bem como quaisquer altera\u00e7\u00f5es que fizemos em nossos arquivos de modelo e configura\u00e7\u00e3o.</p> <p>Em seguida, adicionaremos todas as mudan\u00e7as ao pr\u00f3ximo commit:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit das nossas altera\u00e7\u00f5es. Escreveremos uma mensagem de commit que descreve as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Adicionada a primeira migra\u00e7\u00e3o com Alembic. Criada tabela de usu\u00e1rios.\"\n</code></pre> <p>Finalmente, enviaremos as mudan\u00e7as para o reposit\u00f3rio remoto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As mudan\u00e7as que fizemos foram salvas no hist\u00f3rico do Git e agora est\u00e3o dispon\u00edveis no GitHub.</p>"},{"location":"04/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Fazer uma altera\u00e7\u00e3o no modelo (tabela <code>User</code>) e adicionar um campo chamado <code>updated_at</code>:<ul> <li>Esse campo deve ser mapeado para o tipo <code>datetime</code></li> <li>Esse campo n\u00e3o deve ser inicializado por padr\u00e3o <code>init=False</code></li> <li>O valor padr\u00e3o deve ser <code>now</code></li> <li>Toda vez que a tabela for atualizada esse campo deve ser atualizado:     <pre><code>mapped_column(onupdate=func.now())\n</code></pre></li> </ul> </li> <li>Altere o evento de testes (<code>mock_db_time</code>) para ser contemplado no mock o campo <code>updated_at</code> na valida\u00e7\u00e3o do teste.</li> <li>Criar uma nova migra\u00e7\u00e3o autogerada com alembic</li> <li>Aplicar essa migra\u00e7\u00e3o ao banco de dados</li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"04/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos passos significativos para preparar nosso projeto FastAPI para interagir com um banco de dados. Come\u00e7amos definindo nosso primeiro modelo de dados, o <code>User</code>, utilizando o SQLAlchemy. Al\u00e9m disso, conforme as pr\u00e1ticas de Desenvolvimento Orientado por Testes (TDD), implementamos um teste para assegurar que a funcionalidade de cria\u00e7\u00e3o de um novo usu\u00e1rio no banco de dados esteja operando corretamente.</p> <p>Avan\u00e7amos para configurar o ambiente de desenvolvimento, onde estabelecemos um arquivo <code>.env</code> para armazenar nossa <code>DATABASE_URL</code> e ajustamos o SQLAlchemy para utilizar essa URL. Complementarmente, inclu\u00edmos o arquivo do banco de dados ao <code>.gitignore</code> para evitar que seja rastreado pelo controle de vers\u00e3o.</p> <p>Na \u00faltima parte desta aula, focamos na instala\u00e7\u00e3o e configura\u00e7\u00e3o do Alembic, uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usando o Alembic, criamos nossa primeira migra\u00e7\u00e3o que, automaticamente, gera o esquema do banco de dados a partir dos nossos modelos SQLAlchemy.</p> <p>Com esses passos, nosso projeto est\u00e1 bem encaminhado para come\u00e7ar a persistir dados. Na pr\u00f3xima aula, avan\u00e7aremos para a fase crucial de conectar o SQLAlchemy aos endpoints do nosso projeto. Isso permitir\u00e1 a realiza\u00e7\u00e3o de opera\u00e7\u00f5es de CRUD nos nossos usu\u00e1rios diretamente atrav\u00e9s da API.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"05/","title":"Integrando banco de dados \u00e0 API","text":""},{"location":"05/#integrando-banco-de-dados-a-api","title":"Integrando banco de dados \u00e0 API","text":"<p>Objetivos dessa aula:</p> <ul> <li>Integrando SQLAlchemy \u00e0 nossa aplica\u00e7\u00e3o FastAPI</li> <li>Utilizando a fun\u00e7\u00e3o Depends para gerenciar depend\u00eancias</li> <li>Modificando endpoints para interagir com o banco de dados</li> <li>Testando os novos endpoints com Pytest e fixtures</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Ap\u00f3s termos estabelecido nossos modelos e migra\u00e7\u00f5es na aula anterior, \u00e9 hora de darmos um passo significativo: a integra\u00e7\u00e3o do banco de dados real com a nossa aplica\u00e7\u00e3o FastAPI. Deixaremos para tr\u00e1s o banco de dados simulado que utilizamos at\u00e9 ent\u00e3o e nos dedicaremos \u00e0 implementa\u00e7\u00e3o de um banco de dados real e plenamente operacional. Al\u00e9m disso, adaptaremos a estrutura dos nossos testes para que eles sejam compat\u00edveis com o banco de dados, incluindo a cria\u00e7\u00e3o de novas fixtures.</p>"},{"location":"05/#integrando-sqlalchemy-a-nossa-aplicacao-fastapi","title":"Integrando SQLAlchemy \u00e0 Nossa Aplica\u00e7\u00e3o FastAPI","text":"<p>Para aqueles que n\u00e3o est\u00e3o familiarizados, o SQLAlchemy \u00e9 uma biblioteca Python que facilita a intera\u00e7\u00e3o com um banco de dados SQL. Ele faz isso oferecendo uma forma de trabalhar com bancos de dados que aproveita a facilidade e o poder do Python, ao mesmo tempo, em que mant\u00e9m a efici\u00eancia e a flexibilidade dos bancos de dados SQL.</p> Caso nunca tenha trabalhado com SQLAlchemy <p>Recomendo fortemente que voc\u00ea assista a essa live de python onde os conceitos principais do sqlalchemy s\u00e3o expostos em uma discuss\u00e3o divertida.</p> <p></p> <p> Link direto</p> <p>Uma pe\u00e7a chave do SQLAlchemy \u00e9 o conceito de uma \"sess\u00e3o\". Se voc\u00ea \u00e9 novo no mundo dos bancos de dados, pode pensar na sess\u00e3o como um carrinho de compras virtual: conforme voc\u00ea navega pelo site (ou, neste caso, conforme seu c\u00f3digo executa), voc\u00ea pode adicionar ou remover itens desse carrinho. No entanto, nenhuma altera\u00e7\u00e3o \u00e9 realmente feita at\u00e9 que voc\u00ea decida finalizar a compra. No contexto do SQLAlchemy, \"finalizar a compra\" \u00e9 equivalente a fazer o commit das suas altera\u00e7\u00f5es.</p> <p>A sess\u00e3o no SQLAlchemy \u00e9 t\u00e3o poderosa que, na verdade, incorpora tr\u00eas padr\u00f5es de arquitetura importantes.</p> <ol> <li> <p>Mapa de Identidade: Imagine que voc\u00ea esteja comprando frutas em uma loja online. Cada fruta que voc\u00ea adiciona ao seu carrinho recebe um c\u00f3digo de barras \u00fanico, para a loja saber exatamente qual fruta voc\u00ea quer. O Mapa de Identidade no SQLAlchemy \u00e9 esse sistema de c\u00f3digo de barras: ele garante que cada objeto na sess\u00e3o seja \u00fanico e facilmente identific\u00e1vel.</p> </li> <li> <p>Reposit\u00f3rio: A sess\u00e3o tamb\u00e9m atua como um reposit\u00f3rio. Isso significa que ela \u00e9 como um porteiro: ela controla todas as comunica\u00e7\u00f5es entre o seu c\u00f3digo Python e o banco de dados. Todos os comandos que voc\u00ea deseja enviar para o banco de dados devem passar pela sess\u00e3o.</p> </li> <li> <p>Unidade de Trabalho: Finalmente, a sess\u00e3o age como uma unidade de trabalho. Isso significa que ela mant\u00e9m o controle de todas as altera\u00e7\u00f5es que voc\u00ea quer fazer no banco de dados. Se voc\u00ea adicionar uma fruta ao seu carrinho e depois mudar de ideia e remover, a sess\u00e3o lembrar\u00e1 de ambas as a\u00e7\u00f5es. Ent\u00e3o, quando voc\u00ea finalmente decidir finalizar a compra, ela enviar\u00e1 todas as suas altera\u00e7\u00f5es para o banco de dados de uma s\u00f3 vez.</p> </li> </ol> <p>Entender esses conceitos \u00e9 importante, pois nos ajuda a entender melhor como o SQLAlchemy funciona e como podemos us\u00e1-lo de forma mais eficaz. Agora que temos uma ideia do que \u00e9 uma sess\u00e3o, configuraremos uma para nosso projeto.</p> <p>Para isso, criaremos a fun\u00e7\u00e3o <code>get_session</code> e tamb\u00e9m definiremos <code>Session</code> no arquivo <code>database.py</code>:</p> fast_zero/database.py<pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.settings import Settings\n\nengine = create_engine(Settings().DATABASE_URL)\n\n\ndef get_session():#(1)!\n    with Session(engine) as session:\n        yield session\n</code></pre> <ol> <li>Quando os testes forem executados, essa linha nunca ser\u00e1 coberta. Pois os testes substituir\u00e3o esse bloco por uma fixture em tempo de execu\u00e7\u00e3o aqui. Uma forma de fugir disso e explicar ao coverage que esse bloco n\u00e3o dever\u00e1 ser considerado na cobertura \u00e9 adicionar o coment\u00e1rio <code># pragma: no cover</code>. Isso far\u00e1 ele ignorar esse bloco na contagem.</li> </ol>"},{"location":"05/#gerenciando-dependencias-com-fastapi","title":"Gerenciando Depend\u00eancias com FastAPI","text":"<p>Assim como a sess\u00e3o SQLAlchemy, que implementa v\u00e1rios padr\u00f5es arquiteturais importantes, FastAPI tamb\u00e9m usa um conceito de padr\u00e3o arquitetural chamado \"Inje\u00e7\u00e3o de Depend\u00eancia\".</p> <p>No mundo do desenvolvimento de software, uma \"depend\u00eancia\" \u00e9 um componente que um m\u00f3dulo de software precisa para realizar sua fun\u00e7\u00e3o. Imagine um m\u00f3dulo como uma f\u00e1brica e as depend\u00eancias como as partes ou mat\u00e9rias-primas que a f\u00e1brica precisa para produzir seus produtos. Em vez de a f\u00e1brica ter que buscar essas pe\u00e7as por conta pr\u00f3pria (o que seria ineficiente), elas s\u00e3o entregues \u00e0 f\u00e1brica, prontas para serem usadas. Este \u00e9 o conceito de Inje\u00e7\u00e3o de Depend\u00eancia.</p> <p>A Inje\u00e7\u00e3o de Depend\u00eancia permite que mantenhamos um baixo n\u00edvel de acoplamento entre diferentes m\u00f3dulos de um sistema. As depend\u00eancias entre os m\u00f3dulos n\u00e3o s\u00e3o definidas no c\u00f3digo, mas sim pela configura\u00e7\u00e3o de uma infraestrutura de software (container) respons\u00e1vel por \"injetar\" em cada componente suas depend\u00eancias declaradas.</p> <p>Em termos pr\u00e1ticos, o que isso significa \u00e9 que, em vez de cada parte do nosso c\u00f3digo ter que criar suas pr\u00f3prias inst\u00e2ncias de classes ou servi\u00e7os de que depende (o que pode levar a duplica\u00e7\u00e3o de c\u00f3digo e tornar os testes mais dif\u00edceis), essas inst\u00e2ncias s\u00e3o criadas uma vez e depois injetadas onde s\u00e3o necess\u00e1rias.</p> <p>FastAPI fornece a fun\u00e7\u00e3o <code>Depends</code> para ajudar a declarar e gerenciar essas depend\u00eancias. \u00c9 uma maneira declarativa de dizer ao FastAPI: \"Antes de executar esta fun\u00e7\u00e3o, execute primeiro essa outra fun\u00e7\u00e3o e passe-me o resultado\". Isso \u00e9 especialmente \u00fatil quando temos opera\u00e7\u00f5es que precisam ser realizadas antes de cada request, como abrir uma sess\u00e3o de banco de dados.</p>"},{"location":"05/#modificando-o-endpoint-post-users","title":"Modificando o Endpoint POST /users","text":"<p>Agora que temos a nossa sess\u00e3o de banco de dados gerenciada por meio do FastAPI e da inje\u00e7\u00e3o de depend\u00eancias, atualizaremos nossos endpoints para poderem tirar proveito disso. Come\u00e7aremos com a rota de POST para a cria\u00e7\u00e3o de usu\u00e1rios. Ao inv\u00e9s de usarmos o banco de dados falso que criamos inicialmente, agora faremos a inser\u00e7\u00e3o real dos usu\u00e1rios no nosso banco de dados.</p> <p>Para isso, vamos modificar o nosso endpoint da seguinte maneira:</p> fast_zero/app.py<pre><code>from http import HTTPStatus\n\nfrom fastapi import Depends, FastAPI, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserDB, UserList, UserPublic, UserSchema\n\n# ...\n\n\n@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):#(1)!\n    db_user = session.scalar(\n        select(User).where(\n            (User.username == user.username) | (User.email == user.email)#(2)!\n        )\n    )\n\n    if db_user:\n        if db_user.username == user.username:#(3)!\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Username already exists',\n            )\n        elif db_user.email == user.email:\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Email already exists',\n            )\n\n    db_user = User(\n        username=user.username, password=user.password, email=user.email\n    )\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n</code></pre> <ol> <li><code>session: Session = Depends(get_session)</code> diz que a fun\u00e7\u00e3o <code>get_session</code> ser\u00e1 executada antes da execu\u00e7\u00e3o da fun\u00e7\u00e3o e o valor retornado por <code>get_session</code> ser\u00e1 atribu\u00eddo ao par\u00e2metro <code>session</code>.</li> <li>Faz uma busca por <code>User</code> onde (<code>where</code>) o username \u00e9 igual ao que veio no request, ou (<code>|</code>) o email \u00e9 igual ao que veio no request. A busca tem o objetivo de achar um registro que tenha ou o email ou o username cadastrado. Pois, eles s\u00e3o \u00fanicos na base de dados. Precisamos validar para ver se j\u00e1 n\u00e3o constam na base de dados.</li> <li>Por conta do ou (<code>|</code>), precisamos validar o que \u00e9 que j\u00e1 existe na base. Se \u00e9 o username ou se \u00e9 o email</li> </ol> <p>Vamos analisar esse c\u00f3digo com um pouco de calma, diversas coisas est\u00e3o acontecendo aqui, ent\u00e3o, vamos ter um pouco mais de cuidado em um \"bloco a bloco\":</p> <ul> <li>A defini\u00e7\u00e3o da fun\u00e7\u00e3o: a fun\u00e7\u00e3o <code>create_user</code> recebe um objeto do tipo <code>UserSchema</code> e uma sess\u00e3o SQLAlchemy, que \u00e9 injetada automaticamente pelo FastAPI usando o <code>Depends</code>. A fun\u00e7\u00e3o <code>Depends</code> executa a fun\u00e7\u00e3o <code>get_session</code> e o valor retornado pelo <code>yield</code> \u00e9 atribu\u00eddo ao par\u00e2metro <code>session</code>:       <pre><code>@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\n</code></pre></li> <li>Busca na base de dados: o primeiro passo da requisi\u00e7\u00e3o \u00e9 a verifica\u00e7\u00e3o dos campos que definimos como <code>unique</code> no modelo Users. Ent\u00e3o, faremos uma busca pelos dois campos que definimos como \u00fanicos. <code>email</code> e <code>username</code>. Para ver se algum deles j\u00e1 foi registrado na base anteriormente:       <pre><code>db_user = session.scalar(\n    select(User).where(\n        (User.username == user.username) | (User.email == user.email)\n    )\n)\n</code></pre></li> <li>Valida\u00e7\u00e3o existencial de registro: a fun\u00e7\u00e3o <code>scalar</code> pode retornar um objeto ou <code>None</code>. Ent\u00e3o fazemos uma valida\u00e7\u00e3o para ver se o registro foi encontrado. Caso ele seja encontrado fazemos duas valida\u00e7\u00f5es. Se o <code>username</code> ou o <code>email</code> j\u00e1 existir na base, ele levanta um <code>raise</code>. Um erro \u00e9 retornado para avisar que ou o campo <code>email</code>, ou campo <code>username</code> j\u00e1 constam no banco de dados.       <pre><code>if db_user:\n    if db_user.username == user.username:\n        raise HTTPException(\n            status_code=HTTPStatus.CONFLICT,\n            detail='Username already exists',\n        )\n    elif db_user.email == user.email:\n        raise HTTPException(\n            status_code=HTTPStatus.CONFLICT,\n            detail='Email already exists',\n        )\n</code></pre></li> <li> <p>Inser\u00e7\u00e3o do registro na base: por fim, caso nenhum dos campos \u00fanicos j\u00e1 exista na base dados, o registro \u00e9 inserido no banco.       </p><pre><code>db_user = User(\n    username=user.username, password=user.password, email=user.email\n)#(1)!\nsession.add(db_user)#(2)!\nsession.commit()#(3)!\nsession.refresh(db_user)#(4)!\n</code></pre><p></p> <ol> <li>Cria um objeto <code>User</code> usando os valores recebidos na requisi\u00e7\u00e3o.</li> <li>Adiciona o objeto na sess\u00e3o.</li> <li>Persiste os dados no banco de dados.</li> <li>Faz uma atualiza\u00e7\u00e3o do objeto <code>db_user</code> com os campos que foram preenchidos pelo banco de dados. Como o <code>id</code>, que \u00e9 uma chave prim\u00e1ria auto incremental do banco de dados.</li> </ol> </li> </ul> <p>Ao final disso, temos uma integra\u00e7\u00e3o entre o m\u00e9todo POST da API e uma inser\u00e7\u00e3o no banco de dados.</p>"},{"location":"05/#testando-o-endpoint-post-users-com-pytest-e-fixtures","title":"Testando o Endpoint POST /users com Pytest e Fixtures","text":"<p>Agora que nossa rota de POST est\u00e1 funcionando com o banco de dados real, precisamos atualizar nossos testes para refletir essa mudan\u00e7a. Como estamos usando a inje\u00e7\u00e3o de depend\u00eancias, precisamos tamb\u00e9m usar essa funcionalidade nos nossos testes para podermos injetar a sess\u00e3o de banco de dados de teste.</p> <p>Alteraremos a nossa fixture <code>client</code> para substituir a fun\u00e7\u00e3o <code>get_session</code> que estamos injetando no endpoint pela sess\u00e3o do banco em mem\u00f3ria que j\u00e1 t\u00ednhamos definido para banco de dados.</p> tests/conftest.py<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.app import app\nfrom fast_zero.database import get_session\nfrom fast_zero.models import table_registry\n\n\n@pytest.fixture\ndef client(session):\n    def get_session_override():#(1)!\n        return session\n\n    with TestClient(app) as client:\n        app.dependency_overrides[get_session] = get_session_override#(2)!\n        yield client\n\n    app.dependency_overrides.clear()#(3)!\n\n# ...\n</code></pre> <ol> <li>Criamos uma fun\u00e7\u00e3o para retornar nossa fixture de <code>session</code> definida anteriormente.</li> <li>Substitui a fun\u00e7\u00e3o <code>get_session</code> que usamos para a aplica\u00e7\u00e3o real, pela nossa fun\u00e7\u00e3o que retorna a fixture de testes.</li> <li>Limpa a sobrescrita que fizemos no app para usar a fixture de <code>session</code>.</li> </ol> <p>Com isso, quando o FastAPI tentar injetar a sess\u00e3o em nossos endpoints, ele injetar\u00e1 a sess\u00e3o de teste que definimos, em vez da sess\u00e3o real. E como estamos usando um banco de dados em mem\u00f3ria para os testes, nossos testes n\u00e3o v\u00e3o interferir nos dados reais do nosso aplicativo.</p> tests/test_app.py<pre><code>def test_create_user(client):\n    response = client.post(\n        '/users',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CREATED\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Agora que temos a nossa fixture configurada, atualizaremos o nosso teste <code>test_create_user</code> para usar o novo cliente de teste e verificar que o usu\u00e1rio est\u00e1 sendo realmente criado no banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user FAILED\n</code></pre> <p>O nosso teste ainda n\u00e3o consegue ser executado, mas existe um motivo para isso.</p>"},{"location":"05/#threads-e-conexoes","title":"Threads e conex\u00f5es","text":"<p>No ambiente de testes do FastAPI, a aplica\u00e7\u00e3o e os testes podem rodar em threads diferentes. Isso pode levar a um erro com o SQLite, pois os objetos SQLite criados em uma thread s\u00f3 podem ser usados na mesma thread.</p> <p>Para contornar isso, adicionaremos os seguintes par\u00e2metros na cria\u00e7\u00e3o da <code>engine</code>:</p> <ol> <li> <p><code>connect_args={'check_same_thread': False}</code>: essa configura\u00e7\u00e3o desativa a verifica\u00e7\u00e3o de que o objeto SQLite est\u00e1 sendo usado na mesma thread em que foi criado. Isso permite que a conex\u00e3o seja compartilhada entre threads diferentes sem levar a erros.</p> </li> <li> <p><code>poolclass=StaticPool</code>: esse par\u00e2metro faz com que a engine use um pool de conex\u00f5es est\u00e1tico, ou seja, reutilize a mesma conex\u00e3o para todas as solicita\u00e7\u00f5es. Isso garante que as duas threads usem o mesmo canal de comunica\u00e7\u00e3o, evitando erros relacionados ao uso de diferentes conex\u00f5es em threads diferentes.</p> </li> </ol> <p>Assim, nossa fixture deve ficar dessa forma:</p> tests/conftest.py<pre><code>from sqlalchemy.pool import StaticPool\n\n# ...\n\n@pytest.fixture\ndef session():\n    engine = create_engine(\n        'sqlite:///:memory:',\n        connect_args={'check_same_thread': False},\n        poolclass=StaticPool,\n    )\n    table_registry.metadata.create_all(engine)\n\n    with Session(engine) as session:\n        yield session\n\n    table_registry.metadata.drop_all(engine)\n    engine.dispose()\n</code></pre> <p>Depois de realizar essas mudan\u00e7as, podemos executar nossos testes e verificar se est\u00e3o passando. Por\u00e9m, embora o teste <code>test_create_user</code> tenha passado, precisamos agora ajustar os outros endpoints para que eles tamb\u00e9m utilizem a nossa sess\u00e3o de banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users FAILED\ntests/test_app.py::test_update_user FAILED\n\n# ...\n</code></pre> <p>Nos pr\u00f3ximos passos, vamos realizar essas modifica\u00e7\u00f5es para garantir que todo o nosso aplicativo esteja usando o banco de dados real.</p>"},{"location":"05/#modificando-o-endpoint-get-users","title":"Modificando o Endpoint GET /users","text":"<p>Agora que temos o nosso banco de dados configurado e funcionando, \u00e9 o momento de atualizar o nosso endpoint de GET para interagir com o banco de dados real. Em vez de trabalhar com uma lista fict\u00edcia de usu\u00e1rios, queremos buscar os usu\u00e1rios diretamente do nosso banco de dados, permitindo uma intera\u00e7\u00e3o din\u00e2mica e real com os dados.</p> fast_zero/app.py<pre><code>@app.get('/users/', response_model=UserList)\ndef read_users(\n    skip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\n    users = session.scalars(select(User).offset(skip).limit(limit)).all()\n    return {'users': users}\n</code></pre> <p>Neste c\u00f3digo, adicionamos algumas funcionalidades essenciais para a busca de dados. Os par\u00e2metros <code>offset</code> e <code>limit</code> s\u00e3o utilizados para paginar os resultados, o que \u00e9 especialmente \u00fatil quando se tem um grande volume de dados. </p> <ul> <li><code>offset</code> permite pular um n\u00famero espec\u00edfico de registros antes de come\u00e7ar a buscar, o que \u00e9 \u00fatil para implementar a navega\u00e7\u00e3o por p\u00e1ginas.</li> <li><code>limit</code> define o n\u00famero m\u00e1ximo de registros a serem retornados, permitindo que voc\u00ea controle a quantidade de dados enviados em cada resposta.</li> </ul> <p>Os par\u00e2metros sendo passados na fun\u00e7\u00e3o, como <code>skip</code> e <code>limit</code>, se tornam par\u00e2metros de query. Se olharmos no swagger. Podemos ver que isso agora \u00e9 parametriz\u00e1vel durante a chamada:</p> <p></p> <p>Isso faz com que as chamadas para o endpoint possa ser realizadas desta forma: <code>http://localhost:8000/users/?skip=0&amp;limit=100</code>. Passando <code>skip=0</code> ou <code>limit=100</code>. Esses valores podem mudar a quantidade e os registros que ser\u00e3o retornados pelo banco de dados. Por padr\u00e3o ser\u00e3o retornados <code>100</code> registros iniciando no <code>0</code>.</p> <p>Recomendo que voc\u00ea insira diversos valores no banco de dados e teste a varia\u00e7\u00e3o dos par\u00e2metros. Pode ser bastante divertido.</p> <p>Essas adi\u00e7\u00f5es tornam o nosso endpoint mais flex\u00edvel e otimizado para lidar com diferentes cen\u00e1rios de uso.</p>"},{"location":"05/#testando-o-endpoint-get-users","title":"Testando o Endpoint GET /users","text":"<p>Com a mudan\u00e7a para o banco de dados real, nosso banco de dados de teste ser\u00e1 sempre resetado para cada teste. Portanto, n\u00e3o podemos mais executar o teste que t\u00ednhamos antes, pois n\u00e3o haver\u00e1 usu\u00e1rios no banco. Para verificar se o nosso endpoint est\u00e1 funcionando corretamente, criaremos um novo teste que solicita uma lista de usu\u00e1rios de um banco vazio:</p> tests/test_app.py<pre><code>def test_read_users(client):\n    response = client.get('/users')\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'users': []}\n</code></pre> <p>Agora que temos nosso novo teste, podemos execut\u00e1-lo para verificar se o nosso endpoint GET est\u00e1 funcionando corretamente. Com esse novo teste, a fun\u00e7\u00e3o <code>test_read_users</code> deve passar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Por\u00e9m, \u00e9 claro, queremos tamb\u00e9m testar o caso em que existem usu\u00e1rios no banco. Para isso, criaremos uma nova fixture que cria um usu\u00e1rio em nosso banco de dados de teste.</p>"},{"location":"05/#criando-uma-fixture-para-user","title":"Criando uma fixture para User","text":"<p>Para criar essa fixture, aproveitaremos a nossa fixture de sess\u00e3o do SQLAlchemy, e criaremos um novo usu\u00e1rio a partir dela:</p> tests/conftest.py<pre><code>from fast_zero.models import User, table_registry\n\n# ...\n\n@pytest.fixture\ndef user(session):\n    user = User(username='Teste', email='teste@test.com', password='testtest')\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    return user\n</code></pre> <p>Com essa fixture, sempre que precisarmos de um usu\u00e1rio em nossos testes, podemos simplesmente passar <code>user</code> como um argumento para nossos testes, e o Pytest se encarregar\u00e1 de criar um novo usu\u00e1rio para n\u00f3s.</p> <p>Agora podemos criar um novo teste para verificar se o nosso endpoint est\u00e1 retornando o usu\u00e1rio correto quando existe um usu\u00e1rio no banco:</p> tests/test_app.py<pre><code>from fast_zero.schemas import UserPublic\n\n# ...\n\n\ndef test_read_users_with_users(client, user):\n    user_schema = UserPublic.model_validate(user).model_dump()\n    response = client.get('/users/')\n    assert response.json() == {'users': [user_schema]}\n</code></pre> <p>Agora podemos rodar o nosso teste novamente e verificar se ele est\u00e1 passando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users FAILED\n</code></pre> <p>No entanto, mesmo que nosso c\u00f3digo pare\u00e7a correto, podemos encontrar um problema: o Pydantic n\u00e3o consegue converter diretamente nosso modelo SQLAlchemy para um modelo Pydantic. Resolveremos isso agora.</p>"},{"location":"05/#integrando-o-schema-ao-model","title":"Integrando o Schema ao Model","text":"<p>A integra\u00e7\u00e3o direta do ORM com o nosso esquema Pydantic n\u00e3o \u00e9 imediata e exige algumas modifica\u00e7\u00f5es. O Pydantic, por padr\u00e3o, n\u00e3o sabe como lidar com os modelos do SQLAlchemy, o que nos leva ao erro observado nos testes.</p> <p>A solu\u00e7\u00e3o para esse problema \u00e9 fazer uma altera\u00e7\u00e3o no esquema <code>UserPublic</code> que utilizamos, para que ele possa reconhecer e trabalhar com os modelos do SQLAlchemy. Isso permite a convers\u00e3o direta de objetos do SQLAlchemy em esquemas Pydantic.</p> <p>Para isso, adicionaremos a linha <code>model_config = ConfigDict(from_attributes=True)</code> ao nosso esquema:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, ConfigDict, EmailStr\n\n# ...\n\nclass UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    model_config = ConfigDict(from_attributes=True)\n</code></pre> <p>Dessa forma a convers\u00e3o entre modelos e schemas pode acontecer. Vamos executar os testes para validar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Agora que temos nosso endpoint GET funcionando corretamente e testado, podemos seguir para o endpoint PUT, e continuar com o processo de atualiza\u00e7\u00e3o dos nossos endpoints.</p>"},{"location":"05/#modificando-o-endpoint-put-users","title":"Modificando o Endpoint PUT /users","text":"<p>Agora, modificaremos o endpoint de PUT para suportar o banco de dados, como fizemos com os endpoints POST e GET:</p> fast_zero/app.py<pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int, user: UserSchema, session: Session = Depends(get_session)\n):\n\n    db_user = session.scalar(select(User).where(User.id == user_id))\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    db_user.username = user.username\n    db_user.password = user.password\n    db_user.email = user.email\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n</code></pre> <p>Semelhante ao que fizemos antes, estamos injetando a sess\u00e3o do SQLAlchemy em nosso endpoint e utilizando-a para buscar o usu\u00e1rio a ser atualizado. Se o usu\u00e1rio n\u00e3o for encontrado, retornamos um erro 404.</p> <p>As linhas destacadas mostram que estamos atribuindo novos valores aos atributos <code>username</code>, <code>password</code> e <code>email</code>. Essa opera\u00e7\u00e3o, seguida por um commit, altera os valores existentes no banco. \u00c9 como se a atribui\u00e7\u00e3o nova, fosse uma atualiza\u00e7\u00e3o do dado da tabela.</p> <p>Antes de partirmos para o pr\u00f3ximo passo, ao executar nosso linter, ele ir\u00e1 apontar um erro informando que importamos <code>UserDB</code> mas, nunca o usamos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nfast_zero/app.py:9:40: F401 [*] `fast_zero.schemas.UserDB` imported but unused\nFound 1 error.\n[*] 1 fixable with the `--fix` option.\n--- fast_zero/app.py\n+++ fast_zero/app.py\n@@ -6,7 +6,7 @@\n\n from fast_zero.database import get_session\n from fast_zero.models import User\n-from fast_zero.schemas import Message, UserDB, UserList, UserPublic, UserSchema\n+from fast_zero.schemas import Message, UserList, UserPublic, UserSchema\n\n app = FastAPI()\n\n\nWould fix 1 error.\n</code></pre> <p>Isso ocorre porque a rota PUT era a \u00fanica que estava utilizando UserDB, e agora que modificamos esta rota, podemos remover UserDB dos nossos imports e tamb\u00e9m excluir sua defini\u00e7\u00e3o no arquivo <code>fast_zero/schemas.py</code></p> Sobre o arquivo <code>fast_zero/schemas.py</code> <p>Caso fique em d\u00favida sobre o que remover, seu arquivo <code>fast_zero/schemas.py</code> deve estar parecido com isso, ap\u00f3s a remo\u00e7\u00e3o de <code>UserDB</code>:</p> schemas.py<pre><code>from pydantic import BaseModel, ConfigDict, EmailStr\n\n\nclass Message(BaseModel):\n    message: str\n\n\nclass UserSchema(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n\nclass UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass UserList(BaseModel):\n    users: list[UserPublic]\n</code></pre>"},{"location":"05/#adicionando-o-teste-do-put","title":"Adicionando o teste do PUT","text":"<p>Tamb\u00e9m precisamos alterar o teste para o endpoint de PUT, para que exista um usu\u00e1rio na base para ser alterado:</p> tests/test_app.py<pre><code>def test_update_user(client, user): #(1)!\n    response = client.put(\n        '/users/1',\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n</code></pre> <ol> <li>Adicionaremos a fixture <code>user</code> que j\u00e1 efetua a cria\u00e7\u00e3o de um registro no banco de dados.</li> </ol>"},{"location":"05/#o-caso-do-conflito","title":"O caso do conflito","text":"<p>Embora pare\u00e7a que est\u00e1 tudo certo e o teste esteja sendo executado com sucesso. Existe, por\u00e9m,  um caso que n\u00e3o foi pensado nesse update. Alguns dados no nosso modelo (<code>username</code> e <code>email</code>) est\u00e3o marcados como <code>unique</code> na base de dados. O que pode ocasionar um erro em potencial, caso algu\u00e9m altere esses valores para um valor j\u00e1 existente.</p> <p>Por exemplo, imagine que duas pessoas se cadastraram na nossa aplica\u00e7\u00e3o. Uma com <code>{'username': 'faustino'}</code> e outra com <code>{'username': 'dunossauro'}</code>. At\u00e9 esse momento, n\u00e3o ter\u00edamos nenhum problema.</p> <p>Mas o que aconteceria se \"faustino\" fizesse um update e quisesse se chamar \"dunossauro\"?</p> <p>Vamos iniciar a escrita de um cen\u00e1rio de testes que contemple isso para ficar mais claro:</p> tests/test_app.py<pre><code>def test_update_integrity_error(client, user):\n    # Criando um registro para \"fausto\"\n    client.post( #(1)!\n        '/users',\n        json={\n            'username': 'fausto',\n            'email': 'fausto@example.com',\n            'password': 'secret',\n        },\n    )\n\n    # Alterando o user.username das fixture para fausto\n    response_update = client.put( #(2)!\n        f'/users/{user.id}',\n        json={\n            'username': 'fausto',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n</code></pre> <ol> <li>Criando um user com o <code>username</code> sendo \"fausto\"</li> <li>Alterando o user existente no banco para usar o mesmo username de \"fausto\"</li> </ol> <p>Mesmo sem escrever nenhum <code>assert</code> nesse teste, se executarmos os testes, ele falhar\u00e1:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user FAILED\n\n================================ short test summary info =================================\nFAILED tests/test_app.py::test_update_integrity_error - sqlalchemy.exc.IntegrityError:\n(sqlite3.IntegrityError) UNIQUE constraint failed: users.username\n[SQL: UPDATE users SET username=?, password=?, email=? WHERE users.id = ?]\n[parameters: ('fausto', 'mynewpassword', 'bob@example.com', 1)]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n</code></pre> <p>O erro foi iniciado pelo sqlalchemy. Como podemos constatar na mensagem de erro: <code>sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username.</code></p> <p>Traduzindo de forma literal, ele disse que temos um problema de integridade: <code>falha na restri\u00e7\u00e3o UNIQUE: users.username</code>. Isso acontece, pois temos a restri\u00e7\u00e3o UNIQUE no campo <code>username</code> da tabela <code>users</code>. Quando adicionamos o mesmo nome a um registro que j\u00e1 existia, causamos um erro de integridade.</p> <p>Uma forma de evitar o erro \u00e9 contando com a possibilidade de que ele aconte\u00e7a. Para isso, poder\u00edamos criar um fluxo esperando essa exce\u00e7\u00e3o no endpoint. Algo como:</p> fast_zero/app.py<pre><code>from sqlalchemy.exc import IntegrityError\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int, user: UserSchema, session: Session = Depends(get_session)\n):\n\n    db_user = session.scalar(select(User).where(User.id == user_id))\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    try:\n        db_user.username = user.username\n        db_user.password = user.password\n        db_user.email = user.email\n        session.commit()\n        session.refresh(db_user)\n\n        return db_user\n\n    except IntegrityError: #(1)!\n        raise HTTPException(\n            status_code=HTTPStatus.CONFLICT, #(2)!\n            detail='Username or Email already exists'\n        )\n</code></pre> <ol> <li>Esse erro ser\u00e1 levantado no caso a instru\u00e7\u00e3o de <code>session.commit()</code> n\u00e3o conseguir efetuar a persist\u00eancia.</li> <li>Conflito \u00e9 o status code para <code>409</code>, quando existe um conflito na solicita\u00e7\u00e3o em rela\u00e7\u00e3o ao estado pretendido pela requisi\u00e7\u00e3o.</li> </ol> <p>Agora temos uma valida\u00e7\u00e3o para os conflitos acontecerem por conta dos campos marcados como <code>unique</code>. Toda vez que isso acontecer, a API retornar\u00e1 o c\u00f3digo <code>409</code> com o json <code>{'detail': 'Username or Email already exists'}</code>.</p> <p>Sabendo disso, podemos retornar ao teste e adicionar as instru\u00e7\u00f5es de <code>assert</code> para garantir essas condi\u00e7\u00f5es:</p> tests/test_app.py<pre><code>def test_update_integrity_error(client, user):\n    # ...\n\n    assert response_update.status_code == HTTPStatus.CONFLICT\n    assert response_update.json() == {\n        'detail': 'Username or Email already exists'\n    }\n</code></pre> <p>Executando os testes, tudo deve funcionar corretamente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\n</code></pre>"},{"location":"05/#modificando-o-endpoint-delete-users","title":"Modificando o Endpoint DELETE /users","text":"<p>Em seguida, modificamos o endpoint DELETE da mesma maneira:</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    db_user = session.scalar(select(User).where(User.id == user_id))\n\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    session.delete(db_user)#(1)!\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <ol> <li>O m\u00e9todo <code>delete</code> da session adiciona uma opera\u00e7\u00e3o de dele\u00e7\u00e3o na sess\u00e3o. Na sequ\u00eancia o m\u00e9todo <code>commit</code> tem que ser chamado para que a opera\u00e7\u00e3o seja performada.</li> </ol> <p>Neste caso, estamos novamente usando a sess\u00e3o do SQLAlchemy para encontrar o usu\u00e1rio a ser deletado e, em seguida, exclu\u00edmos esse usu\u00e1rio do banco de dados.</p>"},{"location":"05/#adicionando-testes-para-delete","title":"Adicionando testes para DELETE","text":"<p>Assim como para o endpoint PUT, precisamos alterar o teste para o nosso endpoint DELETE, pois n\u00e3o existe um <code>user</code> na base:</p> tests/test_app.py<pre><code>def test_delete_user(client, user):\n    response = client.delete('/users/1')\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'User deleted'}\n</code></pre>"},{"location":"05/#cobertura-e-testes-nao-feitos","title":"Cobertura e testes n\u00e3o feitos","text":"<p>Com o banco de dados agora em funcionamento, podemos verificar a cobertura de c\u00f3digo do arquivo <code>fast_zero/app.py</code>. Se olharmos para a imagem abaixo, vemos que ainda h\u00e1 alguns casos que n\u00e3o testamos. Por exemplo, o que acontece quando tentamos atualizar ou excluir um usu\u00e1rio que n\u00e3o existe?</p> <p></p> <p>Esses tr\u00eas casos ficam como exerc\u00edcios para quem est\u00e1 acompanhando este curso.</p> <p>Al\u00e9m disso, n\u00e3o devemos esquecer de remover a implementa\u00e7\u00e3o do banco de dados falso <code>database = []</code> que usamos inicialmente e remover tamb\u00e9m as defini\u00e7\u00f5es de <code>TestClient</code> em <code>test_app.py</code>, pois tudo est\u00e1 usando as fixtures agora!</p>"},{"location":"05/#commit","title":"Commit","text":"<p>Agora que terminamos a atualiza\u00e7\u00e3o dos nossos endpoints, faremos o commit das nossas altera\u00e7\u00f5es. O processo \u00e9 o seguinte:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Atualizando endpoints para usar o banco de dados real\"\ngit push\n</code></pre> <p>Com isso, terminamos a atualiza\u00e7\u00e3o dos nossos endpoints para usar o nosso banco de dados real.</p>"},{"location":"05/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Escrever um teste para o endpoint de POST (create_user) que contemple o cen\u00e1rio onde o username j\u00e1 foi registrado. Validando o erro <code>409</code>;</li> <li>Escrever um teste para o endpoint de POST (create_user) que contemple o cen\u00e1rio onde o e-mail j\u00e1 foi registrado. Validando o erro <code>409</code>;</li> <li>Atualizar os testes criados nos exerc\u00edcios 1 e 2 da aula 03 para suportarem o banco de dados;</li> <li>Implementar o banco de dados para o endpoint de listagem por id, criado no exerc\u00edcio 3 da aula 03.</li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"05/#conclusao","title":"Conclus\u00e3o","text":"<p>Parab\u00e9ns por chegar ao final desta aula! Voc\u00ea deu um passo significativo no desenvolvimento de nossa aplica\u00e7\u00e3o, substituindo a implementa\u00e7\u00e3o do banco de dados falso pela integra\u00e7\u00e3o com um banco de dados real usando SQLAlchemy. Tamb\u00e9m vimos como ajustar os nossos testes para considerar essa nova realidade.</p> <p>Nesta aula, abordamos como modificar os endpoints para interagir com o banco de dados real e como utilizar a inje\u00e7\u00e3o de depend\u00eancias do FastAPI para gerenciar nossas sess\u00f5es do SQLAlchemy. Tamb\u00e9m discutimos a import\u00e2ncia dos testes para garantir que nossos endpoints est\u00e3o funcionando corretamente, e como as fixtures do Pytest podem nos auxiliar na prepara\u00e7\u00e3o do ambiente para esses testes.</p> <p>Al\u00e9m disso, nos deparamos com situa\u00e7\u00f5es onde o Pydantic e o SQLAlchemy n\u00e3o interagem perfeitamente bem, e como solucionar esses casos.</p> <p>No final desta aula, voc\u00ea deve estar confort\u00e1vel em integrar um banco de dados real a uma aplica\u00e7\u00e3o FastAPI, saber como escrever testes robustos que levem em considera\u00e7\u00e3o a intera\u00e7\u00e3o com o banco de dados, e estar ciente de poss\u00edveis desafios ao trabalhar com Pydantic e SQLAlchemy juntos.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"06/","title":"Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":""},{"location":"06/#autenticacao-e-autorizacao-com-jwt","title":"Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":"<p>Objetivos da Aula:</p> <ul> <li>Um entendimento b\u00e1sico sobre JWT</li> <li>Implementar autentica\u00e7\u00e3o de usu\u00e1rios com JWT.</li> <li>Adicionar l\u00f3gica de autoriza\u00e7\u00e3o aos endpoints de atualiza\u00e7\u00e3o e dele\u00e7\u00e3o.</li> <li>Utilizar a biblioteca pwdlib para encriptar as senhas dos usu\u00e1rios.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p>"},{"location":"06/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Nesta aula, abordaremos dois aspectos cruciais de qualquer aplica\u00e7\u00e3o web: a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o. At\u00e9 agora, nossos usu\u00e1rios podem criar, ler, atualizar e deletar suas contas, mas qualquer pessoa pode fazer essas a\u00e7\u00f5es. N\u00e3o queremos que qualquer usu\u00e1rio possa deletar ou modificar a conta de outro usu\u00e1rio. Para evitar isso, vamos implementar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o.</p> <p>A autentica\u00e7\u00e3o \u00e9 o processo de verificar quem um usu\u00e1rio \u00e9, enquanto a autoriza\u00e7\u00e3o \u00e9 o processo de verificar o que ele tem permiss\u00e3o para fazer. Usaremos o JSON Web Token (JWT) para implementar a autentica\u00e7\u00e3o, e adicionaremos l\u00f3gica de autoriza\u00e7\u00e3o aos nossos endpoints.</p> <p>Al\u00e9m disso, at\u00e9 agora, estamos armazenando as senhas dos usu\u00e1rios como texto puro no banco de dados, o que \u00e9 uma pr\u00e1tica insegura. Corrigiremos isso utilizando a biblioteca pwdlib para encriptar as senhas.</p>"},{"location":"06/#o-que-e-um-jwt","title":"O que \u00e9 um JWT","text":"<p>O JWT \u00e9 um padr\u00e3o (RFC 7519) que define uma maneira compacta e aut\u00f4noma de transmitir informa\u00e7\u00f5es entre as partes de maneira segura. Essas informa\u00e7\u00f5es s\u00e3o transmitidas como um objeto JSON que \u00e9 digitalmente assinado usando um segredo (com o algoritmo HMAC) ou um par de chaves p\u00fablica/privada usando RSA, ou ECDSA.</p> <p>Um JWT consiste em tr\u00eas partes:</p> <ol> <li> <p>Header: O cabe\u00e7alho do JWT consiste tipicamente em dois componentes: o tipo de token, que \u00e9 JWT neste caso, e o algoritmo de assinatura, como HMAC SHA256 ou RSA. Essas informa\u00e7\u00f5es s\u00e3o codificadas em Base64Url e formam a primeira parte do JWT.</p> <pre><code>{\n   \"alg\": \"HS256\",\n   \"typ\": \"JWT\"\n}\n</code></pre> </li> <li> <p>Payload: O payload de um JWT \u00e9 onde as reivindica\u00e7\u00f5es (em ingl\u00eas claims) s\u00e3o armazenadas. As reivindica\u00e7\u00f5es s\u00e3o informa\u00e7\u00f5es que queremos transmitir e que s\u00e3o relevantes para a intera\u00e7\u00e3o entre o cliente e o servidor. As reivindica\u00e7\u00f5es s\u00e3o codificadas em Base64Url e formam a segunda parte do JWT.</p> <pre><code>{\n  \"sub\": \"teste@test.com\",\n  \"exp\": 1690258153\n}\n</code></pre> </li> <li> <p>Signature: A assinatura \u00e9 utilizada para verificar que o remetente do JWT \u00e9 quem afirma ser e para garantir que a mensagem n\u00e3o foi alterada ao longo do caminho. Para criar a assinatura, voc\u00ea precisa codificar o cabe\u00e7alho, o payload, e um segredo utilizando o algoritmo especificado no cabe\u00e7alho. A assinatura \u00e9 a terceira parte do JWT. Uma assinatura de JWT pode ser criada como se segue:</p> <pre><code>HMACSHA256(\n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n nosso-segredo\n)\n</code></pre> </li> </ol> <p>Essas tr\u00eas partes s\u00e3o separadas por pontos (.) e juntas formam um token JWT.</p> <p>Formando a estrutura: <code>HEADER.PAYLOAD.SIGNATURE</code> que formam um token parecido com</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\n</code></pre> <p>\u00c9 importante ressaltar que, apesar de a informa\u00e7\u00e3o em um JWT estar codificada, ela n\u00e3o est\u00e1 criptografada. Isso significa que qualquer pessoa com acesso ao token pode decodificar e ler as informa\u00e7\u00f5es nele. No entanto, sem o segredo usado para assinar o token, eles n\u00e3o podem alterar as informa\u00e7\u00f5es ou forjar um novo token. Portanto, n\u00e3o devemos incluir informa\u00e7\u00f5es sens\u00edveis ou confidenciais no payload do JWT.</p> <p>Se quisermos ver o header, o payload e a assinatura contidas nesse token podemos acessar o debuger do jwt e checar quais as informa\u00e7\u00f5es que est\u00e3o nesse token:</p> <p></p>"},{"location":"06/#claims","title":"Claims","text":"<p>As Claims do JWT s\u00e3o as informa\u00e7\u00f5es que ser\u00e3o adicionadas ao token via payload. Como:</p> <pre><code>{\n    \"sub\": \"teste@test.com\",\n    \"exp\": 1690258153\n}\n</code></pre> <p>Onde as chaves deste exemplo:</p> <ul> <li><code>sub</code>: identifica o \"assunto\" (subject), basicamente uma forma de identificar o cliente. Pode ser um id, um uuid, email, ...</li> <li><code>exp</code>: tempo de expira\u00e7\u00e3o do token. O backend vai usar esse dado para validar se o token ainda \u00e9 v\u00e1lido ou existe a necessidade de uma atualiza\u00e7\u00e3o do token.</li> </ul> <p>Em nossos exemplos iremos usar somente essas duas claims, mais existem muitas outras. Voc\u00ea pode ver a lista completa das claims aqui caso queira aprender mais.</p>"},{"location":"06/#como-funciona-o-jwt","title":"Como funciona o JWT","text":"<p>Em uma aplica\u00e7\u00e3o web, o processo de autentica\u00e7\u00e3o geralmente funciona da seguinte maneira:</p> <ol> <li>O usu\u00e1rio envia suas credenciais (e-mail e senha) para o servidor em um endpoint de gera\u00e7\u00e3o de token (<code>/token</code> por exemplo);</li> <li>O servidor verifica as credenciais e, se estiverem corretas, gera um token JWT e o envia de volta ao cliente;</li> <li>Nas solicita\u00e7\u00f5es subsequentes, o cliente deve incluir esse token no cabe\u00e7alho de autoriza\u00e7\u00e3o de suas solicita\u00e7\u00f5es. Como, por exemplo: <code>Authorization: Bearer &lt;token&gt;</code>;</li> <li>Quando o servidor recebe uma solicita\u00e7\u00e3o com um token JWT, ele pode verificar a assinatura e se o token \u00e9 v\u00e1lido e n\u00e3o expirou, ele processa a solicita\u00e7\u00e3o.</li> </ol> <pre><code>sequenceDiagram\n  participant Cliente as Cliente\n  participant Servidor as Servidor\n  Cliente-&gt;&gt;Servidor: Envia credenciais (e-mail e senha)\n  Servidor-&gt;&gt;Cliente: Verifica as credenciais\n  Servidor-&gt;&gt;Cliente: Envia token JWT\n  Cliente-&gt;&gt;Servidor: Envia solicita\u00e7\u00e3o com token JWT no cabe\u00e7alho de autoriza\u00e7\u00e3o\n  Servidor-&gt;&gt;Cliente: Verifica o token JWT e processa a solicita\u00e7\u00e3o</code></pre> <p>Nos pr\u00f3ximos t\u00f3picos, vamos detalhar como podemos gerar e verificar tokens JWT em nossa aplica\u00e7\u00e3o FastAPI, bem como adicionar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o aos nossos endpoints.</p>"},{"location":"06/#gerando-tokens-jwt","title":"Gerando tokens JWT","text":"<p>Para gerar tokens JWT, precisamos de uma nova biblioteca que ainda n\u00e3o temos, a <code>pyjwt</code>. Que ser\u00e1 usada para gerar nossos tokens seguindo as especifica\u00e7\u00f5es necess\u00e1rias na RFC:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add pyjwt\n</code></pre> <p>Agora, criaremos uma fun\u00e7\u00e3o para gerar nossos tokens JWT. Criaremos um novo arquivo para gerenciar a seguran\u00e7a: <code>security.py</code>. Nesse arquivo iniciaremos a gera\u00e7\u00e3o dos tokens:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom zoneinfo import ZoneInfo\n\nfrom jwt import encode\n\nSECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.now(tz=ZoneInfo('UTC')) + timedelta(\n        minutes=ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    to_encode.update({'exp': expire})\n    encoded_jwt = encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n</code></pre> <p>A fun\u00e7\u00e3o <code>create_access_token</code> \u00e9 respons\u00e1vel por criar um novo token JWT que ser\u00e1 usado para autenticar o usu\u00e1rio. Ela recebe um dicion\u00e1rio de dados, adiciona um tempo de expira\u00e7\u00e3o ao token (baseado na constante <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>). Esses dados, em conjunto, formam o payload do JWT. Em seguida, usa a biblioteca <code>pyjwt</code> para codificar essas informa\u00e7\u00f5es em um token JWT, que \u00e9 ent\u00e3o retornado.</p> <p>Note que a constante <code>SECRET_KEY</code> \u00e9 usada para assinar o token, e o algoritmo <code>HS256</code> \u00e9 usado para a codifica\u00e7\u00e3o. Em um cen\u00e1rio de produ\u00e7\u00e3o, voc\u00ea deve manter a <code>SECRET_KEY</code> em um local seguro e n\u00e3o exp\u00f4-la em seu c\u00f3digo.</p>"},{"location":"06/#testando-a-geracao-de-tokens","title":"Testando a gera\u00e7\u00e3o de tokens","text":"<p>Embora a fun\u00e7\u00e3o <code>create_access_token</code> deva ser usada em diferentes contextos do c\u00f3digo, o que criaria uma cobertura para ela, \u00e9 interessante criarmos um teste para essa fun\u00e7\u00e3o com uma finalidade puramente did\u00e1tica. De forma que vejamos os tokens gerados pelo <code>pyjwt</code> e interagirmos com ele.</p> <p>Com isso criaremos um arquivo chamado <code>tests/test_security.py</code> para efetuar esse teste:</p> tests/test_security.py<pre><code>from jwt import decode\n\nfrom fast_zero.security import SECRET_KEY, create_access_token\n\n\ndef test_jwt():\n    data = {'test': 'test'} #(1)!\n    token = create_access_token(data) #(2)!\n\n    decoded = decode(token, SECRET_KEY, algorithms=['HS256']) #(3)!\n\n    assert decoded['test'] == data['test']\n    assert 'exp' in decoded #(4)!\n</code></pre> <ol> <li>Dados que ser\u00e3o assinados pelo token JWT.</li> <li>Cria\u00e7\u00e3o do nosso token JWT. O valor da vari\u00e1vel <code>token</code> nesse momento deve ser algo parecido com isso <code>'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoidGVzdCIsImV4cCI6MTczNjcwMTc4NX0.sFK48Oy6EbjkHgMMm272p-a6eAClKGP1Oo8ISDMNiuo'</code></li> <li>Nessa linha estamos chamando a fun\u00e7\u00e3o <code>decode</code> da pr\u00f3pria biblioteca do jwt e passamos nosso token, o algor\u00edtimo que assinou e a nossa secret key. O resultado da fun\u00e7\u00e3o <code>decode</code> deve ser o valor que passamos para a assinatura <code>{'test': 'test'}</code> adicionado a claim que adicionamos na fun\u00e7\u00e3o <code>create_access_token</code>. Algo como <code>{'test': 'test', 'exp': 1736701785}</code>.</li> <li>Checa somente se existe a claim de exp no token decodado.</li> </ol> <p>Agora podemos executar nosso teste e ver se tudo funciona como o esperado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_security.py::test_jwt PASSED\n</code></pre> Esse teste deu errado? <p>Uma coisa que pode acontecer aqui, por conta de <code>create_access_token</code> usar fun\u00e7\u00f5es de fuso hor\u00e1rio (timezone):</p> <pre><code>def create_access_token(data: dict):\n    # ...\n    expire = datetime.now(tz=ZoneInfo('UTC')) + timedelta(\n        minutes=ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    # ...\n</code></pre> <p>Caso o seu sistema operacional n\u00e3o tenha as propriedades para 'UTC' previamente configuradas, o python n\u00e3o saber\u00e1 lidar com o fuso. Uma forma de passar por isso sem alterar as configura\u00e7\u00f5es do seu sistema operacional \u00e9 instalar a biblioteca tzdata:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add tzdata\n</code></pre> <p>Ap\u00f3s isso, tente executar o teste novamente.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, veremos como podemos usar a biblioteca <code>pwdlib</code> para tratar as senhas dos usu\u00e1rios.</p>"},{"location":"06/#hashing-de-senhas","title":"Hashing de Senhas","text":"<p>Armazenar senhas em texto puro \u00e9 uma pr\u00e1tica de seguran\u00e7a extremamente perigosa. Qualquer pessoa mal intencionada com acesso ao banco poderia ver as credenciais na base de dados. Para evitar isso, uma pr\u00e1tica padr\u00e3o \u00e9 criptografar (\"hash\") as senhas antes de armazen\u00e1-las. Quando um usu\u00e1rio tenta se autenticar, a senha inserida \u00e9 criptografada novamente e comparada com a vers\u00e3o criptografada armazenada no banco de dados. Se as duas correspondem, o usu\u00e1rio \u00e9 autenticado.</p> <p>Implementaremos essa funcionalidade usando a biblioteca <code>pwdlib</code> (password lib), que ainda n\u00e3o temos instalada:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add \"pwdlib[argon2]\" #(1)!\n</code></pre> <ol> <li>Argon2 \u00e9 um algor\u00edtimo de hash bastante seguro e confi\u00e1vel.</li> </ol> <p>Para lidar com a senha de forma segura, criaremos duas fun\u00e7\u00f5es: uma para criar o hash da senha e outra para verificar se uma senha inserida corresponde ao hash armazenado. Adicione o seguinte c\u00f3digo ao arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code># ... outros imports\nfrom jwt import encode\nfrom pwdlib import PasswordHash\n\n#... Outras constantes\nACCESS_TOKEN_EXPIRE_MINUTES = 30\npwd_context = PasswordHash.recommended() #(1)!\n\n# ... outras fun\u00e7\u00f5es\n\ndef get_password_hash(password: str):\n    return pwd_context.hash(password) #(2)!\n\n\ndef verify_password(plain_password: str, hashed_password: str):\n    return pwd_context.verify(plain_password, hashed_password) #(3)!\n</code></pre> <ol> <li>Cria um contexto de hash de senhas com o algor\u00edtimo recomendado pela pwdlib. Por padr\u00e3o \u00e9 argon2.</li> <li>Cria um hash argon2 da senha <code>password</code></li> <li>Verifica se <code>plain_password</code> \u00e9 o mesmo valor de <code>hashed_password</code> quando aplicado ao contexto do argon2.</li> </ol> <p>A fun\u00e7\u00e3o <code>get_password_hash</code> recebe uma senha em texto puro como argumento e retorna uma vers\u00e3o criptografada dessa senha. A fun\u00e7\u00e3o <code>verify_password</code> recebe uma senha em texto puro e uma senha criptografada como argumentos, e verifica se a senha em texto puro, quando criptografada, corresponde \u00e0 senha criptografada. Ambas as fun\u00e7\u00f5es utilizam o objeto <code>pwd_context</code>, que definimos usando a biblioteca <code>pwdlib</code>.</p> <p>Agora, quando um usu\u00e1rio se registra em nossa aplica\u00e7\u00e3o, devemos usar a fun\u00e7\u00e3o <code>get_password_hash</code> para armazenar uma vers\u00e3o criptografada da senha. Quando um usu\u00e1rio tenta se autenticar, devemos usar a fun\u00e7\u00e3o <code>verify_password</code> para verificar se a senha inserida corresponde \u00e0 senha armazenada.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, modificaremos nossos endpoints para fazer uso dessas fun\u00e7\u00f5es.</p>"},{"location":"06/#modificando-o-endpoint-de-post-para-encriptar-a-senha","title":"Modificando o endpoint de POST para encriptar a senha","text":"<p>Com as fun\u00e7\u00f5es de cria\u00e7\u00e3o de hash de senha e verifica\u00e7\u00e3o de senha em vigor, agora podemos atualizar nossos endpoints para usar essa nova funcionalidade de encripta\u00e7\u00e3o.</p> <p>Primeiro, modificaremos a fun\u00e7\u00e3o <code>create_user</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados. Para fazer isso precisamos importar a fun\u00e7\u00e3o de gera\u00e7\u00e3o de hash <code>get_password_hash</code> e no momento da cria\u00e7\u00e3o do registro na tabela a senha deve ser passada com o hash gerado:</p> fast_zero/app.py<pre><code>from fast_zero.security import get_password_hash\n\n# ...\n\n@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\n    db_user = session.scalar(\n        select(User).where(\n            (User.username == user.username) | (User.email == user.email)\n        )\n    )\n\n    if db_user:\n        if db_user.username == user.username:\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Username already exists',\n            )\n        elif db_user.email == user.email:\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Email already exists',\n            )\n\n    hashed_password = get_password_hash(user.password)\n\n    db_user = User(\n        email=user.email,\n        username=user.username,\n        password=hashed_password,\n    )\n\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n</code></pre> <p>Desta forma, a senha n\u00e3o ser\u00e1 mais criada em texto plano no objeto <code>User</code>. Fazendo com que caso exista algum problema relacionado a vazamento de dados, as senhas das pessoas nunca sejam expostas.</p>"},{"location":"06/#sobre-o-teste-da-post-users","title":"Sobre o teste da POST /users/","text":"<p>Por n\u00e3o validar o password, usando o retorno <code>UserPublic</code>, o teste j\u00e1 escrito deve passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n</code></pre>"},{"location":"06/#modificando-o-endpoint-de-atualizacao-de-usuarios","title":"Modificando o endpoint de atualiza\u00e7\u00e3o de usu\u00e1rios","text":"<p>\u00c9 igualmente importante modificar a fun\u00e7\u00e3o <code>update_user</code> para tamb\u00e9m criar um hash da senha antes de atualizar <code>User</code> no banco de dados. Caso contr\u00e1rio, a senha em texto puro seria armazenada no banco de dados no momento da atualiza\u00e7\u00e3o.</p> fast_zero/app.py<pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session = Depends(get_session),\n):\n    db_user = session.scalar(select(User).where(User.id == user_id))\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    try:\n        db_user.username = user.username\n        db_user.password = get_password_hash(user.password)\n        db_user.email = user.email\n        session.commit()\n        session.refresh(db_user)\n\n        return db_user\n    # ...\n</code></pre> <p>Assim, a atualiza\u00e7\u00e3o de um <code>User</code>, via m\u00e9todo <code>PUT</code>, tamb\u00e9m criar\u00e1 o hash da senha no momento da atualiza\u00e7\u00e3o. Pois, nesse caso em espec\u00edfico, existe a possibilidade de alterar qualquer coluna da tabela, inclusive o campo <code>password</code>.</p>"},{"location":"06/#sobre-os-testes-da-put-usersuser_id","title":"Sobre os testes da PUT /users/{user_id}","text":"<p>Assim como no teste da rota de cria\u00e7\u00e3o, os testes tamb\u00e9m passam normalmente por n\u00e3o validarem o campo password.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\n</code></pre>"},{"location":"06/#criando-um-endpoint-de-geracao-do-token","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Antes de criar o endpoint, precisamos criar um schema para o nosso token. Em um contexto JWT, <code>access_token</code> \u00e9 o pr\u00f3prio token que representa a sess\u00e3o do usu\u00e1rio e cont\u00e9m informa\u00e7\u00f5es sobre o usu\u00e1rio, enquanto <code>token_type</code> \u00e9 um tipo de autentica\u00e7\u00e3o que ser\u00e1 inclu\u00eddo no cabe\u00e7alho de autoriza\u00e7\u00e3o de cada solicita\u00e7\u00e3o. Em geral, o <code>token_type</code> para JWT \u00e9 \"bearer\".</p> fast_zero/schemas.py<pre><code>class Token(BaseModel):\n    access_token: str\n    token_type: str\n</code></pre>"},{"location":"06/#criando-um-endpoint-de-geracao-do-token_1","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Agora criaremos o endpoint que ir\u00e1 autenticar o usu\u00e1rio e fornecer um token de acesso JWT. Este endpoint ir\u00e1 receber as informa\u00e7\u00f5es de login do usu\u00e1rio, verificar se as credenciais s\u00e3o v\u00e1lidas e, em caso afirmativo, retornar um token de acesso JWT.</p> fast_zero/app.py<pre><code>from fastapi.security import OAuth2PasswordRequestForm\nfrom fast_zero.schemas import Message, Token, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\n    create_access_token,\n    get_password_hash,\n    verify_password,\n)\n\n# ...\n\n@app.post('/token', response_model=Token)\ndef login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(), #(1)!\n    session: Session = Depends(get_session),\n):\n    user = session.scalar(select(User).where(User.email == form_data.username)) #(2)!\n\n    if not user:\n        raise HTTPException(\n            status_code=HTTPStatus.UNAUTHORIZED,\n            detail='Incorrect email or password'\n        )\n\n    if not verify_password(form_data.password, user.password):\n        raise HTTPException(\n            status_code=HTTPStatus.UNAUTHORIZED,\n            detail='Incorrect email or password'\n        )\n\n    access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <ol> <li>A classe <code>OAuth2PasswordRequestForm</code> \u00e9 uma classe especial do FastAPI que gera automaticamente um formul\u00e1rio para solicitar o username (email neste caso) e a senha. Este formul\u00e1rio ser\u00e1 apresentado automaticamente no Swagger UI e Redoc, facilitando a realiza\u00e7\u00e3o de testes de autentica\u00e7\u00e3o.</li> <li>Aten\u00e7\u00e3o redobrada: conforme a nota anterior, o formul\u00e1rio gerado por <code>OAuth2PasswordRequestForm</code> armazena credendicais do usu\u00e1rio em <code>username</code>. Como usamos email para identifiar o usu\u00e1rio, aqui comparamos <code>username</code> do formul\u00e1rio com o atributo <code>email</code> do modelo <code>User</code>.</li> </ol> <p>Esse endpoint recebe os dados do formul\u00e1rio atrav\u00e9s do <code>form_data</code> (que s\u00e3o injetados automaticamente gra\u00e7as ao <code>Depends()</code>) e tenta recuperar um usu\u00e1rio com o email fornecido. Se o usu\u00e1rio n\u00e3o for encontrado ou a senha n\u00e3o corresponder ao hash armazenado no banco de dados, uma exce\u00e7\u00e3o \u00e9 lan\u00e7ada. Caso contr\u00e1rio, um token de acesso \u00e9 criado usando o <code>create_access_token()</code> que criamos anteriormente e retornado como uma resposta.</p>"},{"location":"06/#testando-token","title":"Testando /token","text":"<p>Agora escreveremos um teste para verificar se o nosso novo endpoint est\u00e1 funcionando corretamente.</p> tests/test_app.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.password},\n    )\n    token = response.json()\n\n    assert response.status_code == HTTPStatus.OK\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>Nesse teste, n\u00f3s enviamos uma requisi\u00e7\u00e3o POST para o endpoint \"/token\" com um username e uma senha v\u00e1lidos. Ent\u00e3o, n\u00f3s verificamos que a resposta cont\u00e9m um \"access_token\" e um \"token_type\", que s\u00e3o os campos que esperamos de um JWT v\u00e1lido.</p> <p>No entanto, h\u00e1 um problema. Agora que a senha est\u00e1 sendo criptografada, nosso teste falhar\u00e1:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para corrigir isso, precisamos garantir que a senha esteja sendo criptografada na fixture antes de ser salva:</p> tests/conftest.py<pre><code>from fast_zero.security import get_password_hash\n\n# ...\n\n@pytest.fixture\ndef user(session):\n    user = User(\n        username='Teste',\n        email='teste@test.com',\n        password=get_password_hash('testtest'),\n    )\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    return user\n</code></pre> <p>Rodaremos o teste novamente. No entanto, ainda teremos um problema. Agora s\u00f3 temos a vers\u00e3o criptografada da senha, que n\u00e3o \u00e9 \u00fatil para fazer o login, j\u00e1 que o login exige a senha em texto puro:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para resolver isso, faremos uma modifica\u00e7\u00e3o no objeto user (um monkey patch) para adicionar a senha em texto puro:</p> tests/conftest.py<pre><code>@pytest.fixture\ndef user(session):\n    password = 'testtest'\n    user = User(\n        username='Teste',\n        email='teste@test.com',\n        password=get_password_hash(password),\n    )\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    user.clean_password = password\n\n    return user\n</code></pre> <p>Monkey patching \u00e9 uma t\u00e9cnica em que modificamos ou estendemos o c\u00f3digo em tempo de execu\u00e7\u00e3o. Neste caso, estamos adicionando um novo atributo <code>clean_password</code> ao objeto user para armazenar a senha em texto puro.</p> <p>Agora, podemos alterar o teste para usar <code>clean_password</code>:</p> tests/test_app.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    token = response.json()\n\n    assert response.status_code == HTTPStatus.OK\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>E agora todos os testes devem passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Isso conclui a parte de autentica\u00e7\u00e3o de nossa API. No pr\u00f3ximo passo, implementaremos a autoriza\u00e7\u00e3o nos endpoints.</p>"},{"location":"06/#protegendo-os-endpoints","title":"Protegendo os Endpoints","text":"<p>Agora que temos uma forma de autenticar nossos usu\u00e1rios e emitir tokens JWT, \u00e9 hora de usar essa infraestrutura para proteger nossos endpoints. </p> <p>Nesse ponto, criaremos uma fun\u00e7\u00e3o <code>get_current_user</code> que ser\u00e1 respons\u00e1vel por extrair o token JWT do header <code>Authorization</code> da requisi\u00e7\u00e3o, decodificar esse token, extrair as informa\u00e7\u00f5es do usu\u00e1rio e obter finalmente o usu\u00e1rio do banco de dados. Se qualquer um desses passos falhar, uma exce\u00e7\u00e3o ser\u00e1 lan\u00e7ada e a requisi\u00e7\u00e3o ser\u00e1 negada. Adicionaremos essa fun\u00e7\u00e3o ao <code>security.py</code>:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom http import HTTPStatus\n\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt import DecodeError, decode, encode\nfrom pwdlib import PasswordHash\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\n\n# ...\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='token')\n\ndef get_current_user(\n    session: Session = Depends(get_session),\n    token: str = Depends(oauth2_scheme), #(1)!\n):\n    credentials_exception = HTTPException(  #(2)!\n        status_code=HTTPStatus.UNAUTHORIZED,\n        detail='Could not validate credentials',\n        headers={'WWW-Authenticate': 'Bearer'},\n    )\n\n    try:\n        payload = decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        subject_email = payload.get('sub')\n\n        if not subject_email:\n            raise credentials_exception  #(3)!\n\n    except DecodeError:\n        raise credentials_exception  #(4)!\n\n    user = session.scalar(\n        select(User).where(User.email == subject_email)\n    )\n\n    if not user:\n        raise credentials_exception  #(5)!\n\n    return user\n</code></pre> <ol> <li>A inje\u00e7\u00e3o de <code>oauth2_scheme</code> garante que um token foi enviado, caso n\u00e3o tenha sido enviado ele redirecionar\u00e1 a <code>tokenUrl</code> do objeto <code>OAuth2PasswordBearer</code>.</li> <li>Como essa opera\u00e7\u00e3o pode apresentar erros em diversos momentos, foi atribu\u00eddo um \u00fanico erro a vari\u00e1vel <code>credentials_exception</code>.</li> <li>Nessa primeira valida\u00e7\u00e3o \u00e9 checado se ap\u00f3s o decode do token <code>email</code> est\u00e1 presente no subject. Caso n\u00e3o esteja, o erro ser\u00e1 levantado.</li> <li>Nessa valida\u00e7\u00e3o \u00e9 testada se o token \u00e9 um token JWT v\u00e1lido. Caso n\u00e3o seja, o erro tamb\u00e9m ser\u00e1 levantado.</li> <li>Nossa \u00faltima valida\u00e7\u00e3o checa, ap\u00f3s garantir que existe <code>email</code>, se ele est\u00e1 presente em nossa base de dados. Caso n\u00e3o, o erro ser\u00e1 levantado.</li> </ol> <p>Aqui, a fun\u00e7\u00e3o <code>get_current_user</code> aceita dois argumentos: <code>session</code> e <code>token</code>. O <code>session</code> \u00e9 obtido atrav\u00e9s da fun\u00e7\u00e3o <code>get_session</code> (n\u00e3o mostrada aqui), que deve retornar uma sess\u00e3o de banco de dados ativa. O <code>token</code> \u00e9 obtido do header de autoriza\u00e7\u00e3o da requisi\u00e7\u00e3o, que \u00e9 esperado ser do tipo Bearer (indicado pelo esquema OAuth2).</p> <p>A vari\u00e1vel <code>credentials_exception</code> \u00e9 definida como uma exce\u00e7\u00e3o HTTP que ser\u00e1 lan\u00e7ada sempre que houver um problema com as credenciais fornecidas pelo usu\u00e1rio. O status 401 indica que a autentica\u00e7\u00e3o falhou e a mensagem \"Could not validate credentials\" \u00e9 retornada ao cliente. Al\u00e9m disso, um cabe\u00e7alho 'WWW-Authenticate' \u00e9 inclu\u00eddo na resposta, indicando que o cliente deve fornecer autentica\u00e7\u00e3o.</p> <p>No bloco <code>try</code>, tentamos decodificar o token JWT usando a chave secreta e o algoritmo especificado. O token decodificado \u00e9 armazenado na vari\u00e1vel <code>payload</code>. Extra\u00edmos o campo 'sub' (normalmente usado para armazenar o identificador do usu\u00e1rio no token JWT) e verificamos se ele existe. Se n\u00e3o, lan\u00e7amos a exce\u00e7\u00e3o <code>credentials_exception</code>.</p> <p>Por fim, realizamos uma consulta ao banco de dados para encontrar o usu\u00e1rio com o e-mail correspondente ao username contido no token. <code>session.scalar</code> \u00e9 usado para retornar a primeira coluna do primeiro resultado da consulta. Se nenhum usu\u00e1rio for encontrado, lan\u00e7amos a exce\u00e7\u00e3o <code>credentials_exception</code>. Se um usu\u00e1rio for encontrado, retornamos esse usu\u00e1rio.</p>"},{"location":"06/#aplicacao-da-protecao-ao-endpoint","title":"Aplica\u00e7\u00e3o da prote\u00e7\u00e3o ao endpoint","text":"<p>Primeiro, aplicaremos a autentica\u00e7\u00e3o no endpoint PUT. Se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 401. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 atualizado normalmente.</p> fast_zero/app.py<pre><code>from fast_zero.security import (\n    create_access_token,\n    get_current_user,\n    get_password_hash,\n    verify_password,\n)\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(\n            status_code=HTTPStatus.FORBIDDEN, detail='Not enough permissions'\n        )\n    try:\n        current_user.username = user.username\n        current_user.password = get_password_hash(user.password)\n        current_user.email = user.email\n        session.commit()\n        session.refresh(current_user)\n\n        return current_user\n    # ...\n</code></pre> <p>Com isso, podemos remover a query feita no endpoint para encontrar o User, pois ela j\u00e1 est\u00e1 sendo feita no <code>get_current_user</code>, simplificando ainda mais nosso endpoint.</p> <p>Agora, aplicaremos a autentica\u00e7\u00e3o no endpoint DELETE. Semelhante ao PUT, se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 401. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 deletado.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(\n    user_id: int,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(\n            status_code=HTTPStatus.FORBIDDEN, detail='Not enough permissions'\n        )\n\n    session.delete(current_user)\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Com essa nova depend\u00eancia, o FastAPI automaticamente garantir\u00e1 que um token de autentica\u00e7\u00e3o v\u00e1lido seja fornecido antes de permitir o acesso a esses endpoints. Se o token n\u00e3o for v\u00e1lido, ou se o usu\u00e1rio tentar modificar ou deletar um usu\u00e1rio diferente, um erro ser\u00e1 retornado.</p>"},{"location":"06/#atualizando-os-testes","title":"Atualizando os Testes","text":"<p>Os testes precisam ser atualizados para refletir essas mudan\u00e7as. Primeiro, precisamos criar uma nova fixture que gere um token para um usu\u00e1rio de teste.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    return response.json()['access_token']\n</code></pre> <p>Agora, podemos atualizar os testes para o endpoint PUT e DELETE para incluir a autentica\u00e7\u00e3o.</p> tests/test_app.py<pre><code>def test_update_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': user.id,\n    }\n\ndef test_update_integrity_error(client, user, token):\n    # ... bloco de c\u00f3digo omitido\n    # Alterando o user das fixture para fausto\n    response_update = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'fausto',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n\n    assert response_update.status_code == HTTPStatus.CONFLICT\n    assert response_update.json() == {\n        'detail': 'Username or Email already exists'\n    }\n\ndef test_delete_user(client, user, token):\n    response = client.delete(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'User deleted'}\n</code></pre> <p>Finalmente, podemos rodar todos os testes para garantir que tudo esteja funcionando corretamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Com essas altera\u00e7\u00f5es, nossos endpoints agora est\u00e3o seguramente protegidos pela autentica\u00e7\u00e3o. Apenas os usu\u00e1rios autenticados podem alterar ou deletar seus pr\u00f3prios dados. Isso traz uma camada adicional de seguran\u00e7a e integridade para o nosso aplicativo.</p>"},{"location":"06/#checagem-de-tokens-invalidos","title":"Checagem de tokens inv\u00e1lidos","text":"<p>Uma coisa que pode ter passado em branco durante a fase de testes \u00e9 a valida\u00e7\u00e3o do token JWT. Ele pode estar em um formato inv\u00e1lido, \u00e0s vezes por erro do cliente, outras por algum problema de seguran\u00e7a. \u00c9 importante validarmos como a aplica\u00e7\u00e3o vai reagir a um token inv\u00e1lido.</p> <p>Durante a constru\u00e7\u00e3o da fun\u00e7\u00e3o <code>get_current_user</code>, criamos um fluxo para esse erro:</p> Parte do c\u00f3digo da fun\u00e7\u00e3o `get_current_user` em security.py<pre><code>credentials_exception = HTTPException(\n    status_code=HTTPStatus.UNAUTHORIZED,\n    detail='Could not validate credentials',\n    headers={'WWW-Authenticate': 'Bearer'},\n)\n\ntry:\n    payload = decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n    # C\u00f3digo para caso o token seja decodificado\nexcept DecodeError:\n    raise credentials_exception\n</code></pre> <p>Caso n\u00e3o seja poss\u00edvel decodificar o token, por algum motivo, \u00e9 importante validarmos se o retorno ser\u00e1 um <code>401 UNAUTHORIZED</code>. Para isso, seria importante criar um teste que verifica essa camada.</p> <p>Poder\u00edamos fazer de duas formas, chamando diretamente a fun\u00e7\u00e3o <code>get_current_user</code> passando um token inv\u00e1lido, ou fazer a valida\u00e7\u00e3o diretamente via a requisi\u00e7\u00e3o de algu\u00e9m que dependa de um token v\u00e1lido. Optarei pela segunda op\u00e7\u00e3o, por ser mais pr\u00f3xima de uma requisi\u00e7\u00e3o real.</p> tests/test_security.py<pre><code>from http import HTTPStatus\n\n# ...\n\ndef test_jwt_invalid_token(client):\n    response = client.delete(\n        '/users/1', headers={'Authorization': 'Bearer token-invalido'}\n    )\n\n    assert response.status_code == HTTPStatus.UNAUTHORIZED\n    assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Usamos um <code>assert</code> para validar se o c\u00f3digo \u00e9 mesmo <code>401</code> e outro para validar nossa mensagem de erro. Assim, temos uma garantia que, caso algu\u00e9m envie um token inv\u00e1lido, a resposta seguir\u00e1 como esperado.</p> <p>Antes de finalizar, o ideal \u00e9 executarmos os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_security.py::test_jwt_invalid_token PASSED\n</code></pre>"},{"location":"06/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li> <p>Fa\u00e7a um teste para cobrir o cen\u00e1rio que levanta exception <code>credentials_exception</code> na autentica\u00e7\u00e3o caso o <code>email</code> n\u00e3o seja enviado via JWT. Ao olhar a cobertura de <code>security.py</code> voc\u00ea vai notar que esse contexto n\u00e3o est\u00e1 coberto.</p> </li> <li> <p>Fa\u00e7a um teste para cobrir o cen\u00e1rio que levanta exception <code>credentials_exception</code> na autentica\u00e7\u00e3o caso o email seja enviado, mas n\u00e3o exista um <code>User</code> correspondente cadastrado na base de dados. Ao olhar a cobertura de <code>security.py</code> voc\u00ea vai notar que esse contexto n\u00e3o est\u00e1 coberto.</p> </li> <li> <p>Reveja os testes criados at\u00e9 a aula 5 e veja se eles ainda fazem sentido (testes envolvendo <code>409</code>)</p> </li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"06/#commit","title":"Commit","text":"<p>Depois de finalizar a prote\u00e7\u00e3o dos endpoints e atualizar os testes, \u00e9 hora de fazer commit das altera\u00e7\u00f5es. N\u00e3o se esque\u00e7a de revisar as altera\u00e7\u00f5es antes de fazer o commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\ngit add .\ngit commit -m \"Protege os endpoints PUT e DELETE com autentica\u00e7\u00e3o\"\n</code></pre>"},{"location":"06/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos um passo importante para aumentar a seguran\u00e7a da nossa API. Implementamos a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o para os endpoints PUT e DELETE, garantindo que apenas usu\u00e1rios autenticados possam alterar ou excluir seus pr\u00f3prios dados. Tamb\u00e9m atualizamos os testes para incluir a autentica\u00e7\u00e3o. Na pr\u00f3xima aula, continuaremos a expandir a funcionalidade da nossa API. At\u00e9 l\u00e1!</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"07/","title":"Refatorando a estrutura do projeto","text":""},{"location":"07/#refatorando-a-estrutura-do-projeto","title":"Refatorando a estrutura do projeto","text":"<p>Objetivos da Aula:</p> <ul> <li>Mover coisas de autentica\u00e7\u00e3o para um arquivo chamado <code>fast_zero/auth.py</code></li> <li>Reestruturar o projeto para facilitar sua manuten\u00e7\u00e3o</li> <li>Deixando em <code>fast_zero/security.py</code> somente as valida\u00e7\u00f5es de senha</li> <li>Remover constantes usados em c\u00f3digo (<code>SECRET_KEY</code>, <code>ALGORITHM</code> e <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>) usando a classe Settings do arquivo <code>fast_zero/settings.py</code> que j\u00e1 temos e movendo para vari\u00e1veis de ambiente no arquivo <code>.env</code></li> <li>Criar routers espec\u00edficos para rotas que tratam das funcionalidades de usu\u00e1rios e para as rotas de autentica\u00e7\u00e3o</li> <li>Cria\u00e7\u00e3o de um modelo pydantic para querys</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz </p> <p>Ao longo da evolu\u00e7\u00e3o de um projeto, \u00e9 natural que sua estrutura inicial necessite de ajustes para manter a legibilidade, a facilidade de manuten\u00e7\u00e3o e a organiza\u00e7\u00e3o do c\u00f3digo. Nesta aula, faremos exatamente isso em nosso projeto FastAPI: refatoraremos partes dele para melhorar sua estrutura e, em seguida, ampliar a cobertura de nossos testes para garantir que todos os cen\u00e1rios poss\u00edveis sejam tratados corretamente. Vamos come\u00e7ar!</p>"},{"location":"07/#criando-routers","title":"Criando Routers","text":"<p>O FastAPI oferece uma ferramenta poderosa conhecida como routers, que facilita a organiza\u00e7\u00e3o e agrupamento de diferentes rotas em uma aplica\u00e7\u00e3o. Pense em um router como um \"subaplicativo\" do FastAPI que pode ser integrado em uma aplica\u00e7\u00e3o principal. Isso n\u00e3o s\u00f3 mant\u00e9m o c\u00f3digo organizado e leg\u00edvel, mas tamb\u00e9m se mostra especialmente \u00fatil \u00e0 medida que a aplica\u00e7\u00e3o se expande e novas rotas s\u00e3o adicionadas.</p> <p>Esse tipo de organiza\u00e7\u00e3o nos oferece diversos benef\u00edcios:</p> <ol> <li>Organiza\u00e7\u00e3o e Legibilidade: Routers ajudam a manter o c\u00f3digo organizado e leg\u00edvel, o que \u00e9 crucial \u00e0 medida que a aplica\u00e7\u00e3o se expande.</li> <li>Separa\u00e7\u00e3o de Preocupa\u00e7\u00f5es: Alinhado ao princ\u00edpio de SoC, os routers facilitam o entendimento e teste do c\u00f3digo.</li> <li>Escalabilidade: A estrutura\u00e7\u00e3o com routers permite adicionar novas rotas e funcionalidades de maneira eficiente conforme o projeto cresce.</li> </ol>"},{"location":"07/#estruturacao-inicial","title":"Estrutura\u00e7\u00e3o Inicial","text":"<p>Criaremos inicialmente uma nova estrutura de diret\u00f3rios chamada <code>routers</code> dentro do seu projeto <code>fast_zero</code>. Aqui, teremos subaplicativos dedicados a fun\u00e7\u00f5es espec\u00edficas, como gerenciamento de usu\u00e1rios e autentica\u00e7\u00e3o.</p> <pre><code>\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 database.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u251c\u2500\u2500 routers\n\u2502  \u2502  \u251c\u2500\u2500 auth.py\n\u2502  \u2502  \u2514\u2500\u2500 users.py\n</code></pre> <p>Esta organiza\u00e7\u00e3o facilita a expans\u00e3o do seu projeto e a manuten\u00e7\u00e3o de uma estrutura clara.</p>"},{"location":"07/#implementando-um-router-para-usuarios","title":"Implementando um Router para Usu\u00e1rios","text":"<p>No arquivo <code>fast_zero/routers/users.py</code>, implementaremos o recurso <code>APIRouter</code> do FastAPI, a ferramenta chave para criar nosso subaplicativo. O par\u00e2metro <code>prefix</code> que passamos ajuda a agrupar todos os endpoints relacionados aos usu\u00e1rios sob um mesmo teto.</p> fast_zero/routers/users.py<pre><code>from fastapi import APIRouter\n\nrouter = APIRouter(prefix='/users', tags=['users'])\n</code></pre> <p>Com essa simples configura\u00e7\u00e3o, estamos prontos para definir rotas espec\u00edficas para usu\u00e1rios neste router, em vez de sobrecarregar o aplicativo principal. Utilizamos <code>@router</code> ao inv\u00e9s de <code>@app</code> para definir estas rotas. O uso da tag 'users' contribui para a organiza\u00e7\u00e3o e documenta\u00e7\u00e3o autom\u00e1tica no swagger.</p> <p>Desta forma podemos migrar todos os nossos imports e nossas fun\u00e7\u00f5es de endpoints para o arquivo <code>fast_zero/routers/users.py</code> e os removendo de <code>fast_zero/app.py</code>. Fazendo com que todos esses endpoints estejam no mesmo contexto e isolados da aplica\u00e7\u00e3o principal:</p> fast_zero/routers/users.py<pre><code>from http import HTTPStatus\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\n    get_current_user,\n    get_password_hash,\n)\n\nrouter = APIRouter(prefix='/users', tags=['users'])\n\n@router.post('/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\n# ...\n@router.get('/', response_model=UserList)\n# ...\n@router.put('/{user_id}', response_model=UserPublic)\n# ...\n@router.delete('/{user_id}', response_model=Message)\n# ...\n</code></pre> <p>Com o prefixo definido no router, os paths dos endpoints se tornam mais simples e diretos. Ao inv\u00e9s de '/users/{user_id}', por exemplo, usamos apenas '/{user_id}'.</p> Exemplo do arquivo <code>fast_zero/routers/users.py</code> completo fast_zero/routers/users.py<pre><code>from http import HTTPStatus\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query\nfrom sqlalchemy import select\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import (\n    FilterPage,\n    Message,\n    UserList,\n    UserPublic,\n    UserSchema,\n)\nfrom fast_zero.security import (\n    get_current_user,\n    get_password_hash,\n)\n\nrouter = APIRouter(prefix='/users', tags=['users'])\nSession = Annotated[Session, Depends(get_session)]\nCurrentUser = Annotated[User, Depends(get_current_user)]\n\n\n@router.post('/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema, session: Session):\n    db_user = session.scalar(\n        select(User).where(\n            (User.username == user.username) | (User.email == user.email)\n        )\n    )\n\n    if db_user:\n        if db_user.username == user.username:\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Username already exists',\n            )\n        elif db_user.email == user.email:\n            raise HTTPException(\n                status_code=HTTPStatus.CONFLICT,\n                detail='Email already exists',\n            )\n\n    hashed_password = get_password_hash(user.password)\n\n    db_user = User(\n        email=user.email,\n        username=user.username,\n        password=hashed_password,\n    )\n\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n\n\n@router.get('/', response_model=UserList)\ndef read_users(session: Session, filter_users: Annotated[FilterPage, Query()]):\n    users = session.scalars(\n        select(User).offset(filter_users.offset).limit(filter_users.limit)\n    ).all()\n\n    return {'users': users}\n\n\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session,\n    current_user: CurrentUser,\n):\n    if current_user.id != user_id:\n        raise HTTPException(\n            status_code=HTTPStatus.FORBIDDEN, detail='Not enough permissions'\n        )\n    try:\n        current_user.username = user.username\n        current_user.password = get_password_hash(user.password)\n        current_user.email = user.email\n        session.commit()\n        session.refresh(current_user)\n\n        return current_user\n\n    except IntegrityError:\n        raise HTTPException(\n            status_code=HTTPStatus.CONFLICT,\n            detail='Username or Email already exists',\n        )\n\n\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(\n    user_id: int,\n    session: Session,\n    current_user: CurrentUser,\n):\n    if current_user.id != user_id:\n        raise HTTPException(\n            status_code=HTTPStatus.FORBIDDEN, detail='Not enough permissions'\n        )\n\n    session.delete(current_user)\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Por termos criados as tags, isso reflete na organiza\u00e7\u00e3o do swagger</p> <p></p>"},{"location":"07/#criando-um-router-para-auth","title":"Criando um router para Auth","text":"<p>No momento, temos rotas para <code>/</code> e <code>/token</code> ainda no arquivo <code>fast_zero/app.py</code>. Daremos um passo adiante e criar um router separado para lidar com a autentica\u00e7\u00e3o. Desta forma, conseguiremos manter nosso arquivo principal (<code>app.py</code>) mais limpo e focado em sua responsabilidade principal que \u00e9 iniciar nossa aplica\u00e7\u00e3o.</p> <p>O router para autentica\u00e7\u00e3o ser\u00e1 criado no arquivo <code>fast_zero/routers/auth.py</code>. Veja como fazer:</p> fast_zero/routers/auth.py<pre><code>from http import HTTPStatus\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Token\nfrom fast_zero.security import create_access_token, verify_password\n\nrouter = APIRouter(prefix='/auth', tags=['auth'])\n\nOAuth2Form = Annotated[OAuth2PasswordRequestForm, Depends()]\nSession = Annotated[Session, Depends(get_session)]\n\n\n@router.post('/token', response_model=Token)\ndef login_for_access_token(form_data: OAuth2Form, session: Session):\n    user = session.scalar(select(User).where(User.email == form_data.username))\n\n    if not user:\n        raise HTTPException(\n            status_code=HTTPStatus.UNAUTHORIZED,\n            detail='Incorrect email or password',\n        )\n\n    if not verify_password(form_data.password, user.password):\n        raise HTTPException(\n            status_code=HTTPStatus.UNAUTHORIZED,\n            detail='Incorrect email or password',\n        )\n\n    access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Neste bloco de c\u00f3digo, n\u00f3s criamos um novo router que lidar\u00e1 exclusivamente com a rota de obten\u00e7\u00e3o de token (<code>/token</code>). O endpoint <code>login_for_access_token</code> \u00e9 definido exatamente da mesma maneira que antes, mas agora como parte deste router de autentica\u00e7\u00e3o.</p>"},{"location":"07/#alteracao-da-validacao-de-token","title":"Altera\u00e7\u00e3o da valida\u00e7\u00e3o de token","text":"<p>\u00c9 crucial abordar um aspecto relacionado \u00e0 modifica\u00e7\u00e3o do router: o uso do par\u00e2metro <code>prefix</code>. Ao introduzir o prefixo, o endere\u00e7o do endpoint <code>/token</code>, respons\u00e1vel pela valida\u00e7\u00e3o do bearer token JWT, \u00e9 alterado para <code>/auth/token</code>. Esse caminho est\u00e1 explicitamente definido no <code>OAuth2PasswordBearer</code> dentro de <code>security.py</code>, resultando em uma refer\u00eancia ao caminho antigo <code>/token</code>, anterior \u00e0 cria\u00e7\u00e3o do router.</p> <p>Esse problema fica evidente ao clicar no bot\u00e3o <code>Authorize</code> no Swagger:</p> <p></p> <p>Percebe-se que o caminho para a autoriza\u00e7\u00e3o est\u00e1 incorreto. Como consequ\u00eancia, ao tentar autenticar atrav\u00e9s do Swagger, nos deparamos com um erro na interface:</p> <p></p> <p>No entanto, o erro n\u00e3o \u00e9 suficientemente descritivo para identificarmos a origem do problema, retornando apenas uma mensagem gen\u00e9rica de <code>Auth Error</code>. Para compreender melhor o que ocorreu, \u00e9 necess\u00e1rio verificar o log produzido pelo <code>uvicorn</code> no terminal:</p> Erro mostrado no terminal<pre><code>task serve\n# ...\nINFO:     127.0.0.1:40132 - \"POST /token HTTP/1.1\" 404 Not Found\n</code></pre> <p>A solu\u00e7\u00e3o para este problema \u00e9 relativamente simples. Precisamos ajustar o par\u00e2metro <code>tokenUrl</code> na <code>OAuth2PasswordBearer</code> para refletir as mudan\u00e7as feitas no router, direcionando para <code>/auth/token</code>. Faremos isso no arquivo <code>security.py</code>:</p> security.py<pre><code>oauth2_scheme = OAuth2PasswordBearer(tokenUrl='auth/token')\n</code></pre> <p>Ap\u00f3s essa altera\u00e7\u00e3o, ao utilizar o Swagger, a autoriza\u00e7\u00e3o ser\u00e1 direcionada corretamente para o endpoint apropriado.</p> <p></p>"},{"location":"07/#alteracao-no-teste-do-token","title":"Altera\u00e7\u00e3o no teste do token","text":"<p>Essa altera\u00e7\u00e3o far\u00e1 com que o teste referente a cria\u00e7\u00e3o do token tamb\u00e9m falhe. Pois ele procurar\u00e1 pelo endpoint <code>/token</code>. Devemos fazer a altera\u00e7\u00e3o para o novo caminho, que com a cria\u00e7\u00e3o de router, adiciona o prefixo <code>/auth</code>. Ficando assim:</p> tests/test_app.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/auth/token',#(1)!\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    token = response.json()\n\n    assert response.status_code == HTTPStatus.OK\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <ol> <li>A \u00fanica altera\u00e7\u00e3o \u00e9 mesmo o endpoint!</li> </ol> <p>Desta forma o teste espec\u00edfico do token poder\u00e1 passar corretamente. Mas, existem testes que dependem do token criado pela fixture.</p>"},{"location":"07/#alteracao-na-fixture-de-token","title":"Altera\u00e7\u00e3o na fixture de <code>token</code>","text":"<p>A altera\u00e7\u00e3o da fixture de <code>token</code> \u00e9 igual que fizemos em <code>/tests/test_auth.py</code>, precisamos somente corrigir o novo endere\u00e7o do router no arquivo <code>/tests/conftest.py</code>:</p> /tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    return response.json()['access_token']\n</code></pre> <p>Fazendo assim com que os testes que dependem dessa fixture passem a funcionar.</p> <p>Contudo, essas modifica\u00e7\u00f5es ainda n\u00e3o podem ser executadas, pois precisamos plugar os roteadores no aplicativo antes de executar.</p>"},{"location":"07/#plugando-as-rotas-em-app","title":"Plugando as rotas em app","text":"<p>O FastAPI oferece uma maneira f\u00e1cil e direta de incluir routers em nossa aplica\u00e7\u00e3o principal. Isso nos permite organizar nossos endpoints de maneira eficiente e manter nosso arquivo <code>app.py</code> focado apenas em suas responsabilidades principais.</p> <p>Para incluir os routers em nossa aplica\u00e7\u00e3o principal, precisamos import\u00e1-los e usar a fun\u00e7\u00e3o <code>include_router()</code>. Aqui est\u00e1 como o nosso arquivo <code>app.py</code> fica depois de incluir os routers:</p> fast_zero/fast_zero/app.py<pre><code>from http import HTTPStatus\n\nfrom fastapi import FastAPI\n\nfrom fast_zero.routers import auth, users\nfrom fast_zero.schemas import Message\n\napp = FastAPI()\n\napp.include_router(users.router)\napp.include_router(auth.router)\n\n\n@app.get('/', status_code=HTTPStatus.OK, response_model=Message)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Como voc\u00ea pode ver, nosso arquivo <code>app.py</code> \u00e9 muito mais simples agora. Ele agora delega as rotas para os respectivos routers, mantendo o foco em iniciar nossa aplica\u00e7\u00e3o FastAPI.</p>"},{"location":"07/#executando-os-testes","title":"Executando os testes","text":"<p>Ap\u00f3s refatorar nosso c\u00f3digo, \u00e9 crucial verificar se tudo continua funcionando como esperado. Para isso, executamos nossos testes novamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Como voc\u00ea pode ver, todos os testes passaram. Isso significa que as altera\u00e7\u00f5es que fizemos no nosso c\u00f3digo n\u00e3o afetaram o funcionamento do nosso aplicativo. O router manteve todos os endpoints nas mesmas rotas, garantindo a continuidade do comportamento esperado.</p> <p>Agora, para melhor alinhar nossos testes com a nova estrutura do nosso c\u00f3digo, devemos reorganizar os arquivos de teste de acordo. Ou seja, tamb\u00e9m devemos criar arquivos de teste espec\u00edficos para cada router, em vez de manter todos os testes no arquivo <code>tests/test_app.py</code>. Essa estrutura facilitar\u00e1 a manuten\u00e7\u00e3o e compreens\u00e3o dos testes \u00e0 medida que nossa aplica\u00e7\u00e3o cresce.</p>"},{"location":"07/#reestruturando-os-arquivos-de-testes","title":"Reestruturando os arquivos de testes","text":"<p>Para acompanhar a nova estrutura routers, podemos desacoplar os testes do m\u00f3dulo <code>test/test_app.py</code> e criar arquivos de teste espec\u00edficos para cada um dos dom\u00ednios:</p> <ul> <li><code>/tests/test_app.py</code>: Para testes relacionados ao aplicativo em geral</li> <li><code>/tests/test_auth.py</code>: Para testes relacionados \u00e0 autentica\u00e7\u00e3o e token</li> <li><code>/tests/test_users.py</code>: Para testes relacionados \u00e0s rotas de usu\u00e1rios</li> </ul> <p>Vamos adaptar os testes para se encaixarem nessa nova estrutura.</p>"},{"location":"07/#ajustando-os-testes-para-auth","title":"Ajustando os testes para Auth","text":"<p>Come\u00e7aremos criando o arquivo <code>/tests/test_auth.py</code>. Esse arquivo ser\u00e1 respons\u00e1vel por testar todas as funcionalidades relacionadas \u00e0 autentica\u00e7\u00e3o do usu\u00e1rio.</p> /tests/test_auth.py<pre><code>from http import HTTPStatus\n\n\ndef test_get_token(client, user):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    token = response.json()\n\n    assert response.status_code == HTTPStatus.OK\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>\u00c9 importante notar que com a cria\u00e7\u00e3o do router usando <code>prefix='/auth'</code> devemos alterar o endpoint onde o request \u00e9 feito de <code>'/token'</code> para <code>'/auth/token'</code>. Fazendo com que a requisi\u00e7\u00e3o seja encaminhada para o lugar certo.</p>"},{"location":"07/#ajustando-os-testes-para-user","title":"Ajustando os testes para User","text":"<p>Em seguida, moveremos os testes relacionados ao dom\u00ednio do usu\u00e1rio para o arquivo <code>/tests/test_users.py</code>.</p> /tests/test_users.py<pre><code>from http import HTTPStatus\n\nfrom fast_zero.schemas import UserPublic\n\n\ndef test_create_user(client):\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CREATED\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n\n\ndef test_read_users(client):\n    response = client.get('/users')\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'users': []}\n\n\ndef test_read_users_with_users(client, user):\n    user_schema = UserPublic.model_validate(user).model_dump()\n    response = client.get('/users/')\n    assert response.json() == {'users': [user_schema]}\n\n\ndef test_update_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n\ndef test_update_integrity_error(client, user, token):\n    # Inserindo fausto\n    client.post(\n        '/users',\n        json={\n            'username': 'fausto',\n            'email': 'fausto@example.com',\n            'password': 'secret',\n        },\n    )\n\n    # Alterando o user das fixture para fausto\n    response_update = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'fausto',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n\n    assert response_update.status_code == HTTPStatus.CONFLICT\n    assert response_update.json() == {\n        'detail': 'Username or Email already exists'\n    }\n\n\ndef test_delete_user(client, user, token):\n    response = client.delete(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'User deleted'}\n</code></pre> <p>Para a constru\u00e7\u00e3o desse arquivo, nenhum teste foi modificado. Eles foram somente movidos para o dom\u00ednio espec\u00edfico do router. Importante, por\u00e9m, notar que alguns destes testes usam a fixture <code>token</code> para checar a autoriza\u00e7\u00e3o, como o endpoint do token foi alterado, devemos alterar a fixture de <code>token</code> para que esses testes continuem passando.</p>"},{"location":"07/#executando-os-testes_1","title":"Executando os testes","text":"<p>Ap\u00f3s essa reestrutura\u00e7\u00e3o, \u00e9 importante garantir que tudo continua funcionando corretamente. Executaremos os testes novamente para confirmar isso.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Como podemos ver, todos os testes continuam passando com sucesso, mesmo ap\u00f3s terem sido movidos para arquivos diferentes. Isso \u00e9 uma confirma\u00e7\u00e3o de que nossa reestrutura\u00e7\u00e3o foi bem-sucedida e que nossa aplica\u00e7\u00e3o continua funcionando como esperado.</p>"},{"location":"07/#adicionando-fast-a-analise-estatica","title":"Adicionando <code>FAST</code> a an\u00e1lise est\u00e1tica","text":"<p>Uma das coisas que voc\u00ea j\u00e1 deve ter notado at\u00e9 agora \u00e9 o quanto a an\u00e1lise est\u00e1tica do ruff nos ajuda a manter um c\u00f3digo mais padronizado, sempre escrito da mesma forma e com uma integridade conceitual.</p> <p>Todas as regras que no ruff, com exce\u00e7\u00e3o da <code>'PT'</code> (do pytest), s\u00e3o sobre boas pr\u00e1ticas gerais de desenvolvimento python. Mas, o ruff tamb\u00e9m conta com checagem de boas pr\u00e1ticas de c\u00f3digo FastAPI. Com as regras definidas em FAST.</p> <p>Podemos adicionar essa regra ao nosso arquivo de configura\u00e7\u00e3o:</p> pyproject.toml<pre><code>[tool.ruff.lint]\npreview = true\nselect = ['I', 'F', 'E', 'W', 'PL', 'PT', 'FAST']\n</code></pre> <p>Dessa forma, ao executar o linter, podemos verificar se h\u00e1 infra\u00e7\u00f5es de boas pr\u00e1ticas no c\u00f3digo que escrevemos at\u00e9 agora:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nfast_zero/routers/auth.py:21:5: 'FAST002' FastAPI dependency without `Annotated`\n   |\n19 | @router.post('/token', response_model=Token)\n20 | def login_for_access_token(\n21 |     form_data: OAuth2PasswordRequestForm = Depends(),\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ FAST002\n22 |     session: Session = Depends(get_session),\n23 | ):\n   |\n   = help: Replace with `typing.Annotated`\n# ... Diversos erros FAST002\n</code></pre> <p>Essa regra do Ruff \u00e9 baseada em uma recomenda\u00e7\u00e3o da documenta\u00e7\u00e3o do FastAPI, que sugere que o uso do tipo <code>typing.Annotated</code> \u00e9 prefer\u00edvel ao uso de inje\u00e7\u00e3o de depend\u00eancia diretamente no par\u00e2metro, como <code>param: tipo = Depends(...)</code>.</p>"},{"location":"07/#refinando-a-definicao-de-rotas-com-annotated","title":"Refinando a Defini\u00e7\u00e3o de Rotas com Annotated","text":"<p>A biblioteca nativa <code>typing</code> oferece diversos recursos fascinantes, e um deles \u00e9 o tipo <code>Annotated</code>. Esse tipo permite que um tipo de dado e seus metadados sejam definidos juntos e reutilizados posteriormente. Algo como:</p> C\u00f3digo de exemplo<pre><code>int_maior_que_zero = Annotated[int, \"maior_que(0)\"] #(1)!\n</code></pre> <ol> <li>O valor ap\u00f3s o tipo em <code>Annotated</code> pode ser qualquer metadado arbitr\u00e1rio. Quem define o significado desse metadado s\u00e3o as bibliotecas que utilizam esses metadados. Neste caso, o FastAPI, por exemplo, tem seus pr\u00f3prios metadados que podem ser utilizados para funcionalidades como valida\u00e7\u00f5es ou configura\u00e7\u00f5es de depend\u00eancia.</li> </ol> <p>Esse recurso \u00e9 especialmente \u00fatil quando precisamos utilizar a mesma depend\u00eancia em v\u00e1rios endpoints.</p> <p>Ao definir par\u00e2metros que utilizam inje\u00e7\u00e3o de depend\u00eancia, at\u00e9 o momento seguimos a formata\u00e7\u00e3o: <code>nome_do_argumento: Tipo = Depends(o_que_dependemos)</code>. Por exemplo:</p> <pre><code>session: Session = Depends(get_session)\n</code></pre> <p>Usando <code>Annotated</code>, podemos colocar o <code>Depends</code> nos metadados, o que nos permite encapsular tanto o tipo do par\u00e2metro quanto o <code>Depends</code> em uma \u00fanica entidade, facilitando a defini\u00e7\u00e3o dos endpoints.</p> <p>Por exemplo:</p> fast_zero/routers/users.py<pre><code>from typing import Annotated\n\nSession = Annotated[Session, Depends(get_session)]\nCurrentUser = Annotated[User, Depends(get_current_user)]\n</code></pre> <p>Dessa forma, conseguimos refinar a defini\u00e7\u00e3o dos endpoints para torn\u00e1-los mais concisos, sem alterar seu funcionamento:</p> fast_zero/routers/users.py<pre><code>@router.post('/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(user: UserSchema, session: Session):\n# ...\n\n@router.get('/', response_model=UserList)\ndef read_users(session: Session, skip: int = 0, limit: int = 100):\n# ...\n\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session,\n    current_user: CurrentUser\n):\n# ...\n\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session, current_user: CurrentUser):\n# ...\n</code></pre> <p>Da mesma forma, podemos otimizar o roteador de autentica\u00e7\u00e3o:</p> fast_zero/routers/auth.py<pre><code>from typing import Annotated\n\n# ...\n\nOAuth2Form = Annotated[OAuth2PasswordRequestForm, Depends()]\nSession = Annotated[Session, Depends(get_session)]\n\n@router.post('/token', response_model=Token)\ndef login_for_access_token(form_data: OAuth2Form, session: Session):\n#...\n</code></pre> <p>Assim, quando inserirmos novos endpoints que dependem das mesmas coisas, nosso c\u00f3digo ficar\u00e1 mais organizado e, ao alterar alguma depend\u00eancia, ela ser\u00e1 refletida em todos os endpoints.</p> <p>Com essas altera\u00e7\u00f5es, ao executar o linter novamente, n\u00e3o devemos ter nenhum erro <code>FAST002</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nAll checks passed!\n</code></pre> <p>Dessa forma, seguimos as boas pr\u00e1ticas indicadas pelo Ruff.</p>"},{"location":"07/#parametros-de-query-via-pydantic","title":"Par\u00e2metros de query via Pydantic","text":"<p>Agora que conhecemos o tipo <code>Annotated</code>, podemos introduzir um novo conceito para as querystrings. No endpoint de listagem, estamos passando par\u00e2metros espec\u00edficos na URL para paginar a quantidade de objetos.</p> <p>Com <code>skip</code> e <code>offset</code>. Reduzindo a quantidade de objetos na resposta:</p> fast_zero/routers/users.py<pre><code>@app.get('/', response_model=UserList)\ndef read_users(session: Session, skip: int = 0, limit: int = 100):\n    users = session.scalars(select(User).offset(skip).limit(limit)).all()\n    return {'users': users}\n</code></pre> <p>Embora isso n\u00e3o seja efetivamente um problema, par\u00e2metros de <code>offset</code> e <code>limit</code> s\u00e3o bastante gen\u00e9ricos e podem ser usados em qualquer endpoint que precisar de pagina\u00e7\u00e3o.</p> <p>Uma boa pr\u00e1tica de organiza\u00e7\u00e3o seria usar um modelo do pydantic especializado em filtros, algo como:</p> fast_zero/schemas.py<pre><code>class FilterPage(BaseModel):\n    offset: int = 0\n    limit: int = 100\n</code></pre> <p>Dessa forma, temos um modelo padr\u00e3o de filtro e qualquer endpoint que precisar paginar resultados pode se beneficiar desse modelo.</p>"},{"location":"07/#restringindo-queries-com-field","title":"Restringindo queries com <code>Field</code>","text":"<p>Uma das grandes vantagens de usar o pydantic para as querystrings \u00e9 poder restringir de algumas formas os dados que podem ser passados pelo cliente. Por exemplo, embora <code>offset: int = 0</code> pare\u00e7a bastante confi\u00e1vel, temos um problema claro com o tipo <code>int</code>. E se for passado um valor negativo?</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, ConfigDict, EmailStr, Field\n\n# ...\n\nclass FilterPage(BaseModel):\n    offset: int = Field(0, ge=0)\n    limit: int = Field(100, ge=1)\n</code></pre> <p>Os <code>Field</code>s do pydantic podem aplicar diversas valida\u00e7\u00f5es adicionais, al\u00e9m dos tipos. Neste caso, <code>ge</code> significa greater than [maior que]. O que significa, no caso de <code>offset</code>, que o valor deve ser do tipo <code>int</code> e maior ou igual a <code>0</code>.</p> Annotated e Pydantic <p>Embora tenhamos usado a nota\u00e7\u00e3o completa das anota\u00e7\u00f5es de tipo, como: </p><pre><code>class FilterPage(BaseModel):\n    offset: int = Field(0, ge=0)\n</code></pre><p></p> <p>O tipo <code>Annotated</code> tamb\u00e9m poderia ser usado aqui: </p><pre><code>class FilterPage(BaseModel):\n    offset: Annotated[int, Field(0, ge=0)]\n</code></pre><p></p>"},{"location":"07/#implementacao-de-querystrings-via-pydantic","title":"Implementa\u00e7\u00e3o de querystrings via Pydantic","text":"<p>Uma das formas de remover a declara\u00e7\u00e3o de todos os par\u00e2metros explicitamente da query no endpoint \u00e9 usar nosso modelo com o objeto <code>Query</code> do FastAPI.</p> <p>Dessa forma podemos anotar o modelo do pydantic junto o objeto <code>Query</code>. Fazendo com que ele se torne um filtro:</p> fast_zero/routers/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException, Query\n\n# ...\n\nfrom fast_zero.schemas import (\n    FilterPage,\n    Message,\n    UserList,\n    UserPublic,\n    UserSchema,\n)\n\n# ...\n\n@router.get('/', response_model=UserList)\ndef read_users(session: Session, filter_users: Annotated[FilterPage, Query()]):\n    ...\n</code></pre> <p>Por conta da anota\u00e7\u00e3o com o tipo <code>Query()</code> a documenta\u00e7\u00e3o mant\u00e9m os par\u00e2metros com o formato de querystrings na documenta\u00e7\u00e3o:</p> <p></p> <p>E o uso do modelo <code>FilterPage</code> funciona da mesma forma que qualquer modelo do pydantic, acessando os atributos via ponto:</p> fast_zero/routers/users.py<pre><code>@router.get('/', response_model=UserList)\ndef read_users(session: Session, filter_users: Annotated[FilterPage, Query()]):\n    users = session.scalars(\n        select(User).offset(filter_users.offset).limit(filter_users.limit)\n    ).all()\n</code></pre> <p>Isso al\u00e9m de simplificar o reuso das queries em outros endpoints tamb\u00e9m facilita a expans\u00e3o do filtro sem a responsabilidade de intervir nas implementa\u00e7\u00f5es dos endpoints de forma ativa.</p>"},{"location":"07/#movendo-as-constantes-para-variaveis-de-ambiente","title":"Movendo as constantes para vari\u00e1veis de ambiente","text":"<p>Conforme mencionamos na aula sobre os 12 fatores, \u00e9 uma boa pr\u00e1tica manter as constantes que podem mudar dependendo do ambiente em vari\u00e1veis de ambiente. Isso torna o seu projeto mais seguro e modular, pois voc\u00ea pode alterar essas constantes sem ter que modificar o c\u00f3digo-fonte.</p> <p>Por exemplo, temos estas constantes em nosso m\u00f3dulo <code>security.py</code>:</p> <pre><code>SECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n</code></pre> <p>Estes valores n\u00e3o devem estar diretamente no c\u00f3digo-fonte, ent\u00e3o vamos mov\u00ea-los para nossas vari\u00e1veis de ambiente e represent\u00e1-los na nossa classe <code>Settings</code>.</p>"},{"location":"07/#adicionando-as-constantes-a-settings","title":"Adicionando as constantes a Settings","text":"<p>J\u00e1 temos uma classe ideal para fazer isso em <code>fast_zero/settings.py</code>. Alteraremos essa classe para incluir estas constantes.</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file='.env', env_file_encoding='utf-8'\n    )\n\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Agora, precisamos adicionar estes valores ao nosso arquivo <code>.env</code>.</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\nSECRET_KEY=\"your-secret-key\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> <p>Com isso, podemos alterar o nosso c\u00f3digo em <code>fast_zero/security.py</code> para ler as constantes a partir da classe <code>Settings</code>.</p>"},{"location":"07/#removendo-as-constantes-do-codigo","title":"Removendo as constantes do c\u00f3digo","text":"<p>Primeiramente, carregaremos as configura\u00e7\u00f5es da classe <code>Settings</code> no in\u00edcio do m\u00f3dulo <code>security.py</code>.</p> fast_zero/security.py<pre><code>from fast_zero.settings import Settings\n\nsettings = Settings()\n</code></pre> <p>Com isso, todos os lugares onde as constantes eram usadas devem ser substitu\u00eddos por <code>settings.CONSTANTE</code>. Por exemplo, na fun\u00e7\u00e3o <code>create_access_token</code>, alteraremos para usar as constantes da classe <code>Settings</code>:</p> fast_zero/security.py<pre><code>def create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.now(tz=ZoneInfo('UTC')) + timedelta(\n        minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    to_encode.update({'exp': expire})\n    encoded_jwt = encode(\n        to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM\n    )\n    return encoded_jwt\n</code></pre> <p>Desta forma, eliminamos todas as constantes do c\u00f3digo-fonte e passamos a usar as configura\u00e7\u00f5es a partir da classe <code>Settings</code>. Isso torna nosso c\u00f3digo mais seguro, pois as constantes sens\u00edveis, como a chave secreta, est\u00e3o agora seguras em nosso arquivo <code>.env</code>, e nosso c\u00f3digo fica mais modular, pois podemos facilmente alterar estas constantes simplesmente mudando os valores no arquivo <code>.env</code>. Al\u00e9m disso, essa abordagem facilita o gerenciamento de diferentes ambientes (como desenvolvimento, teste e produ\u00e7\u00e3o) pois cada ambiente pode ter seu pr\u00f3prio arquivo <code>.env</code> com suas configura\u00e7\u00f5es espec\u00edficas.</p> <p>Precisamos alterar o teste para usar as mesmas vari\u00e1veis de ambiente do c\u00f3digo:</p> /tests/test_security.py<pre><code>from http import HTTPStatus\n\nfrom jwt import decode\n\nfrom fast_zero.security import create_access_token, settings\n\n\ndef test_jwt():\n    data = {'test': 'test'}\n    token = create_access_token(data)\n\n    decoded = decode(\n        token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]\n    )\n\n    assert decoded['test'] == data['test']\n    assert 'exp' in decoded\n</code></pre>"},{"location":"07/#testando-se-tudo-funciona","title":"Testando se tudo funciona","text":"<p>Depois de todas essas mudan\u00e7as, \u00e9 muito importante garantir que tudo ainda est\u00e1 funcionando corretamente. Para isso, executaremos todos os testes que temos at\u00e9 agora.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se tudo estiver certo, todos os testes devem passar. Lembre-se de que a refatora\u00e7\u00e3o n\u00e3o deve alterar a funcionalidade do nosso c\u00f3digo - apenas torn\u00e1-lo mais f\u00e1cil de ler e manter.</p>"},{"location":"07/#commit","title":"Commit","text":"<p>Para finalizar, criaremos um commit para registrar todas as altera\u00e7\u00f5es que fizemos na nossa aplica\u00e7\u00e3o. Como essa \u00e9 uma grande mudan\u00e7a que envolve reestruturar a forma como lidamos com as rotas e mover as constantes para vari\u00e1veis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais altera\u00e7\u00f5es:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Refatorando estrutura do projeto: Criado routers para Users e Auth; movido constantes para vari\u00e1veis de ambiente.\"\n</code></pre>"},{"location":"07/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Na pr\u00f3xima aula, vamos adicionar o suporte a programa\u00e7\u00e3o ass\u00edncrona em nossa aplica\u00e7\u00e3o. Caso esse assunto seja um novidade para voc\u00ea, temos uma live introdut\u00f3ria sobre o assunto:</p> <ul> <li>Requests ass\u00edncronos com HTTPX | Live de Python #234</li> </ul>"},{"location":"07/#exercicio","title":"Exerc\u00edcio","text":"<p>Migre os endpoints e testes criados nos exerc\u00edcios anteriores para os locais corretos na nova estrutura da aplica\u00e7\u00e3o.</p>"},{"location":"07/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, vimos como refatorar a estrutura do nosso projeto FastAPI para torn\u00e1-lo mais manuten\u00edvel. Organizamos nosso c\u00f3digo em diferentes arquivos e usamos o sistema de roteadores do FastAPI para separar diferentes partes da nossa API. Tamb\u00e9m mudamos algumas constantes para o arquivo de configura\u00e7\u00e3o, tornando nosso c\u00f3digo mais seguro e flex\u00edvel. Finalmente, atualizamos nossos testes para refletir a nova estrutura do projeto.</p> <p>Refatorar \u00e9 um processo cont\u00ednuo - sempre h\u00e1 espa\u00e7o para melhorias. No entanto, com a estrutura que estabelecemos aqui, estamos em uma boa posi\u00e7\u00e3o para continuar a expandir nossa API no futuro.</p> <p>Na pr\u00f3xima aula, exploraremos mais sobre autentica\u00e7\u00e3o e como gerenciar tokens de acesso e de atualiza\u00e7\u00e3o em nossa API FastAPI.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"08/","title":"Tornando o projeto ass\u00edncrono","text":""},{"location":"08/#tornando-o-projeto-assincrono","title":"Tornando o projeto ass\u00edncrono","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introduzir os conceitos de programa\u00e7\u00e3o ass\u00edncrona</li> <li>Refatorar nossa aplica\u00e7\u00e3o para suportar asyncio</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Uma das caracter\u00edsticas mais apreciadas do FastAPI \u00e9 o suporte \u00e0 programa\u00e7\u00e3o ass\u00edncrona. Isso nos permite usar concorr\u00eancia nos momentos de entrada e sa\u00edda, fazendo com que, enquanto buscamos por um dado no banco de dados, por exemplo, o nosso aplicativo esteja dispon\u00edvel para receber e tamb\u00e9m responder novas requisi\u00e7\u00f5es sem a necessidade de aguardar pela finaliza\u00e7\u00e3o do bloqueio.</p>"},{"location":"08/#uma-pequena-introducao-ao-asyncio","title":"Uma pequena introdu\u00e7\u00e3o ao asyncio","text":"<p>Um dos problemas mais comuns ao lidarmos com uma aplica\u00e7\u00e3o web \u00e9 a necessidade de estarmos sempre dispon\u00edveis para responder a requisi\u00e7\u00f5es enviadas pelos clientes. Quando recebemos uma requisi\u00e7\u00e3o, normalmente precisamos process\u00e1-la: validar o schema, conectar ao banco de dados, realizar algumas opera\u00e7\u00f5es e, finalmente, retornar o recurso solicitado.</p> <p>Em um cen\u00e1rio s\u00edncrono, nosso cen\u00e1rio at\u00e9 o momento, enquanto processamos uma requisi\u00e7\u00e3o, n\u00e3o conseguimos processar outra at\u00e9 que a primeira seja conclu\u00edda. Esse fluxo de execu\u00e7\u00e3o \u00e9 chamado de bloqueante, pois a aplica\u00e7\u00e3o fica \"parada\", aguardando a resposta de sistemas externos, como o banco de dados. Esse tempo de espera, conhecido como bloqueio por I/O (Input/Output) [Entrada/Sa\u00edda], prejudica o desempenho, pois a aplica\u00e7\u00e3o n\u00e3o pode atender a novas requisi\u00e7\u00f5es enquanto espera.</p> Bloqueio de aplica\u00e7\u00e3o VS bloqueio do servidor <p>Quando dizemos que a aplica\u00e7\u00e3o est\u00e1 bloqueada, estamos nos referindo somente ao c\u00f3digo expl\u00edcito da aplica\u00e7\u00e3o. O servidor de aplica\u00e7\u00e3o, em nosso caso o <code>uvicorn</code>, j\u00e1 trabalha de forma n\u00e3o bloqueante. Ele cria uma fila de requisi\u00e7\u00f5es e vai passando uma a uma \u00e0 nossa aplica\u00e7\u00e3o conforme as respostas forem sendo retornadas.</p> <p>Al\u00e9m disso, ele pode inicializar diversas c\u00f3pias da nossa aplica\u00e7\u00e3o (mesmo s\u00edncronas) em um formato de workers e executar diversos processos para nossa aplica\u00e7\u00e3o. Se quisermos inicializar o uvicorn nesse modo, a \u00fanica altera\u00e7\u00e3o necess\u00e1ria seria adicionar a flag <code>--workers &lt;int&gt;</code>. Algo como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn fast_zero.app:app --workers 3\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started parent process [96097]\nINFO:     Started server process [96100]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [96099]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Started server process [96101]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n</code></pre> <p>Fazendo com que nossa aplica\u00e7\u00e3o seja \"clonada\" em tr\u00eas processos e consequ\u00eantemente resolva tr\u00eas requisi\u00e7\u00f5es por vez: </p><pre><code>flowchart LR\n   Cliente --&gt; Uvicorn\n   Uvicorn --&gt; copia_01\n   Uvicorn --&gt; copia_02\n   Uvicorn --&gt; copia_03</code></pre><p></p> <p>Uma forma de contornar esse comportamento \u00e9 o uso de corrotinas ass\u00edncronas.</p>"},{"location":"08/#bloqueio-de-io","title":"Bloqueio de I/O","text":"<p>Quando o c\u00f3digo precisa interagir com sistemas externos \u2014 como um banco de dados, a escrita de um arquivo no sistema operacional ou uma requisi\u00e7\u00e3o web \u2014 ele fica \"parado\", aguardando a resposta para seguir com a execu\u00e7\u00e3o. Esse comportamento de espera \u00e9 chamado de bloqueio por I/O, e ocorre quando a aplica\u00e7\u00e3o n\u00e3o est\u00e1 realizando outra tarefa enquanto espera pela conclus\u00e3o da opera\u00e7\u00e3o externa.</p> <pre><code>sequenceDiagram\n    participant A as Aplica\u00e7\u00e3o\n    participant B as Banco de Dados\n    A-&gt;&gt;B: Envia consulta\n    B--&gt;&gt;A: Espera resposta do banco (bloqueia a aplica\u00e7\u00e3o)\n    B-&gt;&gt;A: Recebe resposta do banco\n    A-&gt;&gt;B: Prossegue com pr\u00f3xima tarefa</code></pre> <p>Esse comportamento de bloqueio pode prejudicar a escalabilidade da aplica\u00e7\u00e3o. Em um cen\u00e1rio com v\u00e1rias requisi\u00e7\u00f5es simult\u00e2neas, uma aplica\u00e7\u00e3o bloqueante pode ficar \"presa\" esperando a resposta de um sistema externo (como o banco de dados), o que impede que outras requisi\u00e7\u00f5es sejam atendidas, resultando em uma perda de desempenho e capacidade de atendimento.</p>"},{"location":"08/#corrotinas-assincronas","title":"Corrotinas ass\u00edncronas","text":"<p>Uma corrotina ass\u00edncrona \u00e9 um tipo especial de \"fun\u00e7\u00e3o\" que pode ser suspensa em determinados pontos (normalmente quando h\u00e1 uma opera\u00e7\u00e3o de bloqueio, como I/O) e retomar a execu\u00e7\u00e3o mais tarde. Isso permite que a aplica\u00e7\u00e3o n\u00e3o fique \"parada\" enquanto espera por uma resposta, permitindo que o Python execute outras tarefas enquanto aguarda a conclus\u00e3o da opera\u00e7\u00e3o.</p> <p>Em python, corrotinas s\u00e3o definidas com a palavra-chave <code>async</code>, no in\u00edcio da fun\u00e7\u00e3o:</p> C\u00f3digo de exemplo<pre><code>async def corrotina():\n    # Opera\u00e7\u00f5es que podem ser suspensas\n    ...\n    return &lt;algo&gt;\n</code></pre> <p>Diferente de uma fun\u00e7\u00e3o tradicional, que realiza toda a execu\u00e7\u00e3o de uma vez (at\u00e9 encontrar o <code>return</code>), a corrotina pode ser escalonada usando a palavra-chave <code>await</code>.</p> <p>O <code>await</code> \u00e9 usado para chamar opera\u00e7\u00f5es que podem levar algum tempo, pelo bloqueio de I/O. Isso permite que o Python \"libere\" o controle de volta para o loop de eventos, que pode executar outras tarefas enquanto aguarda a opera\u00e7\u00e3o e \"espera\" a resposta de I/O ser conclu\u00edda:</p> C\u00f3digo de exemplo<pre><code>async def corrotina():\n    await &lt;chamada-no-banco-de-dados&gt;\n    await &lt;chamada-para-api-externa&gt;\n    await &lt;chamada-para-o-sistema-operacional&gt;\n    return &lt;algo&gt;\n</code></pre> <p>Sendo menos formal, dizemos que quando um <code>await</code> \u00e9 encontrado, ele \"cede a vez\" para outra corrotina ser executada durante a espera de I/O.</p> <p>O uso de <code>await</code> torna a execu\u00e7\u00e3o cooperativa, pois a corrotina avisa ao loop que precisa \"esperar por algo\", fazendo com que outras tarefas sejam executadas durante a espera, tornando o fluxo n\u00e3o bloqueante.</p> Toda corrotina \u00e9 ass\u00edncrona? <p>Embora quase todas \u00e0s vezes que dizemos \"corrotina\", em python moderno, estamos nos referindo a c\u00f3digo ass\u00edncrono, em teoria esse termo j\u00e1 era largamente utilizado antes. Para fun\u00e7\u00f5es geradoras com a palavra <code>yield</code>, que podem passar o controle a outro bloco de c\u00f3digo e voltarem a ser executadas de onde pararam.</p> <p>Damos ao nome a esse tipo de corrotina de \"corrotinas cl\u00e1ssicas\", vimos diversas delas aqui no curso quando criamos fixtures com <code>yield</code>:</p> Pseudoc\u00f3digo de exemplo<pre><code>def exemplo_fixture():\n    coloque_a_aplica\u00e7\u00e3o_no_estado_x()\n    yield  # Aqui existe uma pausa na execu\u00e7\u00e3o, mas n\u00e3o \u00e9 ass\u00edncrona\n    retorne_a_aplica\u00e7\u00e3o_no_estado_y()\n</code></pre>"},{"location":"08/#loop-de-eventos","title":"Loop de eventos","text":"<p>O loop de eventos \u00e9 o cora\u00e7\u00e3o da programa\u00e7\u00e3o ass\u00edncrona, sendo respons\u00e1vel por coordenar a execu\u00e7\u00e3o das corrotinas. Em termos simples, o loop de eventos \u00e9 um loop infinito que gerencia todas as corrotinas e garante que elas sejam executadas em ordem, permitindo o escalonamento de v\u00e1rias tarefas eficientemente e sem bloqueios.</p> <p>Todas as corrotinas s\u00e3o enviadas para o loop de eventos, no momento em que s\u00e3o chamadas, para que ele as execute. Essas corrotinas s\u00e3o executadas sequencialmente, como uma fun\u00e7\u00e3o qualquer. No entanto, quando o loop encontra a palavra-chave <code>await</code>, ele a \"deixa de lado\" temporariamente, at\u00e9 que a tarefa que estava sendo aguardada termine. O loop ent\u00e3o retoma a execu\u00e7\u00e3o da pr\u00f3xima corrotina, ou a que estiver pronta para ser executada, at\u00e9 encontrar outro <code>await</code>.</p> <p>Vamos visualizar isso:</p> <pre><code>sequenceDiagram\n    participant B as C\u00f3digo\n    participant C as Corrotina 1\n    participant D as Corrotina 2\n    participant A as Loop de Eventos\n\n    B-&gt;&gt;C: C\u00f3digo chama Corrotina 1\n    C-&gt;&gt;A: Corrotina 1 vai para o loop de eventos\n    B-&gt;&gt;D: C\u00f3digo chama Corrotina 2\n    D-&gt;&gt;A: Corrotina 2 vai para o loop de eventos\n\n    A-&gt;&gt;C: Executa Corrotina 1 at\u00e9 \"await\"\n    A-&gt;&gt;D: Executa Corrotina 2 at\u00e9 \"await\"\n    A-&gt;&gt;C: Retoma Corrotina 1 ap\u00f3s \"await\"\n    A-&gt;&gt;D: Retoma Corrotina 2 ap\u00f3s \"await\"\n\n    %% Finalizando Corrotina 1\n    A-&gt;&gt;C: Executa Corrotina 1 at\u00e9 \"return\"\n    C--&gt;&gt;A: Corrotina 1 finalizada (return)\n\n    %% Continuando Corrotina 2\n    A-&gt;&gt;D: Executa Corrotina 2 at\u00e9 \"await\"\n    A-&gt;&gt;D: Retoma Corrotina 2 ap\u00f3s \"await\"\n    A-&gt;&gt;D: Executa Corrotina 2 at\u00e9 \"return\"\n    D--&gt;&gt;A: Corrotina 2 finalizada (return)</code></pre> <p>Neste exemplo, o c\u00f3digo chama duas corrotinas. O loop de eventos vai alternando entre elas, executando-as at\u00e9 encontrar o await, e ent\u00e3o \"pausa\" a execu\u00e7\u00e3o de uma e passa para a pr\u00f3xima, sem bloquear o andamento do programa. Isso permite que o c\u00f3digo continue a processar outras tarefas enquanto espera por opera\u00e7\u00f5es mais lentas (como I/O), otimizando a performance e a escalabilidade da aplica\u00e7\u00e3o.</p>"},{"location":"08/#cooperatividade-e-escalonamento","title":"Cooperatividade e Escalonamento","text":"<p>Corrotinas s\u00e3o chamadas de cooperativas porque elas \"cedem\" voluntariamente o controle para outras corrotinas durante sua execu\u00e7\u00e3o. Em vez de interromper o processo de outra corrotina de maneira for\u00e7ada, cada corrotina permite que o controle seja transferido para outra, quando encontra um ponto de espera (como um await). Isso \u00e9 uma caracter\u00edstica importante da programa\u00e7\u00e3o ass\u00edncrona, ao garantir que a execu\u00e7\u00e3o das corrotinas seja feita de forma eficiente, sem bloqueios desnecess\u00e1rios.</p> <p>O loop de eventos \u00e9 o respons\u00e1vel por coordenar esse processo de \"ceder a vez\". Quando uma corrotina encontra um ponto de espera, como uma opera\u00e7\u00e3o de I/O (por exemplo, uma consulta ao banco de dados ou uma chamada HTTP), ela \"cede\" o controle de volta para o loop de eventos. O loop de eventos, ent\u00e3o, verifica se h\u00e1 outras corrotinas prontas para serem executadas e as executa at\u00e9 que o controle seja novamente cedido, geralmente quando outra corrotina encontra um await.</p> <p>Esse processo de alternar entre corrotinas \u00e9 chamado de escalonamento. O escalonamento n\u00e3o ocorre de forma aleat\u00f3ria; ele segue uma ordem que depende de quando as corrotinas encontram os pontos de espera e como o loop de eventos as organiza. Durante esse processo, o loop de eventos alterna entre as corrotinas, maximizando o uso de CPU e diminuindo o tempo de execu\u00e7\u00e3o, sem que o programa sofra com bloqueios de I/O</p>"},{"location":"08/#exemplo-pratico-com-asyncio","title":"Exemplo pr\u00e1tico com <code>asyncio</code>","text":"<p>Eu sei, eu sei... Esse contexto \u00e9 complicado de entender no in\u00edcio, ent\u00e3o vamos detalhar um exemplo simples usando asyncio para observar como a troca de corrotinas acontece e como o escalonamento \u00e9 realizado.</p> <p>Aqui est\u00e1 o c\u00f3digo:</p> Exemplo de c\u00f3digo do escalonamento<pre><code>from asyncio import gather, run, sleep\n\n\nasync def corrotina(n):\n    print(f'Iniciando corrotina {n}')\n    await sleep(1)\n    print(f'Retomando corrotina {n}')\n    await sleep(1)\n    print(f'Retomando corrotina {n}')\n    await sleep(1)\n    print(f'Corrotina {n} finalizada')\n\n\nasync def main():\n    await gather(corrotina(1), corrotina(2)) #(1)!\n\n\nrun(main()) #(2)!\n</code></pre> <ol> <li><code>gather</code> \u00e9 uma corrotina que inicia outras corrotinas. Neste exemplo, ela inicia as duas corrotinas de forma simult\u00e2nea, enviando-as para o loop de eventos.</li> <li><code>asyncio.run</code> envia a corrotina <code>main</code> para o loop de eventos e aguarda a execu\u00e7\u00e3o ser conclu\u00edda de forma bloqueante.</li> </ol> <p>Ao executar esse c\u00f3digo, ter\u00edamos essa sa\u00edda:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python -i exemplo_asyncio.py\nIniciando corrotina 1\nIniciando corrotina 2\nRetomando corrotina 1\nRetomando corrotina 2\nRetomando corrotina 1\nRetomando corrotina 2\nCorrotina 1 finalizada\nCorrotina 2 finalizada\n</code></pre> <p>Mas como exatamente isso est\u00e1 ocorrendo?</p> <ol> <li> <p>In\u00edcio da execu\u00e7\u00e3o:</p> <ul> <li>A fun\u00e7\u00e3o <code>run(main())</code> \u00e9 chamada e inicia a execu\u00e7\u00e3o da corrotina <code>main()</code>.</li> <li>Dentro de <code>main()</code>, a fun\u00e7\u00e3o <code>gather()</code> chama as duas corrotinas, <code>corrotina(1)</code> e <code>corrotina(2)</code>. Ambas s\u00e3o enviadas para o loop de eventos.</li> </ul> </li> <li> <p>Primeiro <code>await sleep(1)</code> em ambas as corrotinas:</p> <ul> <li>Ambas as corrotinas chegam ao <code>await sleep(1)</code>. Nesse momento, o loop de eventos alterna entre elas, j\u00e1 que ambas est\u00e3o esperando.</li> </ul> </li> <li> <p>Retomada ap\u00f3s 1 segundo:</p> <ul> <li>O loop de eventos retoma a execu\u00e7\u00e3o das corrotinas, uma de cada vez, e elas imprimem:<ul> <li><code>Retomando corrotina 1</code></li> <li><code>Retomando corrotina 2</code></li> </ul> </li> </ul> </li> <li> <p>Repete-se o processo:</p> <ul> <li>O ciclo se repete at\u00e9 que todas as opera\u00e7\u00f5es de <code>sleep</code> sejam conclu\u00eddas.</li> </ul> </li> </ol>"},{"location":"08/#conexao-com-a-teoria","title":"Conex\u00e3o com a teoria","text":"<p>O que vemos aqui \u00e9 a altern\u00e2ncia de execu\u00e7\u00e3o entre as corrotinas, feita pelo loop de eventos. Quando uma corrotina encontra um <code>await</code>, ela \"cede\" o controle ao loop de eventos, permitindo que outra corrotina seja executada enquanto a primeira aguarda uma opera\u00e7\u00e3o (como I/O). Isso evita o bloqueio do sistema e melhora a escalabilidade e o desempenho da aplica\u00e7\u00e3o.</p> <p>Com a combina\u00e7\u00e3o de <code>async/await</code> e o loop de eventos, podemos otimizar o processamento de m\u00faltiplas requisi\u00e7\u00f5es simult\u00e2neas sem bloqueios, o que \u00e9 uma das maiores vantagens da programa\u00e7\u00e3o ass\u00edncrona.</p>"},{"location":"08/#sqlalchemy-e-bloqueios","title":"SQLAlchemy e bloqueios","text":"<p>Tradicionalmente, a comunica\u00e7\u00e3o entre uma aplica\u00e7\u00e3o e um banco de dados segue um modelo bloqueante, onde a aplica\u00e7\u00e3o aguarda a conclus\u00e3o da opera\u00e7\u00e3o de entrada/sa\u00edda (I/O) antes de continuar a execu\u00e7\u00e3o de outras tarefas. Esse modelo pode ser problem\u00e1tico em sistemas com alto tr\u00e1fego ou que necessitam de respostas r\u00e1pidas, pois as opera\u00e7\u00f5es de I/O, como consultas ou inser\u00e7\u00f5es em bancos de dados, s\u00e3o relativamente lentas em compara\u00e7\u00e3o com a velocidade de execu\u00e7\u00e3o do c\u00f3digo da aplica\u00e7\u00e3o.</p>"},{"location":"08/#sqlalchemy-nao-bloqueante","title":"SQLAlchemy n\u00e3o bloqueante","text":"<p>O modelo n\u00e3o bloqueante, ou ass\u00edncrono, visa resolver os problemas de desempenho causados pelas opera\u00e7\u00f5es bloqueantes, permitindo que a aplica\u00e7\u00e3o continue executando outras tarefas enquanto aguarda a resposta de I/O \u2014 por exemplo, uma consulta ao banco de dados. Esse comportamento \u00e9 poss\u00edvel atrav\u00e9s do uso de corrotinas e do agendamento de tarefas, uma t\u00e9cnica que suspende e retoma fun\u00e7\u00f5es eficientemente.</p> <p>A principal diferen\u00e7a entre o modelo bloqueante e o ass\u00edncrono \u00e9 que, no modelo n\u00e3o bloqueante, a aplica\u00e7\u00e3o n\u00e3o \"fica parada\" esperando pela resposta do banco. Em vez disso, a aplica\u00e7\u00e3o inicia uma opera\u00e7\u00e3o de I/O e, enquanto espera pela conclus\u00e3o, pode realizar outras tarefas simultaneamente. Quando a resposta do banco chega, a aplica\u00e7\u00e3o retoma a execu\u00e7\u00e3o da opera\u00e7\u00e3o que estava aguardando.</p> <pre><code>sequenceDiagram\n    participant A as Loop de Eventos\n    participant B as API\n    participant C as Requisi\u00e7\u00e3o 1 (API)\n    participant D as Requisi\u00e7\u00e3o 2 (API)\n    participant E as Banco de Dados\n\n    B-&gt;&gt;A: Recebe Requisi\u00e7\u00e3o 1\n    A-&gt;&gt;C: Processa Requisi\u00e7\u00e3o 1 (I/O com o banco)\n    C-&gt;&gt;E: Consulta banco de dados (I/O)\n    B-&gt;&gt;A: Recebe Requisi\u00e7\u00e3o 2\n    A-&gt;&gt;D: Processa Requisi\u00e7\u00e3o 2 (I/O com o banco)\n    D-&gt;&gt;E: Consulta banco de dados (I/O)\n    C--&gt;&gt;A: Resposta do Banco de Dados para Requisi\u00e7\u00e3o 1\n    A-&gt;&gt;B: Envia resposta para Requisi\u00e7\u00e3o 1\n    D--&gt;&gt;A: Resposta do Banco de Dados para Requisi\u00e7\u00e3o 2\n    A-&gt;&gt;B: Envia resposta para Requisi\u00e7\u00e3o 2</code></pre> <p>Esse modelo \u00e9 especialmente \u00fatil em sistemas com alta concorr\u00eancia, onde m\u00faltiplas opera\u00e7\u00f5es precisam ser realizadas simultaneamente. A programa\u00e7\u00e3o ass\u00edncrona permite que a aplica\u00e7\u00e3o n\u00e3o precise esperar que cada consulta ao banco seja conclu\u00edda antes de iniciar outra tarefa, melhorando significativamente o desempenho e a escalabilidade.</p>"},{"location":"08/#configuracao-para-o-sqlalchemy-assincrono","title":"Configura\u00e7\u00e3o para o SQLAlchemy ass\u00edncrono","text":"<p>Embora o SQLAlchemy ofere\u00e7a suporte \u00e0 programa\u00e7\u00e3o ass\u00edncrona, esse suporte n\u00e3o vem completo por padr\u00e3o. Um dos componentes necess\u00e1rios, o pacote <code>greenlet</code>, n\u00e3o \u00e9 instalado automaticamente, para manter o pacote base mais enxuto. O <code>greenlet</code> \u00e9 respons\u00e1vel por viabilizar corrotinas cooperativas dentro do SQLAlchemy, permitindo a execu\u00e7\u00e3o eficiente de c\u00f3digo ass\u00edncrono.</p> <p>Para garantir que tudo funcione corretamente em ambientes ass\u00edncronos, especialmente em diferentes arquiteturas, \u00e9 necess\u00e1rio instalar a depend\u00eancia opcional do <code>asyncio</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add \"sqlalchemy[asyncio]\"\n</code></pre> <p>Vale lembrar que nunca interagiremos diretamente com o <code>greenlet</code>. Ele \u00e9 utilizado internamente pelo SQLAlchemy de forma transparente, mas \u00e9 necess\u00e1rio para que tudo funcione corretamente.</p>"},{"location":"08/#sqlite-assincrono","title":"SQLite ass\u00edncrono","text":"<p>Al\u00e9m disso, como estamos utilizando o banco de dados SQLite, que n\u00e3o possui suporte nativo a asyncio no Python, precisamos instalar uma extens\u00e3o chamada <code>aiosqlite</code>. Ela permite a execu\u00e7\u00e3o ass\u00edncrona com bancos SQLite:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add aiosqlite\n</code></pre> <p>Para que nossa conex\u00e3o esteja ciente que o <code>aiosqlite</code> est\u00e1 sendo usado, devemos alterar a vari\u00e1vel de ambiente para contemplar essa altera\u00e7\u00e3o:</p> .env<pre><code>DATABASE_URL=\"sqlite+aiosqlite:///database.db\"\n</code></pre> <p>Embora isso pare\u00e7a o suficiente, nossa <code>Sess\u00e3o</code> do banco de dados ainda n\u00e3o est\u00e1 preparada para lidar com uma conex\u00e3o ass\u00edncrona. Isso quer dizer que precisamos alterar como ela \u00e9 criada e deixar expl\u00edcito que agora vamos fazer uma conex\u00e3o ass\u00edncrona:</p> fast_zero/database.py<pre><code>from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\nfrom fast_zero.settings import Settings\n\nengine = create_async_engine(Settings().DATABASE_URL)#(1)!\n\n\nasync def get_session():\n    async with AsyncSession(engine, expire_on_commit=False) as session: #(2)!\n        yield session\n</code></pre> <ol> <li><code>create_async_engine</code> cria a engine de conex\u00e3o ass\u00edncrona com o banco de dados </li> <li><code>AsyncSession</code> gerencia a sess\u00e3o de banco de dados de forma ass\u00edncrona.</li> </ol> <p>As altera\u00e7\u00f5es feitas aqui somente dizem que a nossa engine agora deve ser criada de maneira ass\u00edncrona e que a sess\u00e3o do ORM tamb\u00e9m ser\u00e1 ass\u00edncrona.</p> <p>Uma mudan\u00e7a importante <code>expire_on_commit=False</code>, estamos dizendo ao SQLAlchemy para n\u00e3o expirar os objetos carregados ap\u00f3s um commit, o que \u00e9 importante no contexto ass\u00edncrono. O comportamento padr\u00e3o do SQLAlchemy \u00e9 expirar o cache de objetos ap\u00f3s um commit, o que pode causar problemas em opera\u00e7\u00f5es ass\u00edncronas, pois o objeto pode ser descartado enquanto estamos aguardando em outra corrotina. Por isso, usamos <code>expire_on_commit=False</code> para evitar esse tipo de comportamento.</p> mais informa\u00e7\u00f5es sobre a expira\u00e7\u00e3o <p>Voc\u00ea pode encontrar mais explica\u00e7\u00f5es sobre a necessidade de n\u00e3o expira\u00e7\u00e3o do commit nesta p\u00e1gina da documenta\u00e7\u00e3o</p> <p>Agora, todo I/O que acontece no banco pode ser ass\u00edncrono, isso em potencial. Mas precisamos adequar nosso c\u00f3digo para que o escalonamento entre tarefas possa ser feito.</p>"},{"location":"08/#ajustando-a-sessao-de-testes","title":"Ajustando a sess\u00e3o de testes","text":"<p>Embora o SQLAlchemy e o FastAPI lidem de forma nativa com programa\u00e7\u00e3o ass\u00edncrona, o <code>pytest</code> ainda n\u00e3o. Para isso, precisamos instalar uma extens\u00e3o que adicione esse suporte. A <code>pytest-asyncio</code> fornece um mecanismo de marca\u00e7\u00e3o para testes e tamb\u00e9m um para cria\u00e7\u00e3o de fixtures ass\u00edncronas:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev pytest-asyncio\n</code></pre> <p>Uma exig\u00eancia formal do <code>pytest-asyncio</code> \u00e9 que seja configurado o escopo padr\u00e3o das fixtures:</p> pyproject.toml<pre><code>[tool.pytest.ini_options]\npythonpath = \".\"\naddopts = '-p no:warnings'\nasyncio_default_fixture_loop_scope = 'function'\n</code></pre> <p>Para evitar cair em mais um assunto, esse t\u00f3pico ser\u00e1 tratado na aula 11 em Fixtures de sessao.</p> <p>Desta forma, podemos alterar nossa fixture de <code>session</code> para fornecer uma sess\u00e3o ass\u00edncrona:</p> tests/conftest.py<pre><code># ...\n\nimport pytest_asyncio\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\n# ...\n\n@pytest_asyncio.fixture #(1)!\nasync def session():\n    engine = create_async_engine(\n        'sqlite+aiosqlite:///:memory:',\n        connect_args={'check_same_thread': False},\n        poolclass=StaticPool,\n    )\n    async with engine.begin() as conn: #(2)!\n        await conn.run_sync(table_registry.metadata.create_all) #(3)!\n\n    async with AsyncSession(engine, expire_on_commit=False) as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(table_registry.metadata.drop_all)\n</code></pre> <ol> <li><code>@pytest_asyncio.fixture</code> serve para marcar a fun\u00e7\u00e3o como uma fixture ass\u00edncrona que o pytest pode usar. Com essa anota\u00e7\u00e3o, o pytest-asyncio pode gerenciar fixtures que fazem opera\u00e7\u00f5es ass\u00edncronas, como interagir com o banco de dados. Quando utilizamos o pytest_asyncio.fixture, o pytest sabe que a fun\u00e7\u00e3o \u00e9 ass\u00edncrona e precisa ser aguardada (await). Essa fixture pode ser usada como uma depend\u00eancia dentro dos testes, facilitando a configura\u00e7\u00e3o do ambiente de testes de forma eficiente.</li> <li>O m\u00e9todo begin() do engine \u00e9 usado para iniciar uma transa\u00e7\u00e3o no banco de dados. O engine cria uma conex\u00e3o ass\u00edncrona e, ao usar begin(), estamos dizendo ao SQLAlchemy para iniciar uma transa\u00e7\u00e3o dentro do contexto de execu\u00e7\u00e3o ass\u00edncrona. Ele \u00e9 necess\u00e1rio para que possamos executar opera\u00e7\u00f5es no banco de dados de forma eficiente e transacional.</li> <li>O run_sync \u00e9 uma forma de rodar c\u00f3digo s\u00edncrono dentro de um ambiente ass\u00edncrono. No caso do SQLAlchemy, ele \u00e9 usado para executar opera\u00e7\u00f5es que n\u00e3o s\u00e3o ass\u00edncronas (como a cria\u00e7\u00e3o de tabelas) enquanto ainda estamos dentro do loop de eventos ass\u00edncrono.</li> </ol> <p>Para que a fixture seja declarada como ass\u00edncrona, precisamos import\u00e1-la do <code>pytest_asyncio</code> e fazer a declara\u00e7\u00e3o com <code>@pytest_asyncio.fixture</code>. Tamb\u00e9m devemos alterar a engine para o formato async.</p> <p>Uma altera\u00e7\u00e3o substancial no c\u00f3digo \u00e9 a forma em que criamos nossas tabelas usando os metadados:</p> Peda\u00e7o do bloco anterior<pre><code>async with engine.begin() as conn:\n    await conn.run_sync(table_registry.metadata.create_all)\n</code></pre> <p>Aqui, <code>engine.begin()</code> inicia uma transa\u00e7\u00e3o ass\u00edncrona com o banco de dados. Dentro dessa transa\u00e7\u00e3o, usamos o run_sync para executar a cria\u00e7\u00e3o das tabelas, uma opera\u00e7\u00e3o s\u00edncrona por natureza. Esse processo assegura que a cria\u00e7\u00e3o das tabelas ocorra de forma n\u00e3o bloqueante, permitindo que o loop de eventos continue a processar outras tarefas ass\u00edncronas enquanto essa opera\u00e7\u00e3o \u00e9 realizada.</p> <p>Em resumo, o uso de <code>run_sync</code> em uma opera\u00e7\u00e3o ass\u00edncrona \u00e9 uma estrat\u00e9gia importante para integrar opera\u00e7\u00f5es tradicionais s\u00edncronas com a arquitetura ass\u00edncrona do Python, garantindo que a performance e escalabilidade do sistema sejam preservadas.</p>"},{"location":"08/#ajustando-o-teste-do-banco-de-dados","title":"Ajustando o teste do banco de dados","text":"<p>Agora que temos as fixtures preparadas para serem executadas no contexto ass\u00edncrono, podemos iniciar nossa jornada em dire\u00e7\u00e3o aos testes, performando opera\u00e7\u00f5es ass\u00edncronas.</p> <p>Vamos iniciar fazendo com que o nosso teste inicial do banco de dados seja n\u00e3o bloqueante:</p> tests/test_db.py<pre><code>from dataclasses import asdict\n\nimport pytest\nfrom sqlalchemy import select\n\nfrom fast_zero.models import User\n\n\n@pytest.mark.asyncio #(1)!\nasync def test_create_user(session, mock_db_time):\n    with mock_db_time(model=User) as time:\n        new_user = User(\n            username='alice', password='secret', email='teste@test'\n        )\n        session.add(new_user)\n        await session.commit() #(2)!\n\n    user = await session.scalar(select(User).where(User.username == 'alice')) #(3)!\n\n    assert asdict(user) == {\n        'id': 1,\n        'username': 'alice',\n        'password': 'secret',\n        'email': 'teste@test',\n        'created_at': time,\n    }\n</code></pre> <ol> <li>Essa marca\u00e7\u00e3o, diz ao pytest que esse teste cont\u00e9m c\u00f3digo ass\u00edncrono</li> <li>Como <code>.commit</code> faz uma chamada ao banco de dados \u00e9 categorizada como I/O. Logo, essa chamada pode escalonar o async, ent\u00e3o usamos <code>await</code></li> <li>Outra chamada que depende de I/O, a chamada no banco espera a consulta ser conclu\u00edda, logo, tamb\u00e9m usamos <code>await</code>.</li> </ol> <p>Testes tamb\u00e9m podem ser corrotinas ass\u00edncronas, por\u00e9m o pytest n\u00e3o os executa em um loop de eventos. Para isso ser feito, temos que indicar que um determinado teste \u00e9 ass\u00edncrono. Para isso, usamos a marca\u00e7\u00e3o <code>@pytest.mark.asyncio</code>.</p> <p>Com isso feito, podemos adicionar <code>await</code> em todas as chamadas diretas ao banco de dados que apresentam bloqueios, como:</p> <ul> <li><code>session.commit()</code>: Que persiste os dados que est\u00e3o na sess\u00e3o, fazendo uma chamada ao banco de dados.</li> <li><code>session.scalar()</code>: Que pede uma busca de dados ao banco e aguarda o seu resultado.</li> </ul> <p>Isso deve ser o suficiente para o teste ser executado com sucesso:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_db.py\n\n# ...\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Agora que temos certeza de que o banco e as fixtures est\u00e3o funcionando. Podemos passar \u00e0 refatora\u00e7\u00e3o do projeto de fato.</p>"},{"location":"08/#tecnica-de-refatoracao-usando-testes","title":"T\u00e9cnica de refatora\u00e7\u00e3o usando testes","text":"<p>Uma das grandes vantagens de termos uma boa cobertura de testes \u00e9 que podemos fazer mudan\u00e7as estruturais no projeto e garantir que tudo funcione da forma como j\u00e1 estava antes. Os testes nos trazem uma seguran\u00e7a para que tudo possa mudar internamente sem alterar os resultados da API. Para isso, a estrat\u00e9gia que vamos usar aqui \u00e9 a de caminhar executando um teste por vez.</p> <p>Uma das funcionalidades legais do <code>pytest</code> \u00e9 poder executar somente um \u00fanico teste, ou um grupo deles, usando o nome do teste como base. Para isso, podemos chamar <code>task test</code> passando a flag <code>-k</code> seguida do nome do teste. Algo como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_create_user\n\n# ...\ntests/test_users.py::test_create_user FAILED\n</code></pre> <p>Para cada teste que falhar, vamos nos organizando para fazer a convers\u00e3o do c\u00f3digo para ass\u00edncrono.</p> <p>Para listar todos os testes presentes no nosso projeto, podemos usar a flag <code>--collect-only</code> do pytest:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test --collect-only\n</code></pre> <p>Que nos retornar\u00e1 algo parecido com isso:</p> Sa\u00edda do --colect-pnly<pre><code>&lt;Dir fast_zero&gt;\n  &lt;Package tests&gt;\n    &lt;Module test_app.py&gt;\n      &lt;Function test_root_deve_retornar_ok_e_ola_mundo&gt;\n    &lt;Module test_auth.py&gt;\n      &lt;Function test_get_token&gt;\n    &lt;Module test_db.py&gt;\n      &lt;Coroutine test_create_user&gt;\n    &lt;Module test_security.py&gt;\n      &lt;Function test_jwt&gt;\n      &lt;Function test_jwt_invalid_token&gt;\n    &lt;Module test_users.py&gt;\n      &lt;Function test_create_user&gt;\n      &lt;Function test_read_users&gt;\n      &lt;Function test_read_users_with_users&gt;\n      &lt;Function test_update_user&gt;\n      &lt;Function test_update_integrity_error&gt;\n      &lt;Function test_delete_user&gt;\n</code></pre> <p>Onde <code>Module</code> \u00e9 o nome do arquivo com os testes e <code>Function</code> \u00e9 o nome da fun\u00e7\u00e3o de testes. Note que o teste do banco de dados que j\u00e1 alteramos para teste a fixture de session tem outro nome <code>Coroutine</code>, pois j\u00e1 est\u00e1 no estado ass\u00edncrono.</p>"},{"location":"08/#endpoints-nao-bloqueantes","title":"Endpoints n\u00e3o bloqueantes","text":"<p>Para que os endpoints n\u00e3o sejam bloqueantes, a primeira coisa a se fazer \u00e9 adicionar a palavra reservada <code>async</code> no in\u00edcio de todos eles.</p>"},{"location":"08/#router-auth","title":"Router <code>auth</code>","text":"<p>Acredito que come\u00e7ar pelo router <code>auth</code> pode ser menos assustador, j\u00e1 que at\u00e9 o momento ele tem somente um endpoint (<code>login_for_access_token</code>) e um teste (<code>test_get_token</code>).</p> <p>Vamos iniciar executando o teste e coletando o que est\u00e1 acontecendo de errado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_get_token\n# ...\nFAILED tests/test_auth.py::test_get_token - AttributeError: 'coroutine' object has no attribute 'password'\n</code></pre> <p>Esse erro \u00e9 interessante, pois o que ele notifica \u00e9 que um objeto corrotina n\u00e3o tem o atributo password. Precisamos analisar o c\u00f3digo para entender em qual o objeto est\u00e1 buscando password:</p> fast_zero/routers/auth.py<pre><code>@router.post('/token', response_model=Token)\ndef login_for_access_token(form_data: OAuth2Form, session: Session):\n    user = session.scalar(select(User).where(User.email == form_data.username))\n\n    # ...\n\n    if not verify_password(form_data.password, user.password):\n    # ...\n</code></pre> <p>Nesse bloco de c\u00f3digo, podemos ver que existe uma chamada de banco de dados em <code>session.scalar</code>. Devemos lembrar que todas essas chamadas, com a transforma\u00e7\u00e3o da sess\u00e3o em ass\u00edncrona, precisam ter sua resposta aguardada pelo loop de eventos, logo ele deve ter <code>await</code>. E para podermos usar <code>await</code> a fun\u00e7\u00e3o deve ser uma corrotina definida com a palavra <code>async</code>:</p> fast_zero/routers/auth.py<pre><code>@router.post('/token', response_model=Token)\nasync def login_for_access_token(form_data: OAuth2Form, session: Session):\n    user = await session.scalar(\n        select(User).where(User.email == form_data.username)\n    )\n\n    # ...\n</code></pre> <p>Essa simples altera\u00e7\u00e3o j\u00e1 deve ser o suficiente para o c\u00f3digo passar no teste:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_get_token\n\n# ...\n\ntests/test_auth.py::test_get_token /home/dunossauro/07/tests/conftest.py:75: RuntimeWarning: coroutine 'AsyncSession.commit' was never awaited\n  session.commit()\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\n/home/dunossauro/07/tests/conftest.py:76: RuntimeWarning: coroutine 'AsyncSession.refresh' was never awaited\n  session.refresh(user)\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\nPASSED\n</code></pre> <p>De fato, o teste obteve <code>PASSED</code>, por\u00e9m ao usar a fixture <code>user</code> no teste:</p> tests/test_auth.py<pre><code>def test_get_token(client, user):\n    # ...\n</code></pre> <p>E ela n\u00e3o estar preparada para ser ass\u00edncrona, obtivemos <code>RuntimeWarning: coroutine 'AsyncSession.commit' was never awaited</code>. Dizendo que a instru\u00e7\u00e3o de <code>commit</code>, nunca foi aguardada. Podemos corrigir isso:</p> tests/confitest.py<pre><code>@pytest_asyncio.fixture #(1)!\nasync def user(session):\n    password = 'testtest'\n    user = User(\n        username='Teste',\n        email='teste@test.com',\n        password=get_password_hash(password),\n    )\n    session.add(user)\n    await session.commit()\n    await session.refresh(user)\n\n    user.clean_password = password\n\n    return user\n</code></pre> <ol> <li>Tamb\u00e9m recebe a fixture de <code>pytest_asyncio</code>.</li> </ol> <p>Como temos duas intera\u00e7\u00f5es de I/O com o banco nesse fixture <code>.commit</code> e <code>.refresh</code>, devemos aguardar as duas.</p> <p>Desta forma, devemos ter um teste passando com sucesso e sem avisos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_get_token\n# ...\ntests/test_auth.py::test_get_token PASSED\n</code></pre> <p>Embora o comportamento do c\u00f3digo esteja correto e sem nenhum problema aparente. Precisamos corrigir o tipo usado para inje\u00e7\u00e3o de depen\u00eancias que n\u00e3o \u00e9 mais <code>Session</code>, mas <code>AsyncSession</code>:</p> fast_zero/routers/auth.py<pre><code># ...\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n# ...\n\nOAuth2Form = Annotated[OAuth2PasswordRequestForm, Depends()]\nSession = Annotated[AsyncSession, Depends(get_session)]\n</code></pre> <p>Desta forma dizemos ao FastAPI que <code>get_session</code> retorna uma <code>AsyncSession</code>.</p>"},{"location":"08/#router-users","title":"Router <code>users</code>","text":"<p>Seguindo para o router de <code>users</code>, sabemos que aqui teremos um pouco mais de trabalho. Pois temos muitos testes e tamb\u00e9m diversos endpoits.</p>"},{"location":"08/#o-cabecalho","title":"O cabe\u00e7alho","text":"<p>Mas, antes de tudo, j\u00e1 que acabamos de fazer isso, vamos come\u00e7ar pelo cabe\u00e7alho do arquivo. Ajustando a tipagem:</p> fast_zero/routers/users.py<pre><code># ...\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n# ...\n\nSession = Annotated[AsyncSession, Depends(get_session)]\n\n# ...\n</code></pre>"},{"location":"08/#endpoint-de-post","title":"Endpoint de POST","text":"<p>Vamos come\u00e7ar pelo teste <code>test_create_user</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_create_user\n# ...\nFAILED tests/test_users.py::test_create_user - AttributeError: 'coroutine' object has no attribute 'username'\n</code></pre> <p>Temos o mesmo problema das corrotinas. Ent\u00e3o vamos adicionar <code>async</code> e <code>await</code> no nosso endpoint:</p> fast_zero/routers/users.py<pre><code>@router.post('/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\nasync def create_user(user: UserSchema, session: Session):\n    db_user = await session.scalar(\n        select(User).where(\n            (User.username == user.username) | (User.email == user.email)\n        )\n    )\n    # ...\n    session.add(db_user)\n    await session.commit()\n    await session.refresh(db_user)\n\n    return db_user\n</code></pre> <p>Dessa forma, j\u00e1 podemos executar os testes com sucesso:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_create_user\n# ...\ntests/test_users.py::test_create_user PASSED\n</code></pre>"},{"location":"08/#endpoint-de-get","title":"Endpoint de GET","text":"<p>Para o endpoint de get, temos dois testes, chegou a hora de aprender mais um truque da flag <code>-k</code> do pytest. Usando um peda\u00e7o do nome do teste, podemos selecionar todos que t\u00eam parte desse nome. Algo como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_read\n</code></pre> <p>Deve ser capaz de executar os testes <code>test_read_users</code> e tamb\u00e9m <code>test_read_users_with_users</code>.</p> <p>N\u00e3o temos, no entanto, um resultado favor\u00e1vel:</p> resposta de task test -k test_read<pre><code>FAILED tests/test_users.py::test_read_users - AttributeError: 'coroutine' object has no attribute 'all'\n</code></pre> <p>Embora esse erro seja quase que id\u00eantico ao que obtivemos at\u00e9 agora, por falta de <code>await</code>. A forma como o c\u00f3digo est\u00e1 escrita depende de um fator um pouco diferente de refatora\u00e7\u00e3o. Vamos olhar o estado atual do c\u00f3digo com aten\u00e7\u00e3o:</p> fast_zero/routers/users.py<pre><code>@router.get('/', response_model=UserList)\ndef read_users(session: Session, filter_users: Annotated[FilterPage, Query()]):\n    users = session.scalars(\n        select(User).offset(filter_users.offset).limit(filter_users.limit)\n    ).all()\n</code></pre> <p>Usamos o resultado de <code>session.scalars</code> e concatenamos o m\u00e9todo <code>.all()</code>. A transforma\u00e7\u00e3o dessa chamada em ass\u00edncrona demandar\u00e1 a separa\u00e7\u00e3o do <code>scalars</code> do m\u00e9todo <code>all</code>. Desta forma:</p> fast_zero/routers/users.py<pre><code>@router.get('/', response_model=UserList)\nasync def read_users(\n    session: Session, filter_users: Annotated[FilterPage, Query()]\n):\n    query = await session.scalars(\n        select(User).offset(filter_users.offset).limit(filter_users.limit)\n    )\n    users = query.all()\n\n    return {'users': users}\n</code></pre> <p>Pois precisamos obter o resultado de <code>await</code> antes de chamar o m\u00e9todo <code>.all()</code>.</p> <p>Dessa forma, temos os dois testes envolvendo GET passando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_read\n# ...\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\n</code></pre>"},{"location":"08/#endpoint-de-put","title":"Endpoint de PUT","text":"<p>Tamb\u00e9m temos mais de um teste envolvendo o PUT e ambos t\u00eam o mesmo prefixo, dessa forma podemos executar os dois em conjunto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_update\n# ...\nFAILED tests/test_users.py::test_update_user - AttributeError: 'coroutine' object has no attribute 'id'\n</code></pre> <p>\"Para surpresa de zero pessoas\", temos os problemas de corrotinas que vamos arrumar agora, mas, se olharmos com aten\u00e7\u00e3o, o erro ainda n\u00e3o est\u00e1 no endpoint:</p> parte da mensagem de erro<pre><code>    @router.put('/{user_id}', response_model=UserPublic)\n    async def update_user(\n        user_id: int,\n        user: UserSchema,\n        session: Session,\n        current_user: CurrentUser,\n    ):\n&gt;       if current_user.id != user_id:\nE       AttributeError: 'coroutine' object has no attribute 'id'\n</code></pre> <p>Ele vem de <code>current_user</code>, que chama a fun\u00e7\u00e3o <code>get_current_user</code> em <code>fast_zero/security.py</code>.</p>"},{"location":"08/#ajustando-securitypy","title":"Ajustando security.py","text":"<p>No momento em que checamos os tokens para validar quem \u00e9 o usu\u00e1rio corrente existem chamadas para o banco de dados tamb\u00e9m:</p> fast_zero/security.py<pre><code>def get_current_user(\n    session: Session = Depends(get_session),\n    token: str = Depends(oauth2_scheme),\n):\n    # ...\n    user = session.scalar(select(User).where(User.email == subject_email))\n    # ...\n</code></pre> <p>Aqui temos o problema da <code>Session</code> n\u00e3o ser tipada como <code>AsyncSession</code> e de n\u00e3o existir <code>await</code> para a busca no banco de dados. Podemos resolver dessa forma:</p> fast_zero/security.py<pre><code># ...\nfrom sqlalchemy.ext.asyncio import AsyncSession\n# ...\n\nasync def get_current_user(\n    session: AsyncSession = Depends(get_session),\n    token: str = Depends(oauth2_scheme),\n):\n    # ...\n    user = await session.scalar(\n        select(User).where(User.email == subject_email)\n    )\n    # ...\n</code></pre> <p>Agora podemos voltar aos testes</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_update\n# ...\ntests/test_users.py::test_update_user /home/dunossauro/07/fast_zero/routers/users.py:91: RuntimeWarning: coroutine 'AsyncSession.commit' was never awaited\n  session.commit()\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\n/home/dunossauro/07/fast_zero/routers/users.py:92: RuntimeWarning: coroutine 'AsyncSession.refresh' was never awaited\n  session.refresh(current_user)\nRuntimeWarning: Enable tracemalloc to get the object allocation traceback\nPASSED\n</code></pre> <p>Embora <code>test_update_user</code> passe, ele levanta os warnings de corrotinas que nunca foram aguardadas. Ent\u00e3o, voltemos ao PUT.</p>"},{"location":"08/#de-volta-ao-put","title":"De volta ao PUT","text":"<p>Como j\u00e1 \u00e9 de se imaginar, a corre\u00e7\u00e3o \u00e9 transformar nosso endpoint em <code>async</code> e adicionar <code>await</code> nas chamadas do SQLAlchemy:</p> fast_zero/routers/users.py<pre><code>@router.put('/{user_id}', response_model=UserPublic)\nasync def update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session,\n    current_user: CurrentUser,\n):\n    # ...\n    try:\n        current_user.username = user.username\n        current_user.password = get_password_hash(user.password)\n        current_user.email = user.email\n        await session.commit()\n        await session.refresh(current_user)\n\n        return current_user\n    # ...\n</code></pre> <p>Desta forma temos os testes passando de volta:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_update\n# ...\n\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\n</code></pre>"},{"location":"08/#endpoint-de-delete","title":"Endpoint de delete","text":"<p>Como agora s\u00f3 temos o <code>delete</code> para arrumar, vamos fazer invertido, ajustas as chamadas e depois rodar os testes:</p> fast_zero/routers/users.py<pre><code>@router.delete('/{user_id}', response_model=Message)\nasync def delete_user(\n    user_id: int,\n    session: Session,\n    current_user: CurrentUser,\n):\n    # ...\n    await session.delete(current_user)\n    await session.commit()\n</code></pre> <p>Executando o teste para ver se tudo ocorre bem:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k test_delete\n# ...\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Pra finalizar, gostaria de executar todos os testes. Para garantir que todo o projeto est\u00e1 funcionando como deveria de maneira ass\u00edncrona:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_security.py::test_jwt PASSED\ntests/test_security.py::test_jwt_invalid_token PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Com isso temos todos os endpoints funcionando de forma correta e ass\u00edncrona!</p>"},{"location":"08/#cobertura-de-testes-assincrona","title":"Cobertura de testes ass\u00edncrona","text":"<p>Como o fluxo de execu\u00e7\u00e3o deixa de ser linear, algumas coisas costumam aparecer n\u00e3o cobertas, mesmo quando executadas. Se voc\u00ea prestou aten\u00e7\u00e3o durante a execu\u00e7\u00e3o dos testes, parece que temos coisas substancialmente erradas:</p> <p></p> <p>Um exemplo disso \u00e9 o endpoint GET, devidamente testado, mas ao olhar a cobertura:</p> <p></p> <p>Todo o c\u00f3digo executado ap\u00f3s o <code>await</code> \u00e9 mostrado como n\u00e3o coberto, pois no momento do escalonamento o coverage n\u00e3o estava configurado para lidar concorr\u00eancia.</p> <p>A solu\u00e7\u00e3o para isso \u00e9 dizer ao coverage que nosso c\u00f3digo usa determinado tipo de concorr\u00eancia. Como, por exemplo:</p> pyproject.toml<pre><code>[tool.coverage.run]\ncore = \"ctrace\"#(1)!\nconcurrency = [\"thread\", \"greenlet\"]\n</code></pre> <ol> <li>Existem diversas formas de executar o coverage. O <code>sysmon</code> \u00e9 o runner padr\u00e3o, mas atualmente ele n\u00e3o suporta o greenlet. Fonte para se aprofundar mais.</li> </ol> <p>Precisamos ativar a concorr\u00eancia no coverage em dois casos, para threads (conversamos sobre isso na aula 05) e para o greenlet adicionado pela conex\u00e3o ass\u00edncrona do SQLAlchemy.</p> <p>Com essa pequena altera\u00e7\u00e3o, podemos executar os testes novamente e olhar a cobertura:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# ...\n</code></pre> <p>Assim, voltamos aos 93% que t\u00ednamos antes desta aula:</p> <p></p>"},{"location":"08/#migracoes-assincronas","title":"Migra\u00e7\u00f5es ass\u00edncronas","text":"<p>As migra\u00e7\u00f5es com alembic em teoria devem ser sempre s\u00edncronas. Afinal, voc\u00ea n\u00e3o gostaria que ele fizesse escalonamento na hora de aplicar as migra\u00e7\u00f5es e aplicasse um peda\u00e7o de cada em peda\u00e7os diferentes de migra\u00e7\u00f5es de arquivos diferentes.</p> <p>Mas, o problema surge quando temos uma URL de conex\u00e3o ass\u00edncrona. Ao tentar aplicar as migra\u00e7\u00f5es, teremos um erro como esse:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\n# ...\nsqlalchemy.exc.MissingGreenlet: greenlet_spawn has not been called; can't call await_only() here. Was IO attempted in an unexpected place? (Background on this error at: https://sqlalche.me/e/20/xd2s)\n</code></pre> <p>Isso acontece, pois agora estamos usando uma forma ass\u00edncrona do sqlite, quando adicionamos \"+aiosqlite\" na vari\u00e1vel de ambiente <code>DATABASE_URL</code>.</p> <p>Por conta desses dois motivos, agora precisamos fazer com que as migra\u00e7\u00f5es sejam executadas de forma s\u00edncrona, contudo a engine deve ser ass\u00edncrona:</p> fast_zero/migration/env.py<pre><code>import asyncio\n\nfrom logging.config import fileConfig\n\nfrom sqlalchemy.ext.asyncio import async_engine_from_config #(1)!\nfrom sqlalchemy import pool\n\ndef do_run_migrations(connection): #(2)!\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_async_migrations(): #(3)!\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\ndef run_migrations_online(): #(4)!\n    asyncio.run(run_async_migrations())\n\n\nif context.is_offline_mode():\n    # ...\n</code></pre> <ol> <li>Essa linha ser\u00e1 alterada. A linha com <code>engine_from_config</code> ser\u00e1 deletada e ser\u00e1 substitu\u00edda por <code>async_engine_from_config</code>.</li> <li>Essa fun\u00e7\u00e3o ser\u00e1 criada, ela n\u00e3o existia na migra\u00e7\u00e3o. Essa Fun\u00e7\u00e3o ser\u00e1 usada para criar a migra\u00e7\u00e3o. Como o conector do sqlalchemy suporta executar somente fun\u00e7\u00f5es de forma s\u00edncrona, separamos a efetividade da migra\u00e7\u00e3o na fun\u00e7\u00e3o <code>do_run_migrations</code>.</li> <li>Essa fun\u00e7\u00e3o ser\u00e1 criada, ela n\u00e3o existia na migra\u00e7\u00e3o. Fun\u00e7\u00e3o que efetivamente cria a engine de forma ass\u00edncrona e executa a migra\u00e7\u00e3o de forma s\u00edncrona chamando <code>do_run_migrations</code>.</li> <li>Essa fun\u00e7\u00e3o ser\u00e1 alterada. Como o alembic por padr\u00e3o n\u00e3o executa opera\u00e7\u00f5es async, precisamos fazer com que ela chame o <code>asyncio.run</code>.</li> </ol> <p>A fun\u00e7\u00e3o principal <code>run_migrations_online</code> \u00e9 executada pelo alembic, ent\u00e3o ela n\u00e3o pode ser alterada para uma corrotina. Ent\u00e3o motamos <code>run_async_migrations</code> para criar a conex\u00e3o ass\u00edncrona e executar no modo s\u00edncrono as migra\u00e7\u00f5es carregadas por <code>do_run_migrations</code>.</p> <p>Com isso, as migra\u00e7\u00f5es devem ser executadas em erros:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\n</code></pre> <p>Desta forma, continuamos executando as migra\u00e7\u00f5es de forma s\u00edncrona, mas com uma engine de conex\u00e3o ass\u00edncrono.</p>"},{"location":"08/#commit","title":"Commit","text":"<p>Para finalizar, criaremos um commit para registrar todas as altera\u00e7\u00f5es que fizemos na nossa aplica\u00e7\u00e3o. Como essa \u00e9 uma grande mudan\u00e7a que envolve reestruturar como lidamos com as rotas e mover as constantes para vari\u00e1veis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais altera\u00e7\u00f5es:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Refatorando estrutura do projeto: Suporte a asyncio, tornando o projeto n\u00e3o bloqueante\"\n</code></pre>"},{"location":"08/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Na pr\u00f3xima aula, vamos adicionar randomiza\u00e7\u00e3o em testes para facilitar a cria\u00e7\u00e3o dos dados de teste. Caso n\u00e3o conhe\u00e7a o Faker ou Factory-boy, pode ser uma boa para entender melhor a pr\u00f3xima aula:</p> <ul> <li>Randomiza\u00e7\u00e3o de dados em testes unit\u00e1rios com Faker e Factory-boy | Live de Python #281</li> </ul>"},{"location":"08/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Reveja os endpoints criados por voc\u00ea em exerc\u00edcios anteriores e adicione <code>async</code> e <code>await</code> para que eles se tornem n\u00e3o bloqueantes tamb\u00e9m.</li> <li>Altere o endpoint <code>read_root</code> para suportar <code>asyncio</code>.</li> </ol>"},{"location":"08/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula passamos por uma grande refatora\u00e7\u00e3o no sistema ao fazer com que todo o nosso projeto possa ser executado de forma n\u00e3o bloqueante. Essas altera\u00e7\u00f5es aproveitam melhor os recursos computacionais e tamb\u00e9m aumentam a disponibilidade em responder novas requisi\u00e7\u00f5es enquanto outras est\u00e3o sendo processadas.</p> <p>Embora a adi\u00e7\u00e3o do <code>asyncio</code> no projeto pare\u00e7a complicada no in\u00edcio, os benef\u00edcios dessa migra\u00e7\u00e3o acabam se pagando em custo da disponibilidade na web. Atendendo mais requisi\u00e7\u00f5es com os mesmos recursos.</p>"},{"location":"09/","title":"Tornando o sistema de autentica\u00e7\u00e3o robusto","text":""},{"location":"09/#tornando-o-sistema-de-autenticacao-robusto","title":"Tornando o sistema de autentica\u00e7\u00e3o robusto","text":"<p>Objetivos da Aula:</p> <ul> <li>Testar os casos de autentica\u00e7\u00e3o de forma correta</li> <li>Implementar o refresh do token</li> <li>Introduzir testes que param o tempo com <code>freezegun</code></li> <li>Introduzir gera\u00e7\u00e3o de modelos autom\u00e1tica com <code>factory-boy</code></li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Em nossas aulas anteriores, abordamos os fundamentos de um sistema de autentica\u00e7\u00e3o, mas existem diversas maneiras de aprimor\u00e1-lo para que ele se torne mais robusto e seguro. Nessa aula, enfrentaremos perguntas importantes, como: Como lidar com falhas e erros? Como garantir a seguran\u00e7a do sistema mesmo em cen\u00e1rios desafiadores? Estas s\u00e3o algumas das quest\u00f5es-chave que exploraremos.</p> <p>Come\u00e7aremos com uma an\u00e1lise detalhada dos testes de autentica\u00e7\u00e3o. At\u00e9 agora, concentramo-nos em cen\u00e1rios ideais, onde o usu\u00e1rio existe e as condi\u00e7\u00f5es s\u00e3o favor\u00e1veis. Contudo, \u00e9 essencial testar tamb\u00e9m as situa\u00e7\u00f5es adversas e compreender como o sistema responde a falhas. Vamos, portanto, aprender a realizar testes eficazes para esses casos negativos.</p> <p>Depois, passaremos para a implementa\u00e7\u00e3o de um elemento crucial em qualquer sistema de autentica\u00e7\u00e3o: a renova\u00e7\u00e3o do token. Esse mecanismo \u00e9 imprescind\u00edvel para manter a sess\u00e3o do usu\u00e1rio ativa e segura, mesmo quando o token original expira.</p>"},{"location":"09/#testes-para-autenticacao","title":"Testes para autentica\u00e7\u00e3o","text":"<p>Antes de mergulharmos nos testes, conversaremos um pouco sobre por que eles s\u00e3o t\u00e3o importantes. Na programa\u00e7\u00e3o, \u00e9 f\u00e1cil cair na armadilha de pensar que, se algo funciona na maioria das vezes, ent\u00e3o est\u00e1 tudo bem. Mas a verdade \u00e9 que \u00e9 nos casos marginais que os bugs mais dif\u00edceis de encontrar e corrigir costumam se esconder.</p> <p>Por exemplo, o que acontece se tentarmos autenticar um usu\u00e1rio que n\u00e3o existe? Ou se tentarmos autenticar com as credenciais erradas? Se n\u00e3o testarmos esses cen\u00e1rios, podemos acabar com um sistema que parece funcionar na superf\u00edcie, mas que, na verdade, est\u00e1 cheio de falhas de seguran\u00e7a.</p> <p></p> <p>No c\u00f3digo apresentado, se observarmos atentamente, vemos que o erro <code>HTTPException(status_code=HTTPStatus.FORBIDDEN, detail='Not enough permissions')</code> em <code>users.py</code> na rota <code>/{user_id}</code> n\u00e3o est\u00e1 sendo coberto por nossos testes. Essa exce\u00e7\u00e3o \u00e9 lan\u00e7ada quando um usu\u00e1rio n\u00e3o autenticado ou um usu\u00e1rio sem permiss\u00f5es adequadas tenta acessar, ou alterar um recurso que n\u00e3o deveria.</p> <p>Essa lacuna em nossos testes representa um risco potencial, pois n\u00e3o estamos verificando como nosso sistema se comporta quando algu\u00e9m tenta, por exemplo, alterar os detalhes de um usu\u00e1rio sem ter permiss\u00f5es adequadas. Embora possamos assumir que nosso sistema se comportar\u00e1 corretamente, a falta de testes nos deixa sem uma confirma\u00e7\u00e3o concreta.</p>"},{"location":"09/#testando-a-alteracao-de-um-usuario-nao-autorizado","title":"Testando a altera\u00e7\u00e3o de um usu\u00e1rio n\u00e3o autorizado","text":"<p>Agora, escreveremos alguns testes para esses casos. Vamos come\u00e7ar com um cen\u00e1rio simples: o que acontece quando um usu\u00e1rio tenta alterar as informa\u00e7\u00f5es de outro usu\u00e1rio?</p> <p>Para testar isso, criaremos um novo teste chamado test_update_user_with_wrong_user.</p> <p></p>tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id + 1}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.FORBIDDEN\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> Este teste vai simular um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um erro.<p></p>"},{"location":"09/#criando-modelos-por-demanda-com-factory-boy","title":"Criando modelos por demanda com factory-boy","text":"<p>Embora o teste que escrevemos esteja tecnicamente correto, ele ainda n\u00e3o funcionar\u00e1 adequadamente porque, atualmente, s\u00f3 temos um usu\u00e1rio em nosso banco de dados de testes. Precisamos de uma maneira de criar m\u00faltiplos usu\u00e1rios de teste facilmente, e \u00e9 a\u00ed que entra o <code>factory-boy</code>.</p> Caso nunca tenha usado o factory-boy <p>Temos uma live de python focada nos problemas que o factory-boy pode resolver e mostrar seus usos b\u00e1sicos:</p> <p></p> <p>O <code>factory-boy</code> \u00e9 uma biblioteca que nos permite criar objetos de modelo de teste de forma r\u00e1pida e f\u00e1cil. Com ele, podemos criar uma \"f\u00e1brica\"<sup>1</sup> de usu\u00e1rios que produzir\u00e1 novos objetos de usu\u00e1rio sempre que precisarmos. Isso nos permite criar m\u00faltiplos usu\u00e1rios de teste com facilidade, o que \u00e9 perfeito para nosso cen\u00e1rio atual.</p> <p>Para come\u00e7ar, precisamos instalar o <code>factory-boy</code> em nosso ambiente de desenvolvimento:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev factory-boy\n</code></pre> <p>Ap\u00f3s instalar o <code>factory-boy</code>, podemos criar uma <code>UserFactory</code>. Esta f\u00e1brica ser\u00e1 respons\u00e1vel por criar novos objetos de usu\u00e1rio sempre que precisarmos de um para nossos testes. A estrutura da f\u00e1brica ser\u00e1 a seguinte:</p> tests/conftest.py<pre><code>import factory\n\n# ...\n\nclass UserFactory(factory.Factory):\n    class Meta:\n        model = User  #(1)!\n\n    username = factory.Sequence(lambda n: f'test{n}')\n    email = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')\n    password = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')\n</code></pre> <ol> <li>A classe de model, \u00e9 a classe que ser\u00e1 retornada pela f\u00e1brica. Nesse caso <code>User</code>.</li> </ol> <p>Explicando linha a linha, esse c\u00f3digo faz o seguinte:</p> <ul> <li><code>class UserFactory(factory.Factory):</code> define uma f\u00e1brica para o modelo <code>User</code>, herdando de <code>factory.Factory</code>.</li> <li><code>class Meta:</code> uma classe interna <code>Meta</code> \u00e9 usada para configurar a f\u00e1brica.</li> <li><code>model = User</code>: define o modelo para o qual a f\u00e1brica est\u00e1 construindo inst\u00e2ncias. No caso, estamos referenciando a classe <code>User</code>, que deve ser um modelo de banco de dados, como o SQLAlchemy.</li> <li><code>username = factory.Sequence(lambda n: f'test{n}')</code>: define um campo <code>username</code> que recebe uma sequ\u00eancia. A cada chamada da f\u00e1brica, o valor <code>n</code> \u00e9 incrementado, ent\u00e3o cada inst\u00e2ncia gerada ter\u00e1 um <code>username</code> \u00fanico. Usando a string <code>'test{n}'</code>.</li> <li><code>email = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')</code>: define o campo <code>email</code> gerado a partir do <code>username</code>.</li> <li><code>password = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')</code>: define o campo <code>password</code> similar ao campo <code>email</code>.</li> </ul> <p>Essa f\u00e1brica pode ser usada em testes para criar inst\u00e2ncias de <code>User</code> com dados predefinidos, facilitando a escrita de testes que requerem a presen\u00e7a de usu\u00e1rios no banco de dados. Isso \u00e9 extremamente \u00fatil ao escrever testes que requerem o estado pr\u00e9-configurado do banco de dados e ajuda a tornar os testes mais leg\u00edveis e manuten\u00edveis.</p> <p>A seguir, podemos usar essa nova f\u00e1brica para criar m\u00faltiplos usu\u00e1rios de teste. Para fazer isso, modificamos nossa fixture de usu\u00e1rio existente para usar a UserFactory. Assim, sempre que executarmos nossos testes, teremos usu\u00e1rios diferentes dispon\u00edveis.</p> tests/conftest.py<pre><code>@pytest_asyncio.fixture\nasync def user(session):\n    password = 'testtest'\n    user = UserFactory(password=get_password_hash(password))\n\n    session.add(user)\n    await session.commit()\n    await session.refresh(user)\n\n    user.clean_password = password\n\n    return user\n\n\n@pytest_asyncio.fixture\nasync def other_user(session):\n    password = 'testtest'\n    user = UserFactory(password=get_password_hash(password))\n\n    session.add(user)\n    await session.commit()\n    await session.refresh(user)\n\n    user.clean_password = password\n\n    return user\n</code></pre> <p>A cria\u00e7\u00e3o de outra fixture chamada <code>other_user</code> \u00e9 crucial para simular o cen\u00e1rio de um usu\u00e1rio tentando acessar ou modificar as informa\u00e7\u00f5es de outro usu\u00e1rio no sistema. Ao criar duas fixtures diferentes, <code>user</code> e <code>other_user</code>, podemos efetivamente simular dois usu\u00e1rios diferentes em nossos testes. Isso nos permite avaliar como nosso sistema reage quando um usu\u00e1rio tenta realizar uma a\u00e7\u00e3o n\u00e3o autorizada, como alterar as informa\u00e7\u00f5es de outro usu\u00e1rio.</p> <p>Um aspecto interessante no uso das f\u00e1bricas \u00e9 que, sempre que forem chamadas, elas retornar\u00e3o um novo <code>User</code>, pois estamos fixando apenas a senha. Dessa forma, cada chamada a essa f\u00e1brica de usu\u00e1rios retornar\u00e1 um <code>User</code> diferente, com base nos atributos \"lazy\" que usamos.</p> <p>Com essa nova configura\u00e7\u00e3o, podemos finalmente testar o cen\u00e1rio de um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. E como voc\u00ea pode ver, nossos testes passaram com sucesso, o que indica que nosso sistema est\u00e1 lidando corretamente com essa situa\u00e7\u00e3o.</p> tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, other_user, token):\n    response = client.put(\n        f'/users/{other_user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.FORBIDDEN\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Neste caso, n\u00e3o estamos usando a fixture <code>user</code> porque queremos simular um cen\u00e1rio onde o usu\u00e1rio associado ao token (autenticado) est\u00e1 tentando realizar uma a\u00e7\u00e3o sobre outro usu\u00e1rio, representado pela fixture <code>other_user</code>. Ao usar a <code>other_user</code>, garantimos que o id do usu\u00e1rio que estamos tentando modificar ou deletar n\u00e3o seja o mesmo do usu\u00e1rio associado ao token, mas que ainda assim exista no banco de dados.</p> <p>Para enfatizar, a fixture <code>user</code> est\u00e1 sendo usada para representar o usu\u00e1rio que est\u00e1 autenticado atrav\u00e9s do token. Se us\u00e1ssemos a mesma fixture <code>user</code> neste teste, o sistema consideraria que a a\u00e7\u00e3o est\u00e1 sendo realizada pelo pr\u00f3prio usu\u00e1rio, o que n\u00e3o corresponderia ao cen\u00e1rio que queremos testar. Al\u00e9m disso, \u00e9 importante entender que o escopo das fixtures implica que, quando chamadas no mesmo teste, elas devem retornar o mesmo valor. Portanto, usar a <code>user</code> e <code>other_user</code> permite uma simula\u00e7\u00e3o mais precisa do comportamento desejado.</p> <p>Com o teste implementado, vamos execut\u00e1-lo para ver se nosso sistema est\u00e1 protegido contra essa a\u00e7\u00e3o indevida:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se todos os testes passaram com sucesso, isso indica que nosso sistema est\u00e1 se comportando como esperado, inclusive no caso de tentativas indevidas de deletar um usu\u00e1rio.</p>"},{"location":"09/#testando-o-delete-com-o-usuario-errado","title":"Testando o DELETE com o usu\u00e1rio errado","text":"<p>Continuando nossos testes, agora testaremos o que acontece quando tentamos deletar um usu\u00e1rio com um usu\u00e1rio errado.</p> <p>Talvez voc\u00ea esteja se perguntando, por que precisamos fazer isso? Bem, lembre-se de que a seguran\u00e7a \u00e9 uma parte crucial de qualquer sistema de autentica\u00e7\u00e3o. Precisamos garantir que um usu\u00e1rio n\u00e3o possa deletar a conta de outro usu\u00e1rio - apenas a pr\u00f3pria conta. Portanto, \u00e9 importante que testemos esse cen\u00e1rio para garantir que nosso sistema est\u00e1 seguro.</p> <p>Aqui est\u00e1 o teste que usaremos:</p> tests/test_users.py<pre><code>def test_delete_user_wrong_user(client, other_user, token):\n    response = client.delete(\n        f'/users/{other_user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == HTTPStatus.FORBIDDEN\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Como voc\u00ea pode ver, esse teste tenta deletar o user de um id diferente usando o token do user. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um status 401 com uma mensagem de erro indicando que o usu\u00e1rio n\u00e3o tem permiss\u00f5es suficientes para realizar essa a\u00e7\u00e3o.</p> <p>Vamos executar esse teste agora e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_users.py::test_delete_user_wrong_user PASSED\n</code></pre> <p>\u00d3timo, nosso teste passou! Isso significa que nosso sistema est\u00e1 corretamente impedindo um usu\u00e1rio de deletar a conta de outro usu\u00e1rio.</p> <p>Agora que terminamos de testar a autoriza\u00e7\u00e3o, passaremos para o pr\u00f3ximo desafio: testar tokens expirados. Lembre-se, em um sistema de autentica\u00e7\u00e3o robusto, um token deve expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Portanto, \u00e9 importante que testemos o que acontece quando tentamos usar um token expirado. Veremos isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"09/#testando-a-expiracao-do-token","title":"Testando a expira\u00e7\u00e3o do token","text":"<p>Continuando com nossos testes de autentica\u00e7\u00e3o, a pr\u00f3xima coisa que precisamos testar \u00e9 a expira\u00e7\u00e3o do token. Tokens de autentica\u00e7\u00e3o s\u00e3o normalmente projetados para expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Isso evita que algu\u00e9m que tenha obtido um token possa us\u00e1-lo indefinidamente se ele for roubado ou perdido. Portanto, \u00e9 importante que verifiquemos que nosso sistema esteja tratando corretamente a expira\u00e7\u00e3o dos tokens.</p> <p>Para realizar esse teste, usaremos uma biblioteca chamada <code>freezegun</code>. <code>freezegun</code>\u00e9 uma biblioteca Python que nos permite \"congelar\" o tempo em um ponto espec\u00edfico ou avan\u00e7\u00e1-lo conforme necess\u00e1rio durante os testes. Isso \u00e9 especialmente \u00fatil para testar funcionalidades sens\u00edveis ao tempo, como a expira\u00e7\u00e3o de tokens, sem ter que esperar em tempo real.</p> <p>Primeiro, precisamos instalar a biblioteca:</p> <pre><code>poetry add --group dev freezegun\n</code></pre> <p>Agora criaremos nosso teste. Come\u00e7aremos pegando um token para um usu\u00e1rio, congelando o tempo, esperando pelo tempo de expira\u00e7\u00e3o do token e, em seguida, tentando usar o token para acessar um endpoint que requer autentica\u00e7\u00e3o.</p> <p>Ao elaborarmos o teste, usaremos a funcionalidade de congelamento de tempo do <code>freezegun</code>. O objetivo \u00e9 simular a cria\u00e7\u00e3o de um token \u00e0s 12:00 e, em seguida, verificar sua expira\u00e7\u00e3o \u00e0s 12:31. Neste cen\u00e1rio, estamos utilizando o conceito de \"viajar no tempo\" para al\u00e9m do per\u00edodo de validade do token, garantindo que a tentativa subsequente de utiliz\u00e1-lo resultar\u00e1 em um erro de autentica\u00e7\u00e3o.</p> tests/test_auth.py<pre><code>from freezegun import freeze_time\n\n# ...\n\ndef test_token_expired_after_time(client, user):\n    with freeze_time('2023-07-14 12:00:00'):\n        response = client.post(\n            '/auth/token',\n            data={'username': user.email, 'password': user.clean_password},\n        )\n        assert response.status_code == HTTPStatus.OK\n        token = response.json()['access_token']\n\n    with freeze_time('2023-07-14 12:31:00'):\n        response = client.put(\n            f'/users/{user.id}',\n            headers={'Authorization': f'Bearer {token}'},\n            json={\n                'username': 'wrongwrong',\n                'email': 'wrong@wrong.com',\n                'password': 'wrong',\n            },\n        )\n        assert response.status_code == HTTPStatus.UNAUTHORIZED\n        assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Lembre-se de que configuramos nosso token para expirar ap\u00f3s 30 minutos. Portanto, n\u00f3s avan\u00e7amos o tempo em 31 minutos para garantir que o token tenha expirado.</p> <p>Agora, executaremos nosso teste e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_auth.py::test_token_expired_after_time FAILED\n</code></pre> <p>O motivo deste teste falhar \u00e9 que n\u00e3o temos uma condi\u00e7\u00e3o que fa\u00e7a a captura deste cen\u00e1rio. Em <code>fast_zero/security.py</code>, o \u00fanico caso de erro esperado \u00e9 em rela\u00e7\u00e3o \u00e0 dados  inv\u00e1lidos durante o decode (<code>DecodeError</code>). Precisamos adicionar uma exception para quando o token estiver no formato correto, mas n\u00e3o estiver no prazo de validade. Quando seu tempo de uso j\u00e1 est\u00e1 expirado.</p> <p>Para isso, podemos importar do <code>pyjwt</code> o objeto <code>ExpiredSignatureError</code> que \u00e9 a exce\u00e7\u00e3o levantada para a decodifica\u00e7\u00e3o de um c\u00f3digo expirado:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\nfrom http import HTTPStatus\n\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt import DecodeError, ExpiredSignatureError, decode, encode\nfrom pwdlib import PasswordHash\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\n# ...\n\nasync def get_current_user(\n    session: AsyncSession = Depends(get_session),\n    token: str = Depends(oauth2_scheme),\n):\n    credentials_exception = HTTPException(\n        status_code=HTTPStatus.UNAUTHORIZED,\n        detail='Could not validate credentials',\n        headers={'WWW-Authenticate': 'Bearer'},\n    )\n\n    try:\n        payload = decode(\n            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]\n        )\n        subject_email = payload.get('sub')\n\n        if not subject_email:\n            raise credentials_exception\n\n    except DecodeError:\n        raise credentials_exception\n\n    except ExpiredSignatureError:\n        raise credentials_exception\n\n    user = await session.scalar(\n        select(User).where(User.email == subject_email)\n    )\n\n    if not user:\n        raise credentials_exception\n\n    return user\n</code></pre> <p>Com essa simples altera\u00e7\u00e3o, temos uma sa\u00edda de erro para quando o token estiver inv\u00e1lido. Por quest\u00f5es de seguran\u00e7a, vamos manter a mesma mensagem usada antes. Dizendo que n\u00e3o conseguimos validar as credenciais.</p> <p>Assim, vamos executar o teste novamente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_auth.py::test_token_expired_after_time PASSED\n</code></pre> <p>Temos a demonstra\u00e7\u00e3o de sucesso.</p> <p>No entanto, ainda h\u00e1 uma coisa que precisamos implementar: a atualiza\u00e7\u00e3o de tokens. Atualmente, quando um token expira, o usu\u00e1rio teria que fazer login novamente para obter um novo token. Isso n\u00e3o \u00e9 uma \u00f3tima experi\u00eancia para o usu\u00e1rio. Em vez disso, gostar\u00edamos de oferecer a possibilidade de o usu\u00e1rio atualizar seu token quando ele estiver prestes a expirar. Veremos como fazer isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"09/#testando-o-usuario-nao-existente-e-senha-incorreta","title":"Testando o usu\u00e1rio n\u00e3o existente e senha incorreta","text":"<p>Na constru\u00e7\u00e3o de qualquer sistema de autentica\u00e7\u00e3o, \u00e9 crucial garantir que os casos de erro sejam tratados corretamente. Isso n\u00e3o s\u00f3 previne poss\u00edveis falhas de seguran\u00e7a, mas tamb\u00e9m permite fornecer feedback \u00fatil aos usu\u00e1rios.</p> <p>Em nossa implementa\u00e7\u00e3o atual, temos duas situa\u00e7\u00f5es espec\u00edficas que devem retornar um erro: quando um usu\u00e1rio inexistente tenta fazer login e quando uma senha incorreta \u00e9 fornecida. Abordaremos esses casos de erro em nossos pr\u00f3ximos testes.</p> <p>Embora possa parecer redundante testar esses casos j\u00e1 que ambos resultam no mesmo erro, \u00e9 importante verificar que ambos os cen\u00e1rios est\u00e3o corretamente tratados. Isso nos permitir\u00e1 manter a robustez do nosso sistema conforme ele evolui e muda ao longo do tempo.</p>"},{"location":"09/#testando-a-excecao-para-um-usuario-inexistente","title":"Testando a exce\u00e7\u00e3o para um usu\u00e1rio inexistente","text":"<p>Para este cen\u00e1rio, precisamos enviar um request para o endpoint de token com um e-mail que n\u00e3o existe no banco de dados. A resposta esperada \u00e9 um HTTP 401 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_inexistent_user(client):\n    response = client.post(\n        '/auth/token',\n        data={'username': 'no_user@no_domain.com', 'password': 'testtest'},\n    )\n    assert response.status_code == HTTPStatus.UNAUTHORIZED\n    assert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre>"},{"location":"09/#testando-a-excecao-para-uma-senha-incorreta","title":"Testando a exce\u00e7\u00e3o para uma senha incorreta","text":"<p>Aqui, precisamos enviar um request para o endpoint de token com uma senha incorreta para um usu\u00e1rio existente. A resposta esperada \u00e9 um HTTP 401 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_wrong_password(client, user):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': 'wrong_password'}\n    )\n    assert response.status_code == HTTPStatus.UNAUTHORIZED\n    assert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre> <p>Com esses testes, garantimos que nossas exce\u00e7\u00f5es est\u00e3o sendo lan\u00e7adas corretamente. Essa \u00e9 uma parte importante da constru\u00e7\u00e3o de um sistema de autentica\u00e7\u00e3o robusto, pois nos permite ter confian\u00e7a de que estamos tratando corretamente os casos de erro.</p>"},{"location":"09/#implementando-o-refresh-do-token","title":"Implementando o refresh do token","text":"<p>O processo de renova\u00e7\u00e3o de token \u00e9 uma parte essencial na implementa\u00e7\u00e3o de autentica\u00e7\u00e3o JWT. Em muitos sistemas, por raz\u00f5es de seguran\u00e7a, os tokens de acesso t\u00eam um tempo de vida relativamente curto. Isso significa que eles expiram ap\u00f3s um determinado per\u00edodo de tempo, e quando isso acontece, o cliente precisa obter um novo token para continuar acessando os recursos do servidor. Aqui \u00e9 onde o processo de renova\u00e7\u00e3o de token entra: permite que um cliente obtenha um novo token de acesso sem a necessidade de autentica\u00e7\u00e3o completa (por exemplo, sem ter que fornecer novamente o nome de usu\u00e1rio e senha).</p> <p>Agora implementaremos a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token em nosso c\u00f3digo.</p> fast_zero/routes/auth.py<pre><code>from fast_zero.security import (\n    create_access_token,\n    get_current_user,\n    verify_password,\n)\n\n# ...\nCurrentUser = Annotated[User, Depends(get_current_user)]\n# ...\n\n@router.post('/refresh_token', response_model=Token)\nasync def refresh_access_token(user: CurrentUser):\n    new_access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': new_access_token, 'token_type': 'bearer'}\n</code></pre> <p>Implementaremos tamb\u00e9m um teste para verificar se a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token est\u00e1 funcionando corretamente.</p> tests/test_auth.py<pre><code>def test_refresh_token(client, user, token):\n    response = client.post(\n        '/auth/refresh_token',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    data = response.json()\n\n    assert response.status_code == HTTPStatus.OK\n    assert 'access_token' in data\n    assert 'token_type' in data\n    assert data['token_type'] == 'bearer'\n</code></pre> <p>Ainda \u00e9 importante garantir que nosso sistema trate corretamente os tokens expirados. Para isso, adicionaremos um teste que verifica se um token expirado n\u00e3o pode ser usado para renovar um token.</p> tests/test_auth.py<pre><code>def test_token_expired_dont_refresh(client, user):\n    with freeze_time('2023-07-14 12:00:00'):\n        response = client.post(\n            '/auth/token',\n            data={'username': user.email, 'password': user.clean_password},\n        )\n        assert response.status_code == HTTPStatus.OK\n        token = response.json()['access_token']\n\n    with freeze_time('2023-07-14 12:31:00'):\n        response = client.post(\n            '/auth/refresh_token',\n            headers={'Authorization': f'Bearer {token}'},\n        )\n        assert response.status_code == HTTPStatus.UNAUTHORIZED\n        assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Agora, se executarmos nossos testes, todos eles devem passar, incluindo os novos testes que acabamos de adicionar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_auth.py::test_token_inexistent_user PASSED\ntests/test_auth.py::test_token_wrong_password PASSED\ntests/test_auth.py::test_refresh_token PASSED\ntests/test_auth.py::test_token_expired_after_time PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_integrity_error PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\ntests/test_users.py::test_delete_user_wrong_user PASSED\ntests/test_users.py::test_token_expired_dont_refresh PASSED\n</code></pre> <p>Com esses testes, podemos ter certeza de que cobrimos alguns casos importantes relacionados \u00e0 autentica\u00e7\u00e3o de usu\u00e1rios em nossa API.</p>"},{"location":"09/#atualizando-o-schema-do-oauth","title":"Atualizando o schema do OAuth","text":"<p>Agora que temos um endpoint espec\u00edfico para o refresh, seria bom indicar na documenta\u00e7\u00e3o que ele est\u00e1 dispon\u00edvel e qual o endpoint respons\u00e1vel por isso.</p> <p>Basta adicionar ao <code>OAuth2PasswordBearer</code> qual o caminho respons\u00e1vel pelo refresh:</p> fast_zero/security.py<pre><code># ...\noauth2_scheme = OAuth2PasswordBearer(\n    tokenUrl='auth/token', refreshUrl='auth/refresh'\n)\n# ...\n</code></pre> <p>Dessa forma, nossa documenta\u00e7\u00e3o mostra exatamente o endpoint respons\u00e1vel pelo refresh no campo de <code>OAuth2</code>:</p> <p></p> <p>Ficando expl\u00edcito para o cliente.</p>"},{"location":"09/#commit","title":"Commit","text":"<p>Agora, faremos um commit com as altera\u00e7\u00f5es que fizemos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Implementando o refresh do token e testes de autoriza\u00e7\u00e3o\"\n</code></pre>"},{"location":"09/#exercicio","title":"Exerc\u00edcio","text":"<p>O endpoint de <code>PUT</code> usa dois users criados na base de dados, por\u00e9m, at\u00e9 o momento ele cria um novo user no teste via request na API por falta de uma fixture como <code>other_user</code>. Atualize o teste para usar essa nova fixture.</p> <p>Exerc\u00edcios resolvidos </p>"},{"location":"09/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, abordamos uma grande quantidade de t\u00f3picos cruciais para a constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o web segura e robusta. Come\u00e7amos com a implementa\u00e7\u00e3o da funcionalidade de renova\u00e7\u00e3o do token JWT, uma pe\u00e7a fundamental na arquitetura de autentica\u00e7\u00e3o baseada em token. Este processo garante que os usu\u00e1rios possam continuar acessando a aplica\u00e7\u00e3o, mesmo ap\u00f3s o token inicial ter expirado, sem a necessidade de fornecer suas credenciais novamente.</p> <p>Por\u00e9m, a implementa\u00e7\u00e3o do c\u00f3digo foi apenas a primeira parte do que fizemos. Uma parte significativa da nossa aula foi dedicada a testar de maneira exaustiva a nossa aplica\u00e7\u00e3o. Escrevemos testes para verificar o comportamento b\u00e1sico das nossas rotas de autentica\u00e7\u00e3o, mas n\u00e3o paramos por a\u00ed. Tamb\u00e9m consideramos v\u00e1rios casos de borda que podem surgir durante a autentica\u00e7\u00e3o de um usu\u00e1rio.</p> <p>Testamos, por exemplo, o que acontece quando se tenta obter um token com credenciais incorretas. Verificamos o comportamento da nossa aplica\u00e7\u00e3o quando um token expirado \u00e9 utilizado. Esses testes nos ajudam a garantir que nossa aplica\u00e7\u00e3o se comporte de maneira adequada n\u00e3o apenas nas situa\u00e7\u00f5es mais comuns, mas tamb\u00e9m quando algo sai do esperado.</p> <p>Al\u00e9m disso, ao implementar esses testes, n\u00f3s garantimos que futuras altera\u00e7\u00f5es no nosso c\u00f3digo n\u00e3o ir\u00e3o quebrar funcionalidades j\u00e1 existentes. Testes automatizados s\u00e3o uma parte fundamental de qualquer aplica\u00e7\u00e3o de alta qualidade, e o que fizemos nesta aula vai al\u00e9m do b\u00e1sico, mostrando como lidar com cen\u00e1rios complexos e realistas. Nos aproximando do ambiente de produ\u00e7\u00e3o.</p> <p>Na pr\u00f3xima aula, utilizaremos a infraestrutura de autentica\u00e7\u00e3o que criamos aqui para permitir que os usu\u00e1rios criem, leiam, atualizem e deletem suas pr\u00f3prias listas de tarefas. Isso vai nos permitir explorar ainda mais as funcionalidades do FastAPI e do SQLAlchemy, al\u00e9m de continuar a expandir a nossa su\u00edte de testes.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p> <ol> <li> <p>Quando nos referimos a f\u00e1brica, estamos falando do padr\u00e3o de projeto criacional Factory. Para mais informa\u00e7\u00f5es sobre o padr\u00e3o, voc\u00ea pode dar uma olhada aqui.\u00a0\u21a9</p> </li> </ol>"},{"location":"10/","title":"Criando rotas CRUD para gerenciamento de tarefas","text":""},{"location":"10/#criando-rotas-crud-para-gerenciamento-de-tarefas","title":"Criando rotas CRUD para gerenciamento de tarefas","text":"<p>Objetivos da Aula:</p> <ul> <li>Cria\u00e7\u00e3o das rotas para as opera\u00e7\u00f5es CRUD das tarefas</li> <li>Fazer com que s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas</li> <li>Escrita e execu\u00e7\u00e3o dos testes para cada opera\u00e7\u00e3o das tarefas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz  Exerc\u00edcios </p> <p>Ap\u00f3s termos cumprido todos os passos essenciais para estabelecer um sistema eficiente de gerenciamento de usu\u00e1rios, estamos agora preparados para levar nossa aplica\u00e7\u00e3o a um novo momento, introduzindo um sistema de gerenciamento de tarefas, mais conhecido como todo list. Nesta nova etapa, garantiremos que somente o usu\u00e1rio que criou uma tarefa tenha o direito de acessar e editar tal tarefa, refor\u00e7ando a seguran\u00e7a e a privacidade dos dados. Para isso, desenvolveremos diversos endpoints e implementaremos as medidas de restri\u00e7\u00e3o e autentica\u00e7\u00e3o que aprimoramos na \u00faltima aula.</p>"},{"location":"10/#estrutura-inicial-do-codigo","title":"Estrutura inicial do c\u00f3digo","text":"<p>Primeiro, criaremos um novo arquivo chamado <code>todos.py</code> no diret\u00f3rio de <code>routers</code>:</p> fast_zero/routers/todos.py<pre><code>from fastapi import APIRouter\n\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n</code></pre> <p>Neste c\u00f3digo, criamos uma nova inst\u00e2ncia da classe <code>APIRouter</code> do FastAPI. Esta classe \u00e9 usada para definir as rotas de nossa aplica\u00e7\u00e3o. A inst\u00e2ncia <code>router</code> funcionar\u00e1 como um mini aplicativo FastAPI, que poder\u00e1 ter suas pr\u00f3prias rotas, modelos de resposta, etc.</p> <p>A op\u00e7\u00e3o <code>prefix</code> no construtor do <code>APIRouter</code> \u00e9 usada para definir um prefixo comum para todas as rotas definidas neste roteador. Isso significa que todas as rotas que definirmos neste roteador come\u00e7ar\u00e3o com <code>/todos</code>. Usamos um prefixo aqui porque queremos agrupar todas as rotas relacionadas a tarefas em um lugar. Isso torna nossa aplica\u00e7\u00e3o mais organizada e f\u00e1cil de entender.</p> <p>A op\u00e7\u00e3o <code>tags</code> \u00e9 usada para agrupar as rotas em se\u00e7\u00f5es no documento interativo de API gerado pelo FastAPI (como Swagger UI e ReDoc). Todas as rotas que definirmos neste roteador aparecer\u00e3o na se\u00e7\u00e3o \"todos\" da documenta\u00e7\u00e3o da API.</p> <p>Ap\u00f3s definir o roteador, precisamos inclu\u00ed-lo em nossa aplica\u00e7\u00e3o principal. Atualizaremos o arquivo <code>fast_zero/app.py</code> para incluir as rotas de tarefas que criaremos:</p> fast_zero/app.py<pre><code>from http import HTTPStatus\n\nfrom fastapi import FastAPI\n\nfrom fast_zero.routers import auth, todos, users\nfrom fast_zero.schemas import Message\n\napp = FastAPI()\n\napp.include_router(users.router)\napp.include_router(auth.router)\napp.include_router(todos.router)\n\n\n@app.get('/', status_code=HTTPStatus.OK, response_model=Message)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Neste c\u00f3digo, chamamos o m\u00e9todo <code>include_router</code> do FastAPI para cada roteador que definimos. Este m\u00e9todo adiciona todas as rotas do roteador \u00e0 nossa aplica\u00e7\u00e3o. Com isso, nossa aplica\u00e7\u00e3o agora ter\u00e1 todas as rotas definidas nos roteadores <code>users</code>, <code>auth</code> e <code>todos</code>.</p>"},{"location":"10/#implementacao-da-tabela-no-banco-de-dados","title":"Implementa\u00e7\u00e3o da tabela no Banco de dados","text":"<p>Agora, implementaremos a tabela 'Todos' no nosso banco de dados. Esta tabela estar\u00e1 diretamente relacionada \u00e0 tabela 'User', pois toda tarefa pertence a um usu\u00e1rio. Esta rela\u00e7\u00e3o \u00e9 crucial para garantir que s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas.</p> fast_zero/models.py<pre><code>from datetime import datetime\nfrom enum import Enum\n\nfrom sqlalchemy import ForeignKey, func\nfrom sqlalchemy.orm import (\n    Mapped, mapped_as_dataclass, mapped_column, registry, relationship\n)\n\ntable_registry = registry()\n\n\nclass TodoState(str, Enum): #(1)!\n    draft = 'draft'\n    todo = 'todo'\n    doing = 'doing'\n    done = 'done'\n    trash = 'trash'\n\n\n@mapped_as_dataclass(table_registry)\nclass User:\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(init=False, primary_key=True)\n    username: Mapped[str] = mapped_column(unique=True)\n    password: Mapped[str]\n    email: Mapped[str] = mapped_column(unique=True)\n    created_at: Mapped[datetime] = mapped_column(\n        init=False, server_default=func.now()\n    )\n\n    todos: Mapped[list['Todo']] = relationship( #(2)!\n        init=False,\n        cascade='all, delete-orphan',\n        lazy='selectin',\n    )\n\n\n@mapped_as_dataclass(table_registry)\nclass Todo:\n    __tablename__ = 'todos'\n\n    id: Mapped[int] = mapped_column(init=False, primary_key=True)\n    title: Mapped[str]\n    description: Mapped[str]\n    state: Mapped[TodoState] #(3)!\n\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id')) #(4)!\n</code></pre> <ol> <li> <p>Enums de strings no podem validar se o texto est\u00e1 entre as alternativas v\u00e1lidas. Algo como:</p> <pre><code>&gt;&gt;&gt; TodoState('draft') # Valor encontrado\n&lt;TodoState.draft: 'draft'&gt;\n&gt;&gt;&gt; TodoState('batatinha')\nTraceback (most recent call last):\n  File \"&lt;python-input-22&gt;\", line 1, in &lt;module&gt;\n    TodoState('batatinha')\n    ~~~~~~~~~^^^^^^^^^^^^^\n  # ...\nValueError: 'batatinha' is not a valid TodoState\n</code></pre> </li> <li> <p>Aqui criamos uma rela\u00e7\u00e3o com a tabela <code>Todos</code>. Onde temos uma rela\u00e7\u00e3o 1:N. Cada <code>User</code> pode ter <code>N</code> <code>Todo</code>s associados a ele. No <code>cascade</code> dizemos <code>'all, delete-orphan'</code> para que quando um <code>User</code> for deletado, todos os todos associados a ele tamb\u00e9m ser\u00e3o deletados. No campo <code>lazy</code> estamos usando <code>'selectin'</code>. O que quer dizer que quando fizermos um <code>select</code> em <code>Users</code> tamb\u00e9m vamos obter os objetos <code>Todo</code> associados a ele.</p> </li> <li><code>TodoState</code> cria uma rela\u00e7\u00e3o entre o <code>Enum</code> e o campo <code>state</code>. Isso quer dizer que somente os valores no enum ser\u00e3o considerados v\u00e1lidos para esse campo.</li> <li>Aqui temos um relacionamento via chave estrangeira. Onde todo <code>Todo</code> \u00e9 associado a um <code>id</code> de <code>User</code>.</li> </ol> <p>Neste ponto, \u00e9 importante compreender o conceito de <code>relationship</code> no SQLAlchemy. A fun\u00e7\u00e3o <code>relationship</code> define como as duas tabelas ir\u00e3o interagir. Por exemplo, a tabela <code>User</code>, em seu campo <code>todo</code> pode exibir todos os objetos <code>Todo</code> associados a ela. Por exemplo, quando buscarmos por um <code>User</code> por meio de um <code>select</code> obteremos todos N objetos <code>Todo</code> associados ao seu <code>id</code>:</p> <pre><code>flowchart LR\n   User --&gt; todos\n   todos --&gt; A[Todo.id 1]\n   todos --&gt; B[Todo.id 2]\n   todos --&gt; C[Todo.id 3]\n   todos --&gt; D[Todo.id 4]</code></pre> <p>Nesse caso temos uma rela\u00e7\u00e3o de 1 <code>User</code>, para N <code>Todo</code>.</p> <p>O argumento <code>cascade</code> determina o que ocorre com as tarefas quando o usu\u00e1rio associado a elas \u00e9 deletado. Ao definir <code>'all, delete-orphan'</code>, estamos instruindo o SQLAlchemy a deletar todas as tarefas de um usu\u00e1rio quando este for deletado.</p> <p>Se formos executar nosso teste do db, ele deve falhar. Pois, temos um novo campo <code>todo</code> sendo retornado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k db\n# ...\ntests/test_db.py::test_create_user FAILED\n# ...\nE         Full diff:\nE           {\nE               'created_at': datetime.datetime(2024, 1, 1, 0, 0),\nE               'email': 'teste@test',\nE               'id': 1,\nE               'password': 'secret',\nE         +     'todos': [],\nE               'username': 'alice',\nE           }\n# ...\n</code></pre> <p>Esse comportamento acontece por termos usado <code>lazy='selectin'</code> no <code>relationship</code>. Isso faz com que o novo campo traga os resultados de <code>Todo</code>s associados a esse <code>User</code> quando for buscado via <code>select</code>. Por esse motivo devemos alterar nosso teste de cria\u00e7\u00e3o de users:</p> tests/test_db.py<pre><code>@pytest.mark.asyncio\nasync def test_create_user(session, mock_db_time):\n    with mock_db_time(model=User) as time:\n        new_user = User(\n            username='alice', password='secret', email='teste@test'\n        )\n        session.add(new_user)\n        await session.commit()\n\n    user = await session.scalar(select(User).where(User.username == 'alice'))\n\n    assert asdict(user) == {\n        'id': 1,\n        'username': 'alice',\n        'password': 'secret',\n        'email': 'teste@test',\n        'created_at': time,\n        'todos': [],\n    }\n</code></pre> <p>Assim, o comportamento esperado deve estar sendo validado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k db\n# ...\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Com isso funcionando, podemos testar nossa nova tabela.</p>"},{"location":"10/#testando-as-novas-implementacoes-do-banco-de-dados","title":"Testando as novas implementa\u00e7\u00f5es do banco de dados","text":"<p>Embora tenhamos 100% de cobertura de c\u00f3digo, isso n\u00e3o garante que tudo esteja funcionando corretamente. S\u00f3 implementamos a estrutura do banco de dados, mas n\u00e3o testamos a l\u00f3gica de como as tabelas e as rela\u00e7\u00f5es funcionam na pr\u00e1tica.</p> <p></p> <p>Pra come\u00e7ar, vamos escrever um teste que valida se os campos da tabela foram criados da maneira correta e com os tipos corretos:</p> tests/test_db.py<pre><code># ...\n\nfrom fast_zero.models import Todo, User\n# ...\n\n@pytest.mark.asyncio\nasync def test_create_todo(session, user):\n    todo = Todo(\n        title='Test Todo',\n        description='Test Desc',\n        state='draft',\n        user_id=user.id, #(1)!\n    )\n\n    session.add(todo)\n    await session.commit()\n\n    todo = await session.scalar(select(Todo))\n\n    assert asdict(todo) == {\n        'description': 'Test Desc',\n        'id': 1,\n        'state': 'draft',\n        'title': 'Test Todo',\n        'user_id': 1,  #(2)!\n    }\n</code></pre> <ol> <li>Precisa que um <code>User</code> esteja criado, pois existe um relacionamento nessa tabela.</li> <li>Valida\u00e7\u00e3o se o <code>Todo</code> conta com o campo de relacionamento.</li> </ol> <p>Nesse teste fizemos a cria\u00e7\u00e3o de um <code>Todo</code>, s\u00f3 que para que um <code>Todo</code> fosse criado, um <code>User</code> precisava ser criado antes, pois um <code>Todo</code> sempre \u00e9 associado a um <code>User</code>.</p> <p>Com isso, voc\u00ea pode executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k db\n# ...\ntests/test_db.py::test_create_user_without_todos PASSED\ntests/test_db.py::test_create_todo PASSED\n</code></pre> <p>Embora tenhamos cen\u00e1rios que pare\u00e7am suficientes, temos que pensar que n\u00e3o testamos a rela\u00e7\u00e3o de todos realmente existindo e sendo retornados com users. Para isso, criamos um teste para verificar se a rela\u00e7\u00e3o entre tarefas e usu\u00e1rios est\u00e1 funcionando corretamente:</p> tests/test_db.py<pre><code>@pytest.mark.asyncio\nasync def test_user_todo_relationship(session, user: User):\n    todo = Todo(\n        title='Test Todo',\n        description='Test Desc',\n        state='draft',\n        user_id=user.id,\n    )\n\n    session.add(todo)\n    await session.commit()\n    await session.refresh(user) #(1)!\n\n    user = await session.scalar(\n        select(User).where(User.id == user.id)\n    )\n\n    assert user.todos == [todo]\n</code></pre> <ol> <li>alguma explica\u00e7\u00e3o legal!</li> </ol> <p>Este teste cria uma nova tarefa para um usu\u00e1rio e verifica se essa tarefa aparece na lista de tarefas desse usu\u00e1rio.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test -k db\n# ...\ntests/test_db.py::test_create_user PASSED\ntests/test_db.py::test_create_todo PASSED\ntests/test_db.py::test_user_todo_relationship PASSED\n</code></pre> <p>Isso mostra que os testes foram bem-sucedidos. Agora, com o modelo j\u00e1 em funcionamento, podemos ir para a parte dos schemas.</p>"},{"location":"10/#schemas-para-todos","title":"Schemas para Todos","text":"<p>Criaremos dois esquemas para nosso modelo de tarefas (todos): <code>TodoSchema</code> e <code>TodoPublic</code>.</p> fast_zero/schemas.py<pre><code>from fast_zero.models import TodoState\n\n#...\n\nclass TodoSchema(BaseModel):\n    title: str\n    description: str\n    state: TodoState\n\n\nclass TodoPublic(TodoSchema):\n    id: int\n\n\nclass TodoList(BaseModel):\n    todos: list[TodoPublic]\n</code></pre> <p><code>TodoSchema</code> ser\u00e1 usado para validar os dados de entrada quando uma nova tarefa \u00e9 criada e <code>TodoPublic</code> ser\u00e1 usado para validar os dados de sa\u00edda quando uma tarefa \u00e9 retornada em um endpoint.</p>"},{"location":"10/#endpoint-de-criacao","title":"Endpoint de cria\u00e7\u00e3o","text":"<p>Criamos o primeiro endpoint para a cria\u00e7\u00e3o de tarefas. Este \u00e9 um endpoint POST na rota '/todos'. \u00c9 importante destacar que, para criar uma tarefa, um usu\u00e1rio precisa estar autenticado e s\u00f3 esse usu\u00e1rio autenticado ser\u00e1 o propriet\u00e1rio da tarefa.</p> fast_zero/routers/todos.py<pre><code>from typing import Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import Todo, User\nfrom fast_zero.schemas import TodoPublic, TodoSchema\nfrom fast_zero.security import get_current_user\n\nrouter = APIRouter()\n\nSession = Annotated[AsyncSession, Depends(get_session)]\nCurrentUser = Annotated[User, Depends(get_current_user)]\n\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n\n\n@router.post('/', response_model=TodoPublic)\nasync def create_todo(\n    todo: TodoSchema,\n    user: CurrentUser,\n    session: Session,\n):\n    db_todo = Todo(\n        title=todo.title,\n        description=todo.description,\n        state=todo.state,\n        user_id=user.id,\n    )\n    session.add(db_todo)\n    await session.commit()\n    await session.refresh(db_todo)\n\n    return db_todo\n</code></pre> <p>Neste endpoint, fazemos uso da depend\u00eancia <code>get_current_user</code> que garante que somente usu\u00e1rios autenticados possam criar tarefas, protegendo assim nossa aplica\u00e7\u00e3o.</p>"},{"location":"10/#testando-o-endpoint-de-criacao","title":"Testando o endpoint de cria\u00e7\u00e3o","text":"<p>Para garantir que nosso endpoint est\u00e1 funcionando corretamente, criamos um teste para ele. Este teste verifica se o endpoint '/todos' est\u00e1 criando tarefas corretamente.</p> tests/test_todos.py<pre><code>def test_create_todo(client, token):\n    response = client.post(\n        '/todos/',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'title': 'Test todo',\n            'description': 'Test todo description',\n            'state': 'draft',\n        },\n    )\n    assert response.json() == {\n        'id': 1,\n        'title': 'Test todo',\n        'description': 'Test todo description',\n        'state': 'draft',\n    }\n</code></pre> <p>No teste, fazemos uma requisi\u00e7\u00e3o POST para o endpoint '/todos' passando um token de autentica\u00e7\u00e3o v\u00e1lido e um JSON com os dados da tarefa a ser criada. Em seguida, verificamos se a resposta cont\u00e9m os dados corretos da tarefa criada.</p> <p>Para executar este teste, voc\u00ea deve usar o comando abaixo no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n# ...\ntests/test_todos.py::test_create_todo PASSED\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, os testes devem passar. Por\u00e9m, apesar do sucesso dos testes, nosso c\u00f3digo ainda n\u00e3o est\u00e1 completamente pronto. Ainda \u00e9 necess\u00e1rio criar uma migra\u00e7\u00e3o para a tabela de tarefas no banco de dados.</p>"},{"location":"10/#criando-a-migracao-da-nova-tabela","title":"Criando a migra\u00e7\u00e3o da nova tabela","text":"<p>Agora que temos nosso modelo de tarefas definido, precisamos criar uma migra\u00e7\u00e3o para adicionar a tabela de tarefas ao nosso banco de dados. Usamos o Alembic para criar e gerenciar nossas migra\u00e7\u00f5es.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create todos table\"\n\n# ...\n\nGenerating /&lt;caminho&gt;/fast_zero/migrations/versions/de865434f506_create_todos_table.py\n</code></pre> <p>Este comando gera um arquivo de migra\u00e7\u00e3o, que se parece com o c\u00f3digo abaixo:</p> migrations/versions/de865434f506_create_todos_table.py<pre><code>def upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('todos',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('title', sa.String(), nullable=False),\n    sa.Column('description', sa.String(), nullable=False),\n    sa.Column('state', sa.Enum('draft', 'todo', 'doing', 'done', 'trash', name='todostate'), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('todos')\n    # ### end Alembic commands ###\n</code></pre> <p>Depois que a migra\u00e7\u00e3o for criada, precisamos aplic\u00e1-la ao nosso banco de dados. Execute o comando <code>alembic upgrade head</code> para aplicar a migra\u00e7\u00e3o.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -&gt; de865434f506, create todos table\n</code></pre> <p>Agora que a migra\u00e7\u00e3o foi aplicada, nosso banco de dados deve ter uma nova tabela de tarefas. Para verificar, voc\u00ea pode abrir o banco de dados com o comando <code>sqlite3 database.db</code> e depois executar o comando <code>.schema</code> para ver o esquema do banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n# ...\nsqlite&gt; .schema\n# ...\nCREATE TABLE todos (\n    id INTEGER NOT NULL,\n    title VARCHAR NOT NULL,\n    description VARCHAR NOT NULL,\n    state VARCHAR(5) NOT NULL,\n    user_id INTEGER NOT NULL,\n    PRIMARY KEY (id),\n    FOREIGN KEY(user_id) REFERENCES users (id)\n);\n</code></pre> <p>Finalmente, agora que temos a tabela de tarefas em nosso banco de dados, podemos testar nosso endpoint de cria\u00e7\u00e3o de tarefas no Swagger. Para fazer isso, execute nosso servidor FastAPI e abra o Swagger no seu navegador.</p>"},{"location":"10/#endpoint-de-listagem","title":"Endpoint de listagem","text":"<p>Agora que criamos a nossa migra\u00e7\u00e3o e temos o endpoint de cria\u00e7\u00e3o de Todos, temos que criar nosso endpoint de listagem de tarefas. Ele deve listar todas as tarefas de acordo com o <code>CurrentUser</code>.</p> <p>Algumas coisas adicionais e que podem ser importantes na hora de recuperar as tarefas \u00e9 fazer um filtro de busca. Em alguns momentos queremos buscar uma tarefa por t\u00edtulo, em outro momento por descri\u00e7\u00e3o, \u00e0s vezes s\u00f3 pelo estado. Por exemplo, somente tarefas conclu\u00eddas.</p> <p>Por exemplo, uma query string simples pode ser: <code>todos/?title=\"batatinha\"</code>.</p> <p>Uma caracter\u00edstica importante das queries \u00e9 que podemos juntar mais de um atributo em uma busca. Por exemplo, podemos buscar somente as tarefas a fazer que contenham no t\u00edtulo \"trabalho\". Dessa forma, temos um endpoint mais eficiente, j\u00e1 que podemos realizar buscas complexas e refinadas com uma \u00fanica chamada.</p> <p>A combina\u00e7\u00e3o poderia ser algo como: <code>todos/?title=\"batatinha\"&amp;status=todo</code>.</p> <p>A combina\u00e7\u00e3o de diferentes par\u00e2metros de query n\u00e3o s\u00f3 torna o endpoint mais flex\u00edvel, mas tamb\u00e9m permite que os usu\u00e1rios obtenham os dados de que precisam de maneira mais r\u00e1pida e conveniente. Isso contribui para uma melhor experi\u00eancia do usu\u00e1rio e otimiza a intera\u00e7\u00e3o com o banco de dados.</p>"},{"location":"10/#o-modelo-da-query","title":"O modelo da query","text":"<p>Como agora temos v\u00e1rios par\u00e2metros de query como <code>title</code>, <code>description</code> e <code>state</code>, podemos criar um modelo como esse:</p> fast_zero/schemas.py<pre><code>class FilterTodo(FilterPage):\n    title: str | None = None\n    description: str | None = None\n    state: TodoState | None = None\n</code></pre> <p>Uma coisa interessante de observar nesse modelo \u00e9 que ele usa <code>FilterPage</code> como base, para que al\u00e9m dos campos propostos, tenhamos o <code>limit</code> e <code>offset</code> tamb\u00e9m.</p> <p>A defini\u00e7\u00e3o de <code>state</code> tem um comportamento bastante interessante na documenta\u00e7\u00e3o, gerando uma caixa de sele\u00e7\u00e3o para garantir que o valor correto seja enviado.</p> <p></p>"},{"location":"10/#afunilando-o-schema","title":"Afunilando o schema","text":"<p>Outra coisa que pode ser feita, al\u00e9m de deixar cada filtro opcional na querystring \u00e9 utilizar o campo <code>Field</code> do pydantic, como fizemos na aula 07. Desta vez, por\u00e9m, aplicando limita\u00e7\u00f5es \u00e0s strings.</p> fast_zero/schemas.py<pre><code>class FilterTodo(FilterPage):\n    title: str | None = Field(None, min_length=3, max_length=20)\n    description: str | None = Field(None, min_length=3, max_length=20)\n    state: TodoState | None = None\n</code></pre> <p>Desta forma, <code>Field(None, min_length=3, max_length=20)</code>, podemos garantir que a requisi\u00e7\u00e3o feita deve ter ao menos <code>3</code> caracteres e no m\u00e1ximo <code>20</code>.</p> <p>Embora essa seja uma mudan\u00e7a s\u00fatil, evitam-se buscas por uma quantidade grande de registros no resultado. Imagine a busca por um \u00fanico caractere, como <code>a</code>. Ela pode ser bastante exaustiva, trazendo uma quantidade grande de volume de dados na resposta. Embora os <code>limit</code> e <code>offset</code> estejam no filtro, limitando o tamanho da resposta, essas buscas ainda podem ser bastante extensas.</p> <p></p> URLs longas <p>Embora URLs n\u00e3o tenham uma limita\u00e7\u00e3o especificada em seu tamanho, os navegadores t\u00eam limita\u00e7\u00f5es em rela\u00e7\u00e3o ao tamanho delas. Nada extremamente preocupante. O falecido IE explorer, por exemplo, tinha uma limita\u00e7\u00e3o de 2.083 caracteres. Mas\u2026 sempre que poss\u00edvel, \u00e9 importante limitar o tamanho m\u00e1ximo, pode evitar bugs e at\u00e9 mesmo alguns c\u00f3digos <code>414</code> de erro.</p>"},{"location":"10/#implementacao-do-endpoint","title":"Implementa\u00e7\u00e3o do endpoint","text":"<p>Agora, com o modelo em m\u00e3os, podemos escrever nosso endpoint de listagem que leva em considera\u00e7\u00e3o todos os filtros poss\u00edveis na hora de fazer a busca:</p> fast_zero/routers/todos.py<pre><code>from typing import Annotated\n# ...\nfrom fastapi import APIRouter, Depends, Query\nfrom sqlalchemy import select\n# ...\nfrom fast_zero.schemas import (\n    FilterTodo,\n    Message,\n    TodoList,\n    TodoPublic,\n    TodoSchema,\n    TodoUpdate,\n)\n\n# ...\n\n@router.get('/', response_model=TodoList)\nasync def list_todos(\n    session: Session,\n    user: CurrentUser,\n    todo_filter: Annotated[FilterTodo, Query()],\n):\n    query = select(Todo).where(Todo.user_id == user.id)\n\n    if todo_filter.title:\n        query = query.filter(Todo.title.contains(todo_filter.title))\n\n    if todo_filter.description:\n        query = query.filter(\n            Todo.description.contains(todo_filter.description)\n        )\n\n    if todo_filter.state:\n        query = query.filter(Todo.state == todo_filter.state)\n\n    todos = await session.scalars(\n        query.offset(todo_filter.offset).limit(todo_filter.limit)\n    )\n\n    return {'todos': todos.all()}\n</code></pre> <p>Essa abordagem equilibra a flexibilidade e a efici\u00eancia, tornando o endpoint capaz de atender a uma variedade de necessidades de neg\u00f3cio. Utilizando os recursos do FastAPI, conseguimos implementar uma solu\u00e7\u00e3o robusta e f\u00e1cil de manter, que ser\u00e1 testada posteriormente para garantir sua funcionalidade e integridade.</p> <p>No c\u00f3digo acima, estamos utilizando filtros do SQLAlchemy, uma biblioteca ORM (Object-Relational Mapping) do Python, para adicionar condi\u00e7\u00f5es \u00e0 nossa consulta. Esses filtros correspondem aos par\u00e2metros que o usu\u00e1rio pode passar na URL.</p> <ul> <li><code>Todo.title.contains(todo_filter.title)</code>: verifica se o t\u00edtulo da tarefa cont\u00e9m a string fornecida.</li> <li><code>Todo.description.contains(todo_filter.description)</code>: verifica se a descri\u00e7\u00e3o da tarefa cont\u00e9m a string fornecida.</li> <li><code>Todo.state == todo_filter.state</code>: compara o estado da tarefa com o valor fornecido.</li> </ul> <p>Essas condi\u00e7\u00f5es s\u00e3o traduzidas em cl\u00e1usulas SQL pelo SQLAlchemy, permitindo que o banco de dados filtre os resultados de acordo com os crit\u00e9rios especificados pelo usu\u00e1rio. Essa integra\u00e7\u00e3o entre FastAPI e SQLAlchemy torna o processo de filtragem eficiente e a codifica\u00e7\u00e3o mais expressiva e clara.</p>"},{"location":"10/#criando-uma-factory-para-simplificar-os-testes","title":"Criando uma factory para simplificar os testes","text":"<p>Criar uma factory para o endpoint facilitaria os testes por diversas raz\u00f5es, especialmente quando se trata de testar o nosso endpoint de listagem que usa m\u00faltiplas queries. Primeiro, a factory ajuda a encapsular a l\u00f3gica de cria\u00e7\u00e3o dos objetos necess\u00e1rios para o teste, como no caso dos objetos <code>Todo</code>. Isso significa que voc\u00ea pode criar objetos consistentes e bem-formados sem ter que repetir o mesmo c\u00f3digo em v\u00e1rios testes.</p> <p>Com a complexidade das queries que nosso endpoint permite, precisamos cobrir todos os usos poss\u00edveis dessas queries. A factory vai nos ajudar a criar muitos casos de testes de forma pr\u00e1tica e eficiente, j\u00e1 que podemos gerar diferentes combina\u00e7\u00f5es de t\u00edtulos, descri\u00e7\u00f5es, estados, entre outros atributos, simulando diversas situa\u00e7\u00f5es de uso.</p> <p>Al\u00e9m disso, ao utilizar bibliotecas como o <code>factory</code>, \u00e9 poss\u00edvel gerar dados aleat\u00f3rios e v\u00e1lidos, o que pode ajudar a garantir que os testes sejam abrangentes e testem o endpoint em uma variedade de condi\u00e7\u00f5es. Ao simplificar o processo de configura\u00e7\u00e3o dos testes, voc\u00ea pode economizar tempo e esfor\u00e7o, permitindo que a equipe se concentre mais na l\u00f3gica do teste.</p> tests/test_todos.py<pre><code>import factory.fuzzy\n\nfrom fast_zero.models import Todo, TodoState\n\n# ...\n\nclass TodoFactory(factory.Factory):\n    class Meta:\n        model = Todo\n\n    title = factory.Faker('text')\n    description = factory.Faker('text')\n    state = factory.fuzzy.FuzzyChoice(TodoState)\n    user_id = 1\n</code></pre> <p>A fixture acima pode ser usada em diversos testes, reduzindo a duplica\u00e7\u00e3o de c\u00f3digo e melhorando a manuten\u00e7\u00e3o. Por exemplo, em um teste que precisa criar v\u00e1rios objetos <code>Todo</code>, voc\u00ea pode simplesmente usar a <code>TodoFactory</code> para criar esses objetos com uma \u00fanica linha de c\u00f3digo. A factory j\u00e1 cont\u00e9m a l\u00f3gica necess\u00e1ria para criar um objeto v\u00e1lido, e voc\u00ea pode facilmente sobrescrever qualquer um dos atributos, se necess\u00e1rio, para o caso de teste espec\u00edfico.</p> <p>A utiliza\u00e7\u00e3o de f\u00e1bricas tamb\u00e9m promove uma melhor separa\u00e7\u00e3o entre a l\u00f3gica de cria\u00e7\u00e3o do objeto e a l\u00f3gica do teste, tornando os testes mais leg\u00edveis e f\u00e1ceis de seguir. Com a <code>TodoFactory</code>, somos capazes de simular e testar diversos cen\u00e1rios de busca e filtragem, garantindo que nosso endpoint de listagem funcione corretamente em todas as situa\u00e7\u00f5es poss\u00edveis, aumentando assim a robustez e confiabilidade de nosso sistema.</p>"},{"location":"10/#testes-para-esse-endpoint","title":"Testes para esse endpoint","text":"<p>Ao trabalhar com o endpoint de listagem de tarefas, temos v\u00e1rias varia\u00e7\u00f5es de query strings que precisam ser testadas. Cada uma dessas varia\u00e7\u00f5es representa um caso de uso diferente, e queremos garantir que o sistema funcione corretamente em todos eles. Separaremos os testes em pequenos blocos e explicar cada um deles.</p>"},{"location":"10/#testando-a-listagem-de-todos","title":"Testando a Listagem de Todos","text":"<p>Primeiro, criaremos um teste b\u00e1sico que verifica se o endpoint est\u00e1 listando todos os objetos <code>Todo</code>.</p> tests/test_todos.py<pre><code>import pytest\n\n# ...\n\n@pytest.mark.asyncio\nasync def test_list_todos_should_return_5_todos(session, client, user, token):\n    expected_todos = 5\n    session.add_all(TodoFactory.create_batch(5, user_id=user.id))\n    await session.commit()\n\n    response = client.get(\n        '/todos/',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Este teste valida que todos os 5 objetos <code>Todo</code> s\u00e3o retornados pelo endpoint.</p>"},{"location":"10/#testando-a-paginacao","title":"Testando a Pagina\u00e7\u00e3o","text":"<p>Em seguida, testaremos a pagina\u00e7\u00e3o para garantir que o offset e o limite estejam funcionando corretamente.</p> tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_list_todos_pagination_should_return_2_todos(\n    session, user, client, token\n):\n    expected_todos = 2\n    session.add_all(TodoFactory.create_batch(5, user_id=user.id))\n    await session.commit()\n\n    response = client.get(\n        '/todos/?offset=1&amp;limit=2',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Este teste verifica que, quando aplicado o offset de 1 e o limite de 2, apenas 2 objetos <code>Todo</code> s\u00e3o retornados.</p>"},{"location":"10/#testando-o-filtro-por-titulo","title":"Testando o Filtro por T\u00edtulo","text":"<p>Tamb\u00e9m queremos verificar se a filtragem por t\u00edtulo est\u00e1 funcionando conforme esperado.</p> tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_list_todos_filter_title_should_return_5_todos(\n    session, user, client, token\n):\n    expected_todos = 5\n    session.add_all(\n        TodoFactory.create_batch(5, user_id=user.id, title='Test todo 1')\n    )\n    await session.commit()\n\n    response = client.get(\n        '/todos/?title=Test todo 1',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Este teste garante que quando o filtro de t\u00edtulo \u00e9 aplicado, apenas as tarefas com o t\u00edtulo correspondente s\u00e3o retornadas.</p>"},{"location":"10/#testando-o-filtro-por-descricao","title":"Testando o Filtro por Descri\u00e7\u00e3o","text":"<p>Da mesma forma, queremos testar o filtro de descri\u00e7\u00e3o.</p> tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_list_todos_filter_description_should_return_5_todos(\n    session, user, client, token\n):\n    expected_todos = 5\n    session.add_all(\n        TodoFactory.create_batch(5, user_id=user.id, description='description')\n    )\n    await session.commit()\n\n    response = client.get(\n        '/todos/?description=desc',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Este teste verifica que, quando filtramos pela descri\u00e7\u00e3o, apenas as tarefas com a descri\u00e7\u00e3o correspondente s\u00e3o retornadas.</p>"},{"location":"10/#testando-o-filtro-por-estado","title":"Testando o Filtro por Estado","text":"<p>Finalmente, precisamos testar o filtro de estado.</p> tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_list_todos_filter_state_should_return_5_todos(\n    session, user, client, token\n):\n    expected_todos = 5\n    session.add_all(\n        TodoFactory.create_batch(5, user_id=user.id, state=TodoState.draft)\n    )\n    await session.commit()\n\n    response = client.get(\n        '/todos/?state=draft',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Este teste garante que quando filtramos pelo estado, apenas as tarefas com o estado correspondente s\u00e3o retornadas.</p>"},{"location":"10/#testando-a-combinacao-de-filtros-de-estado-titulo-e-descricao","title":"Testando a Combina\u00e7\u00e3o de Filtros de Estado, T\u00edtulo e Descri\u00e7\u00e3o","text":"<p>Em nosso conjunto de testes, tamb\u00e9m \u00e9 importante verificar se o endpoint \u00e9 capaz de lidar com m\u00faltiplos par\u00e2metros de consulta simultaneamente. Para isso, criaremos um teste que combine os filtros de estado, t\u00edtulo e descri\u00e7\u00e3o. Isso assegurar\u00e1 que, quando esses par\u00e2metros s\u00e3o usados juntos, o endpoint retornar\u00e1 apenas as tarefas que correspondem a todas essas condi\u00e7\u00f5es.</p> <p>Este teste \u00e9 vital para garantir que os usu\u00e1rios podem realizar buscas complexas usando v\u00e1rios crit\u00e9rios ao mesmo tempo, e que o endpoint ir\u00e1 retornar os resultados esperados.</p> <p>A seguir, apresento o c\u00f3digo do teste:</p> tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_list_todos_filter_combined_should_return_5_todos(\n    session, user, client, token\n):\n    expected_todos = 5\n    session.add_all(\n        TodoFactory.create_batch(\n            5,\n            user_id=user.id,\n            title='Test todo combined',\n            description='combined description',\n            state=TodoState.done,\n        )\n    )\n\n    session.add_all(\n        TodoFactory.create_batch(\n            3,\n            user_id=user.id,\n            title='Other title',\n            description='other description',\n            state=TodoState.todo,\n        )\n    )\n    await session.commit()\n\n    response = client.get(\n        '/todos/?title=Test todo combined&amp;description=combined&amp;state=done',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == expected_todos\n</code></pre> <p>Com esses testes, cobrimos todas as poss\u00edveis varia\u00e7\u00f5es de query strings para o nosso endpoint, garantindo que ele funciona corretamente em todas essas situa\u00e7\u00f5es. A abordagem modular para escrever esses testes facilita a leitura e a manuten\u00e7\u00e3o, al\u00e9m de permitir uma cobertura de teste abrangente e robusta.</p>"},{"location":"10/#executando-os-testes","title":"Executando os testes","text":"<p>\u00c9 importante n\u00e3o esquecermos de executar os testes para ver se tudo corre bem:</p> <pre><code>task test tests/test_todos.py\n# ...\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\n</code></pre>"},{"location":"10/#endpoint-de-alteracao","title":"Endpoint de Altera\u00e7\u00e3o","text":"<p>Para fazer a altera\u00e7\u00e3o de uma tarefa, precisamos de um modelo onde tudo seja opcional, j\u00e1 que poder\u00edamos querer atualizar apenas um ou alguns campos da tarefa. Criaremos o esquema <code>TodoUpdate</code>, no qual todos os campos s\u00e3o opcionais:</p> fast_zero/schemas.py<pre><code>class TodoUpdate(BaseModel):\n    title: str | None = None\n    description: str | None = None\n    state: TodoState | None = None\n</code></pre> <p>Para podermos alterar somente os valores que recebemos no modelo, temos que fazer um <code>dump</code> somente dos valores que recebemos e os atualizar no objeto que pegamos da base de dados:</p> fast_zero/routers/todos.py<pre><code>from http import HTTPStatus\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, Query\n# ...\nfrom fast_zero.schemas import TodoList, TodoPublic, TodoSchema, TodoUpdate\n\n# ...\n\n@router.patch('/{todo_id}', response_model=TodoPublic)\nasync def patch_todo(\n    todo_id: int, session: Session, user: CurrentUser, todo: TodoUpdate\n):\n    db_todo = await session.scalar(\n        select(Todo).where(Todo.user_id == user.id, Todo.id == todo_id)\n    )\n\n    if not db_todo:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='Task not found.'\n        )\n\n    for key, value in todo.model_dump(exclude_unset=True).items():\n        setattr(db_todo, key, value)\n\n    session.add(db_todo)\n    await session.commit()\n    await session.refresh(db_todo)\n\n    return db_todo\n</code></pre> <p>A linha <code>for key, value in todo.model_dump(exclude_unset=True).items():</code> est\u00e1 iterando atrav\u00e9s de todos os campos definidos na inst\u00e2ncia <code>todo</code> do modelo de atualiza\u00e7\u00e3o. A fun\u00e7\u00e3o <code>model_dump</code> \u00e9 um m\u00e9todo que vem do modelo <code>BaseModel</code> do Pydantic e permite exportar o modelo para um dicion\u00e1rio.</p> <p>O par\u00e2metro <code>exclude_unset=True</code> \u00e9 importante aqui, pois significa que apenas os campos que foram explicitamente definidos (ou seja, aqueles que foram inclu\u00eddos na solicita\u00e7\u00e3o PATCH) ser\u00e3o inclu\u00eddos no dicion\u00e1rio resultante. Isso permite que voc\u00ea atualize apenas os campos que foram fornecidos na solicita\u00e7\u00e3o, deixando os outros inalterados.</p> <p>Ap\u00f3s obter a chave e o valor de cada campo definido, a linha <code>setattr(db_todo, key, value)</code> \u00e9 usada para atualizar o objeto <code>db_todo</code> que representa a tarefa no banco de dados. A fun\u00e7\u00e3o <code>setattr</code> \u00e9 uma fun\u00e7\u00e3o embutida do Python que permite definir o valor de um atributo em um objeto. Neste caso, ele est\u00e1 definindo o atributo com o nome igual \u00e0 chave (ou seja, o nome do campo) no objeto <code>db_todo</code> com o valor correspondente.</p> <p>Dessa forma, garantimos que somente os campos enviados ao schema sejam atualizados no objeto.</p>"},{"location":"10/#testes-para-o-endpoint-de-alteracao","title":"Testes para o Endpoint de Altera\u00e7\u00e3o","text":"<p>Os testes aqui incluem o caso de atualiza\u00e7\u00e3o bem-sucedida e o caso de erro quando a tarefa n\u00e3o \u00e9 encontrada:</p> fast_zero/tests/test_todos.py<pre><code>from http import HTTPStatus\n\n# ...\n\ndef test_patch_todo_error(client, token):\n    response = client.patch(\n        '/todos/10',\n        json={},\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'Task not found.'}\n\n\n@pytest.mark.asyncio\nasync def test_patch_todo(session, client, user, token):\n    todo = TodoFactory(user_id=user.id)\n\n    session.add(todo)\n    await session.commit()\n\n    response = client.patch(\n        f'/todos/{todo.id}',\n        json={'title': 'teste!'},\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == HTTPStatus.OK\n    assert response.json()['title'] == 'teste!'\n</code></pre> <p>Agora precisamos executar os testes para ver se est\u00e1 tudo correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n\n# ...\n\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\n</code></pre> <p>Com tudo funcionando, podemos partir para o nosso endpoint de DELETE.</p>"},{"location":"10/#endpoint-de-delecao","title":"Endpoint de Dele\u00e7\u00e3o","text":"<p>A rota para deletar uma tarefa \u00e9 simples e direta. Caso o <code>todo</code> exista, deletaremos ele com a <code>sesion</code> caso n\u00e3o, retornamos <code>404</code>:</p> fast_zero/routers/todos.py<pre><code>from fast_zero.schemas import (\n    TodoList,\n    TodoPublic,\n    TodoSchema,\n)\n\n# ...\n\n\n@router.delete('/{todo_id}', response_model=Message)\nasync def delete_todo(todo_id: int, session: Session, user: CurrentUser):\n    todo = await session.scalar(\n        select(Todo).where(Todo.user_id == user.id, Todo.id == todo_id)\n    )\n\n    if not todo:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='Task not found.'\n        )\n\n    await session.delete(todo)\n    await session.commit()\n\n    return {'message': 'Task has been deleted successfully.'}\n</code></pre>"},{"location":"10/#testes-para-o-endpoint-de-delecao","title":"Testes para o Endpoint de Dele\u00e7\u00e3o","text":"<p>Esses testes verificam tanto a remo\u00e7\u00e3o bem-sucedida quanto o caso de erro quando a tarefa n\u00e3o \u00e9 encontrada:</p> fast_zero/tests/test_todos.py<pre><code>@pytest.mark.asyncio\nasync def test_delete_todo(session, client, user, token):\n    todo = TodoFactory(user_id=user.id)\n\n    session.add(todo)\n    await session.commit()\n\n    response = client.delete(\n        f'/todos/{todo.id}', headers={'Authorization': f'Bearer {token}'}\n    )\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'message': 'Task has been deleted successfully.'\n    }\n\n\ndef test_delete_todo_error(client, token):\n    response = client.delete(\n        f'/todos/{10}', headers={'Authorization': f'Bearer {token}'}\n    )\n\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'Task not found.'}\n</code></pre> <p>Por fim, precisamos executar os testes para ver se est\u00e1 tudo correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n\n# ...\n\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\ntests/test_todos.py::test_delete_todo PASSED\ntests/test_todos.py::test_delete_todo_error PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\n</code></pre>"},{"location":"10/#commit","title":"Commit","text":"<p>Agora que voc\u00ea finalizou a implementa\u00e7\u00e3o desses endpoints, \u00e9 um bom momento para fazer um commit das suas mudan\u00e7as. Para isso, voc\u00ea pode seguir os seguintes passos:</p> <ol> <li>Adicione as mudan\u00e7as para a stage area: <code>git add .</code></li> <li>Commit as mudan\u00e7as: <code>git commit -m \"Implementado os endpoints de tarefas\"</code></li> </ol>"},{"location":"10/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Na pr\u00f3xima aula vamos criar containers docker da nossa aplica\u00e7\u00e3o caso n\u00e3o tenha nenhuma experi\u00eancia com docker a Linuxtips tem uma playlist completa e gr\u00e1tis sobre docker no canal deles no YouTube)</p>"},{"location":"10/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li> <p>Adicione os campos <code>created_at</code> e <code>updated_at</code> na tabela <code>Todo</code></p> <ul> <li>Eles devem ser <code>init=False</code></li> <li>Deve usar <code>func.now()</code> para cria\u00e7\u00e3o</li> <li>O campo <code>updated_at</code> deve ter <code>onupdate</code></li> </ul> </li> <li> <p>Criar uma migra\u00e7\u00e3o para que os novos campos sejam versionados e tamb\u00e9m aplicar a migra\u00e7\u00e3o</p> </li> <li>Adicionar os campos <code>created_at</code> e <code>updated_at</code> no schema de sa\u00edda dos endpoints. Para que esse valores sejam retornados na API. Essa altera\u00e7\u00e3o deve ser refletida nos testes tamb\u00e9m!</li> <li>Crie um teste para o endpoint de busca (GET) que valide todos os campos contidos no <code>Todo</code> de resposta. At\u00e9 o momento, todas as valida\u00e7\u00f5es foram feitas pelo tamanho do resultado de todos.</li> <li>Crie um teste para validar o caso do <code>Enum</code> em <code>state: Mapped[TodoState]</code> na tabela <code>TODO</code>, onde o valor esteja fora dos valores mapeados por ele. Isso for\u00e7ar\u00e1 um erro que pode ser validado com <code>pytest.raises</code></li> <li>Crie dois testes para validar a busca por <code>todos</code>.</li> <li>Um com o <code>title</code> com um texto menor do que <code>3</code> caracteres</li> <li>Um com o <code>title</code> com um texto maior do que <code>20</code> caracteres</li> </ol> <p>Exerc\u00edcios resolvidos </p>"},{"location":"10/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula exploramos os aspectos essenciais para construir uma API completa e funcional para gerenciar tarefas, integrando-se ao sistema de autentica\u00e7\u00e3o que j\u00e1 t\u00ednhamos desenvolvido.</p> <p>Iniciamos criando a estrutura de banco de dados para as tarefas, incluindo tabelas e migra\u00e7\u00f5es, e em seguida definimos os schemas necess\u00e1rios. A partir da\u00ed, trabalhamos na cria\u00e7\u00e3o dos endpoints para as opera\u00e7\u00f5es CRUD: cria\u00e7\u00e3o, leitura (listagem com filtragem), atualiza\u00e7\u00e3o (edi\u00e7\u00e3o) e exclus\u00e3o (dele\u00e7\u00e3o).</p> <p>Em cada est\u00e1gio, focamos na qualidade e na robustez, utilizando testes rigorosos para assegurar que os endpoints se comportassem conforme esperado. Exploramos tamb\u00e9m t\u00e9cnicas espec\u00edficas como atualiza\u00e7\u00e3o parcial e filtragem avan\u00e7ada, tornando a API flex\u00edvel e poderosa.</p> <p>O resultado foi um sistema integrado de gerenciamento de tarefas, ou um \"todo list\", ligado aos usu\u00e1rios e \u00e0 autentica\u00e7\u00e3o que j\u00e1 hav\u00edamos implementado. Esta aula refor\u00e7ou a import\u00e2ncia de um design cuidadoso e uma implementa\u00e7\u00e3o criteriosa, ilustrando como a FastAPI pode ser usada para criar APIs eficientes e profissionais.</p> <p>Agora que a nossa aplica\u00e7\u00e3o est\u00e1 crescendo e ganhando mais funcionalidades, na pr\u00f3xima aula, mergulharemos no mundo da dockeriza\u00e7\u00e3o. Aprenderemos a colocar a nossa aplica\u00e7\u00e3o dentro de um container Docker, facilitando o deploy e o escalonamento. Este \u00e9 um passo vital no desenvolvimento moderno de aplica\u00e7\u00f5es e estou ansioso para gui\u00e1-lo atrav\u00e9s dele. At\u00e9 l\u00e1!</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"11/","title":"Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":""},{"location":"11/#dockerizando-a-nossa-aplicacao-e-introduzindo-o-postgresql","title":"Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender os conceitos b\u00e1sicos do Docker</li> <li>Entender como criar uma imagem Docker para a nossa aplica\u00e7\u00e3o FastAPI</li> <li>Aprender a rodar a aplica\u00e7\u00e3o utilizando Docker</li> <li>Introduzir o conceito de Docker Compose para gerenciamento de m\u00faltiplos cont\u00eaineres</li> <li>Aprender o que \u00e9 um Dockerfile e sua estrutura</li> <li>Entender os benef\u00edcios e motivos da mudan\u00e7a de SQLite para PostgreSQL</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz </p> <p>Ap\u00f3s a implementa\u00e7\u00e3o do nosso gerenciador de tarefas na aula anterior, temos uma primeira vers\u00e3o est\u00e1vel da nossa aplica\u00e7\u00e3o. Nesta aula, al\u00e9m de aprendermos a \"dockerizar\" nossa aplica\u00e7\u00e3o FastAPI, tamb\u00e9m abordaremos a migra\u00e7\u00e3o do banco de dados SQLite para o PostgreSQL.</p>"},{"location":"11/#o-docker-e-a-nossa-aplicacao","title":"O Docker e a nossa aplica\u00e7\u00e3o","text":"<p>Docker \u00e9 uma plataforma aberta que permite automatizar o processo de implanta\u00e7\u00e3o, escalonamento e opera\u00e7\u00e3o de aplica\u00e7\u00f5es dentro de cont\u00eaineres. Ele serve para \"empacotar\" uma aplica\u00e7\u00e3o e suas depend\u00eancias em um cont\u00eainer virtual que pode ser executado em qualquer sistema operacional que suporte Docker. Isso facilita a implanta\u00e7\u00e3o, o desenvolvimento e o compartilhamento de aplica\u00e7\u00f5es, al\u00e9m de proporcionar um ambiente isolado e consistente.</p> Caso n\u00e3o tenha o docker instalado na sua m\u00e1quina <p>A instala\u00e7\u00e3o do Docker varia entre sistemas operacionais. Por esse motivo, acredito que n\u00e3o cabe cobrir a instala\u00e7\u00e3o do docker nesse material.</p> WindowsLinuxMacOS X <p>A instala\u00e7\u00e3o no windows varia com a forma em que voc\u00ea administra o seu sistema. Ela pode se basear em WSL2 ou no Hyper-V.</p> <p>Os passos para ambos os tipos de instala\u00e7\u00e3o podem ser encontrados na documenta\u00e7\u00e3o oficial do docker: link.</p> <p>A instala\u00e7\u00e3o no linux variar\u00e1 de acordo com a sua distribui\u00e7\u00e3o. As distribui\u00e7\u00f5es mais tradicionais (baseadas em Debian e RHEL podem ser encontradas na documenta\u00e7\u00e3o oficial do docker: link.</p> <p>Outras distribui\u00e7\u00f5es devem ter o pacote do docker dispon\u00edvel em seus reposit\u00f3rios. Como distro baseadas em Archlinux.</p> <p>A instala\u00e7\u00e3o no MacOS, depender\u00e1 da arquitetura do seu computador. Se voc\u00ea usa Intel ou Silicon.</p> <p>Os passos para ambos os tipos de instala\u00e7\u00e3o podem ser encontrados na documenta\u00e7\u00e3o oficial do docker: link.</p>"},{"location":"11/#criando-nosso-dockerfile","title":"Criando nosso Dockerfile","text":"<p>Para criar um container Docker, escrevemos uma lista de passos de como construir o ambiente para execu\u00e7\u00e3o da nossa aplica\u00e7\u00e3o em um arquivo chamado <code>Dockerfile</code>. Ele define o ambiente de execu\u00e7\u00e3o, os comandos necess\u00e1rios para preparar o ambiente e o comando a ser executado quando um cont\u00eainer \u00e9 iniciado a partir da imagem.</p> <p>Uma das coisas interessantes sobre Docker \u00e9 que existe um Hub de containers prontos onde a comunidade hospeda imagens \"prontas\", que podemos usar como ponto de partida. Por exemplo, a comunidade de python mant\u00e9m um grupo de imagens com o ambiente python pronto para uso. Podemos partir dessa imagem com o python j\u00e1 instalado adicionar os passos para que nossa aplica\u00e7\u00e3o seja executada.</p> <p>Aqui est\u00e1 um exemplo de <code>Dockerfile</code> para executar nossa aplica\u00e7\u00e3o:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 Dockerfile<pre><code>FROM python:3.14-slim\nENV POETRY_VIRTUALENVS_CREATE=false\n\nWORKDIR app/\nCOPY . .\n\nRUN pip install poetry\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi --without dev\n\nEXPOSE 8000\nCMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.14-slim</code>: define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.14, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual. (O container j\u00e1 \u00e9 um ambiente isolado)</li> <li><code>RUN pip install poetry</code>: instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>WORKDIR app/</code>: define o diret\u00f3rio em que executaremos os comandos a seguir.</li> <li><code>COPY . .</code>: copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi --without dev</code>: instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output. O par\u00e2metro <code>--without dev</code> diz ao poetry que n\u00e3o queremos as bibliotecas de desenvolvimento. Pois, no docker n\u00e3o executaremos os testes.</li> <li><code>EXPOSE 8000</code>: informa ao Docker que o cont\u00eainer escutar\u00e1 na porta 8000.</li> <li><code>CMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app</code>: define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado.</li> </ol> Dockerfile<pre><code>FROM python:3.13-slim\nENV POETRY_VIRTUALENVS_CREATE=false\n\nWORKDIR app/\nCOPY . .\n\nRUN pip install poetry\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi --without dev\n\nEXPOSE 8000\nCMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.13-slim</code>: define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.13, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual. (O container j\u00e1 \u00e9 um ambiente isolado)</li> <li><code>RUN pip install poetry</code>: instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>WORKDIR app/</code>: define o diret\u00f3rio em que executaremos os comandos a seguir.</li> <li><code>COPY . .</code>: copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi --without dev</code>: instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output. O par\u00e2metro <code>--without dev</code> diz ao poetry que n\u00e3o queremos as bibliotecas de desenvolvimento. Pois, no docker n\u00e3o executaremos os testes.</li> <li><code>EXPOSE 8000</code>: informa ao Docker que o cont\u00eainer escutar\u00e1 na porta 8000.</li> <li><code>CMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app</code>: define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado.</li> </ol> Dockerfile<pre><code>FROM python:3.12-slim\nENV POETRY_VIRTUALENVS_CREATE=false\n\nWORKDIR app/\nCOPY . .\n\nRUN pip install poetry\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi --without dev\n\nEXPOSE 8000\nCMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.12-slim</code>: define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.12, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual. (O container j\u00e1 \u00e9 um ambiente isolado)</li> <li><code>RUN pip install poetry</code>: instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>WORKDIR app/</code>: define o diret\u00f3rio em que executaremos os comandos a seguir.</li> <li><code>COPY . .</code>: copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi --without dev</code>: instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output. O par\u00e2metro <code>--without dev</code> diz ao poetry que n\u00e3o queremos as bibliotecas de desenvolvimento. Pois, no docker n\u00e3o executaremos os testes.</li> <li><code>EXPOSE 8000</code>: informa ao Docker que o cont\u00eainer escutar\u00e1 na porta 8000.</li> <li><code>CMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app</code>: define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado.</li> </ol> Dockerfile<pre><code>FROM python:3.11-slim\nENV POETRY_VIRTUALENVS_CREATE=false\n\nWORKDIR app/\nCOPY . .\n\nRUN pip install poetry\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi --without dev\n\nEXPOSE 8000\nCMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.11-slim</code>: define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.11, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual. (O container j\u00e1 \u00e9 um ambiente isolado)</li> <li><code>RUN pip install poetry</code>: instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>WORKDIR app/</code>: define o diret\u00f3rio em que executaremos os comandos a seguir.</li> <li><code>COPY . .</code>: copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi --without dev</code>: instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output. O par\u00e2metro <code>--without dev</code> diz ao poetry que n\u00e3o queremos as bibliotecas de desenvolvimento. Pois, no docker n\u00e3o executaremos os testes.</li> <li><code>EXPOSE 8000</code>: informa ao Docker que o cont\u00eainer escutar\u00e1 na porta 8000.</li> <li><code>CMD poetry run uvicorn --host 0.0.0.0 fast_zero.app:app</code>: define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado.</li> </ol> <p>Vamos entender melhor esse \u00faltimo comando:</p> <ul> <li><code>poetry run</code> define o comando que ser\u00e1 executado no ambiente virtual criado pelo Poetry.</li> <li><code>uvicorn</code> \u00e9 o servidor ASGI que usamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>--host</code> define o host que o servidor escutar\u00e1. Especificamente, <code>\"0.0.0.0\"</code> \u00e9 um endere\u00e7o IP que permite que o servidor aceite conex\u00f5es de qualquer endere\u00e7o de rede dispon\u00edvel, tornando-o acess\u00edvel externamente.</li> <li><code>fast_zero.app:app</code> define o <code>&lt;m\u00f3dulo python&gt;:&lt;objeto&gt;</code> que o servidor executar\u00e1.</li> </ul>"},{"location":"11/#criando-a-imagem","title":"Criando a imagem","text":"<p>Para criar uma imagem Docker a partir do Dockerfile, usamos o comando <code>docker build</code>. O comando a seguir cria uma imagem chamada \"fast_zero\":</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker build -t \"fast_zero\" .\n</code></pre> Voc\u00ea usa Mac com Silicon? <p>Pode haver alguma incompatibilidade em alguma biblioteca durante o build. Pois nem todos os pacotes est\u00e3o dispon\u00edveis para Silicon no pypi. Arquitetura <code>aarch64</code>.</p> <p>Caso encontre algum problema, durante o build voc\u00ea pode especificar a plataforma para <code>amd64</code>. Que \u00e9 a arquitetura em que o curso foi escrito:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker build --platform linux/amd64 -t \"fast_zero\" .\n</code></pre> <p>Mais informa\u00e7\u00f5es nessa issue. Obrigado @K-dash por notificar </p> <p>Este comando l\u00ea o Dockerfile no diret\u00f3rio atual (indicado pelo <code>.</code>) e cria uma imagem com a tag \"fast_zero\", (indicada pelo <code>-t</code>).</p> <p>Ent\u00e3o verificaremos se a imagem foi criada com sucesso usando o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker images\n</code></pre> <p>Este comando lista todas as imagens Docker dispon\u00edveis no seu sistema.</p>"},{"location":"11/#executando-o-container","title":"Executando o container","text":"<p>Para executar o cont\u00eainer, usamos o comando <code>docker run</code>. Especificamos o nome do cont\u00eainer com a flag <code>--name</code>, indicamos a imagem que queremos executar e a tag que queremos usar <code>&lt;nome_da_imagem&gt;:&lt;tag&gt;</code>. A flag <code>-p</code> serve para mapear a porta do host para a porta do cont\u00eainer <code>&lt;porta_do_host&gt;:&lt;porta_do_cont\u00eainer&gt;</code>. Portanto, teremos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -it --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> <p>Este comando iniciar\u00e1 nossa aplica\u00e7\u00e3o em um cont\u00eainer Docker, que estar\u00e1 escutando na porta 8000. Para testar se tudo est\u00e1 funcionando corretamente, voc\u00ea pode acessar <code>http://localhost:8000</code> em um navegador ou usar um comando como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>curl http://localhost:8000\n</code></pre> Caso voc\u00ea fique preso no terminal <p>Caso voc\u00ea tenha a aplica\u00e7\u00e3o travada no terminal e n\u00e3o consiga sair, voc\u00ea pode teclar Ctrl+C para parar a execu\u00e7\u00e3o do container.</p>"},{"location":"11/#gerenciando-containers-docker","title":"Gerenciando Containers docker","text":"<p>Quando voc\u00ea trabalha com Docker, \u00e9 importante saber como gerenciar os cont\u00eaineres. Aqui est\u00e3o algumas opera\u00e7\u00f5es b\u00e1sicas para gerenci\u00e1-los:</p> <ol> <li> <p>Rodar um cont\u00eainer em background: se voc\u00ea deseja executar o cont\u00eainer em segundo plano para que n\u00e3o ocupe o terminal, pode usar a op\u00e7\u00e3o <code>-d</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> </li> <li> <p>Parar um cont\u00eainer: quando voc\u00ea \"para\" um cont\u00eainer, est\u00e1 essencialmente interrompendo a execu\u00e7\u00e3o do processo principal do cont\u00eainer. Isso significa que o cont\u00eainer n\u00e3o est\u00e1 mais ativo, mas ainda existe no sistema, com seus dados associados e configura\u00e7\u00e3o. Isso permite que voc\u00ea reinicie o cont\u00eainer posteriormente, se desejar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker stop fastzeroapp\n</code></pre> </li> <li> <p>Remover um cont\u00eainer: ao \"remover\" um cont\u00eainer, voc\u00ea est\u00e1 excluindo o cont\u00eainer do sistema. Isso significa que todos os dados associados ao cont\u00eainer s\u00e3o apagados. Uma vez que um cont\u00eainer \u00e9 removido, voc\u00ea n\u00e3o pode reinici\u00e1-lo; no entanto, voc\u00ea pode sempre criar um novo cont\u00eainer a partir da mesma imagem.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker rm fastzeroapp\n</code></pre> </li> </ol> <p>Ambos os comandos (stop e rm) usam o nome do cont\u00eainer que definimos anteriormente com a flag <code>--name</code>. \u00c9 uma boa pr\u00e1tica manter a gest\u00e3o dos seus cont\u00eaineres, principalmente durante o desenvolvimento, para evitar um uso excessivo de recursos ou conflitos de nomes e portas.</p>"},{"location":"11/#introduzindo-o-postgresql","title":"Introduzindo o postgreSQL","text":"<p>O PostgreSQL \u00e9 um Sistema de Gerenciamento de Banco de Dados Objeto-Relacional (ORDBMS) poderoso e de c\u00f3digo aberto. Ele \u00e9 amplamente utilizado em produ\u00e7\u00e3o em muitos projetos devido \u00e0 sua robustez, escalabilidade e conjunto de recursos extensos.</p> <p>Mudar para um banco de dados como PostgreSQL tem v\u00e1rios benef\u00edcios:</p> <ul> <li>Escalabilidade: SQLite n\u00e3o \u00e9 ideal para aplica\u00e7\u00f5es em larga escala ou com grande volume de dados. PostgreSQL foi projetado para lidar com uma grande quantidade de dados e requisi\u00e7\u00f5es.</li> <li>Concorr\u00eancia: diferentemente do SQLite, que tem limita\u00e7\u00f5es para grava\u00e7\u00f5es simult\u00e2neas, o PostgreSQL suporta m\u00faltiplas opera\u00e7\u00f5es simult\u00e2neas.</li> <li>Funcionalidades avan\u00e7adas: PostgreSQL vem com v\u00e1rias extens\u00f5es e funcionalidades que o SQLite pode n\u00e3o oferecer.</li> </ul> <p>Al\u00e9m disso, SQLite tem algumas limita\u00e7\u00f5es que podem torn\u00e1-lo inadequado para produ\u00e7\u00e3o em alguns casos. Por exemplo, ele n\u00e3o suporta alta concorr\u00eancia e pode ter problemas de performance com grandes volumes de dados.</p> <p>Nota</p> <p>Embora para o escopo da nossa aplica\u00e7\u00e3o e os objetivos de aprendizado o SQLite pudesse ser suficiente, \u00e9 sempre bom nos prepararmos para cen\u00e1rios de produ\u00e7\u00e3o real. A ado\u00e7\u00e3o de PostgreSQL nos d\u00e1 uma pr\u00e9via das pr\u00e1ticas do mundo real e garante que nossa aplica\u00e7\u00e3o possa escalar sem grandes modifica\u00e7\u00f5es de infraestrutura.</p>"},{"location":"11/#como-executar-o-postgres","title":"Como executar o postgres?","text":"<p>Embora o PostgreSQL seja poderoso, sua instala\u00e7\u00e3o direta em uma m\u00e1quina real pode ser desafiadora e pode resultar em configura\u00e7\u00f5es diferentes entre os ambientes de desenvolvimento. Felizmente, podemos utilizar o Docker para resolver esse problema. No Docker Hub, est\u00e3o dispon\u00edveis imagens pr\u00e9-constru\u00eddas do PostgreSQL, permitindo-nos executar o PostgreSQL com um \u00fanico comando. Confira a imagem oficial do PostgreSQL.</p> <p>Para executar um cont\u00eainer do PostgreSQL, use o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d \\\n    --name app_database \\\n    -e POSTGRES_USER=app_user \\\n    -e POSTGRES_DB=app_db \\\n    -e POSTGRES_PASSWORD=app_password \\\n    -p 5432:5432 \\\n    postgres\n</code></pre>"},{"location":"11/#explicando-as-flags-e-configuracoes","title":"Explicando as Flags e Configura\u00e7\u00f5es","text":"<ul> <li>Flag <code>-e</code>:</li> </ul> <p>Esta flag \u00e9 usada para definir vari\u00e1veis de ambiente no cont\u00eainer. No contexto do PostgreSQL, essas vari\u00e1veis s\u00e3o essenciais. Elas configuram o nome de usu\u00e1rio, nome do banco de dados, e senha durante a primeira execu\u00e7\u00e3o do cont\u00eainer. Sem elas, o PostgreSQL pode n\u00e3o iniciar da forma esperada. \u00c9 uma forma pr\u00e1tica de configurar o PostgreSQL sem interagir manualmente ou criar arquivos de configura\u00e7\u00e3o.</p> <ul> <li>Porta <code>5432</code>:</li> </ul> <p>O PostgreSQL, por padr\u00e3o, escuta por conex\u00f5es na porta <code>5432</code>. Mapeando esta porta do cont\u00eainer para a mesma porta no host (usando <code>-p</code>), fazemos com que o PostgreSQL seja acess\u00edvel nesta porta na m\u00e1quina anfitri\u00e3, permitindo que outras aplica\u00e7\u00f5es se conectem a ele.</p> <p>Sobre as vari\u00e1veis</p> <p>Os valores acima (<code>app_user</code>, <code>app_db</code>, e <code>app_password</code>) s\u00e3o padr\u00f5es gen\u00e9ricos para facilitar a inicializa\u00e7\u00e3o do PostgreSQL em um ambiente de desenvolvimento. No entanto, \u00e9 altamente recomend\u00e1vel que voc\u00ea altere esses valores, especialmente <code>app_password</code>, para garantir a seguran\u00e7a do seu banco de dados.</p>"},{"location":"11/#volumes-e-persistencia-de-dados","title":"Volumes e Persist\u00eancia de Dados","text":"<p>Para garantir a persist\u00eancia dos dados entre execu\u00e7\u00f5es do cont\u00eainer, utilizamos volumes. Um volume mapeia um diret\u00f3rio do sistema host para um diret\u00f3rio no cont\u00eainer. Isso \u00e9 crucial para bancos de dados, pois sem um volume, ao remover o cont\u00eainer, todos os dados armazenados dentro dele se perderiam.</p> <p>No PostgreSQL, o diret\u00f3rio padr\u00e3o para armazenamento de dados \u00e9 <code>/var/lib/postgresql/data</code>. Mapeamos esse diret\u00f3rio para um volume (neste caso \"pgdata\") em nossa m\u00e1quina host para garantir a persist\u00eancia dos dados:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d \\\n    --name app_database \\\n    -e POSTGRES_USER=app_user \\\n    -e POSTGRES_DB=app_db \\\n    -e POSTGRES_PASSWORD=app_password \\\n    -v pgdata:/var/lib/postgresql/data \\\n    -p 5432:5432 \\\n    postgres\n</code></pre> <p>O par\u00e2metro do volume \u00e9 passado ao cont\u00eainer usando o par\u00e2metro <code>-v</code> Dessa forma, os dados do banco continuar\u00e3o existindo, mesmo que o cont\u00eainer seja reiniciado ou removido.</p>"},{"location":"11/#adicionando-o-suporte-ao-postgresql-na-nossa-aplicacao","title":"Adicionando o suporte ao PostgreSQL na nossa aplica\u00e7\u00e3o","text":"<p>Para que o SQLAlchemy suporte o PostgreSQL, precisamos instalar uma depend\u00eancia chamada <code>psycopg</code>. Este \u00e9 o adaptador PostgreSQL para Python e \u00e9 crucial para fazer a comunica\u00e7\u00e3o.</p> <p>Para instalar essa depend\u00eancia, utilize o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add \"psycopg[binary]\"\n</code></pre> <p>Uma das vantagens do SQLAlchemy enquanto ORM \u00e9 a flexibilidade. Com apenas algumas altera\u00e7\u00f5es m\u00ednimas, como a atualiza\u00e7\u00e3o da string de conex\u00e3o, podemos facilmente transicionar para um banco de dados diferente. Assim, ap\u00f3s ajustar o arquivo <code>.env</code> com a string de conex\u00e3o do PostgreSQL, a aplica\u00e7\u00e3o dever\u00e1 operar normalmente, mas desta vez utilizando o PostgreSQL.</p> <p>Para ajustar a conex\u00e3o com o PostgreSQL, modifique seu arquivo <code>.env</code> para incluir a seguinte string de conex\u00e3o:</p> .env<pre><code>DATABASE_URL=\"postgresql+psycopg://app_user:app_password@localhost:5432/app_db\"\n</code></pre> <p>Caso tenha alterado as vari\u00e1veis de ambiente do cont\u00eainer</p> <p>Se voc\u00ea alterou <code>app_user</code>, <code>app_password</code> ou <code>app_db</code> ao inicializar o cont\u00eainer PostgreSQL, garanta que esses valores sejam refletidos na string de conex\u00e3o acima. A palavra <code>localhost</code> indica que o banco de dados PostgreSQL est\u00e1 sendo executado na mesma m\u00e1quina que sua aplica\u00e7\u00e3o. Se o banco de dados estiver em uma m\u00e1quina diferente, substitua <code>localhost</code> pelo endere\u00e7o IP correspondente e, se necess\u00e1rio, ajuste a porta <code>5432</code>.</p> <p>Para que a instala\u00e7\u00e3o do <code>psycopg</code> esteja na imagem docker, precisamos fazer um novo build. Para que a nova vers\u00e3o do <code>pyproject.toml</code> seja copiada e os novos pacotes sejam instalados:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker rm fastzeroapp #(1)!\ndocker build -t \"fast_zero\" . #(2)!\ndocker run -it --name fastzeroapp -p 8000:8000 fast_zero:latest #(3)!\n</code></pre> <ol> <li>Remove a vers\u00e3o antiga</li> <li>Refaz o build</li> <li>Executa novamente</li> </ol>"},{"location":"11/#executando-as-migracoes","title":"Executando as migra\u00e7\u00f5es","text":"<p>Migra\u00e7\u00f5es s\u00e3o como vers\u00f5es para seu banco de dados, permitindo que voc\u00ea atualize sua estrutura de forma ordenada e controlada. Sempre que mudamos de banco de dados, ou at\u00e9 mesmo quando alteramos sua estrutura, as migra\u00e7\u00f5es precisam ser executadas para garantir que a base de dados esteja em sincronia com nosso c\u00f3digo.</p> <p>No contexto de cont\u00eaineres, rodar as migra\u00e7\u00f5es se torna ainda mais simples. Quando mudamos de banco de dados, como \u00e9 o caso de termos sa\u00eddo de um SQLite (por exemplo) para um PostgreSQL, as migra\u00e7\u00f5es s\u00e3o essenciais. O motivo \u00e9 simples: o novo banco de dados n\u00e3o ter\u00e1 a estrutura e os dados do antigo, a menos que migremos. As migra\u00e7\u00f5es ir\u00e3o garantir que o novo banco de dados tenha a mesma estrutura e rela\u00e7\u00f5es que o anterior.</p> Antes de executar o pr\u00f3ximo comando <p>Assegure-se de que ambos os cont\u00eaineres, tanto da aplica\u00e7\u00e3o quanto do banco de dados, estejam ativos. O cont\u00eainer do banco de dados deve estar rodando para que a aplica\u00e7\u00e3o possa se conectar a ele.</p> <p>Assegure-se de que o cont\u00eainer da aplica\u00e7\u00e3o esteja ativo. Estamos usando a flag <code>--network=host</code> para que o cont\u00eainer use a rede do host. Isso pode ser essencial para evitar problemas de conex\u00e3o, j\u00e1 que n\u00e3o podemos prever como est\u00e1 configurada a rede do computador onde este comando ser\u00e1 executado.</p> execu\u00e7\u00e3o no terminal<pre><code>docker run -d --network=host --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> <p>Para aplicar migra\u00e7\u00f5es em um ambiente com cont\u00eaineres, frequentemente temos comandos espec\u00edficos associados ao servi\u00e7o. Vejamos como executar migra\u00e7\u00f5es usando o Docker:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker exec -it fastzeroapp poetry run alembic upgrade head\n</code></pre> <p>O comando <code>docker exec</code> \u00e9 usado para invocar um comando espec\u00edfico dentro de um cont\u00eainer em execu\u00e7\u00e3o. A op\u00e7\u00e3o <code>-it</code> \u00e9 uma combina\u00e7\u00e3o de <code>-i</code> (interativo) e <code>-t</code> (pseudo-TTY), que juntas garantem um terminal interativo, permitindo a comunica\u00e7\u00e3o direta com o cont\u00eainer.</p> <p>Ap\u00f3s executar as migra\u00e7\u00f5es, voc\u00ea pode verificar a cria\u00e7\u00e3o das tabelas utilizando um sistema de gerenciamento de banco de dados. A seguir, apresentamos um exemplo com o Beekeeper Studio:</p> <p></p> <p>Lembre-se: Embora as tabelas estejam agora criadas e estruturadas, o banco de dados ainda n\u00e3o cont\u00e9m os dados anteriormente presentes no SQLite ou em qualquer outro banco que voc\u00ea estivesse utilizando antes.</p>"},{"location":"11/#simplificando-nosso-fluxo-com-docker-compose","title":"Simplificando nosso fluxo com <code>docker-compose</code>","text":"<p>Docker Compose \u00e9 uma ferramenta que permite definir e gerenciar aplicativos multi-cont\u00eainer com Docker. \u00c9 como se voc\u00ea tivesse um maestro conduzindo uma orquestra: o maestro (ou Docker Compose) garante que todos os m\u00fasicos (ou cont\u00eaineres) toquem em harmonia. Definimos nossa aplica\u00e7\u00e3o e servi\u00e7os relacionados, como o PostgreSQL, em um arquivo <code>compose.yaml</code> e os gerenciamos juntos atrav\u00e9s de comandos simplificados.</p> <p>Ao adotar o Docker Compose, facilitamos o desenvolvimento e a execu\u00e7\u00e3o da nossa aplica\u00e7\u00e3o com seus servi\u00e7os dependentes utilizando um \u00fanico comando.</p>"},{"location":"11/#criacao-do-composeyaml","title":"Cria\u00e7\u00e3o do <code>compose.yaml</code>","text":"compose.yaml<pre><code>services:\n  fastzero_database:\n    image: postgres\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    environment:\n      POSTGRES_USER: app_user\n      POSTGRES_DB: app_db\n      POSTGRES_PASSWORD: app_password\n    ports:\n      - \"5432:5432\"\n\n  fastzero_app:\n    image: fastzero_app\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - fastzero_database\n    environment:\n      DATABASE_URL: postgresql+psycopg://app_user:app_password@fastzero_database:5432/app_db\n\nvolumes:\n  pgdata:\n</code></pre> <p>Explica\u00e7\u00e3o linha a linha:</p> <ol> <li> <p><code>services:</code>: define os servi\u00e7os (cont\u00eaineres) que ser\u00e3o gerenciados.</p> </li> <li> <p><code>fastzero_database:</code>: define nosso servi\u00e7o de banco de dados PostgreSQL.</p> </li> <li> <p><code>image: postgres</code>: usa a imagem oficial do PostgreSQL.</p> </li> <li> <p><code>volumes:</code>: mapeia volumes para persist\u00eancia de dados.</p> </li> <li> <p><code>pgdata:/var/lib/postgresql/data</code>: cria ou usa um volume chamado \"pgdata\" e o mapeia para o diret\u00f3rio <code>/var/lib/postgresql/data</code> no cont\u00eainer.</p> </li> <li> <p><code>environment:</code>: define vari\u00e1veis de ambiente para o servi\u00e7o.</p> </li> <li> <p><code>fastzero_app:</code>: define o servi\u00e7o para nossa aplica\u00e7\u00e3o.</p> </li> <li> <p><code>image: fastzero_app</code>: usa a imagem Docker da nossa aplica\u00e7\u00e3o.</p> </li> <li> <p><code>build:</code>: instru\u00e7\u00f5es para construir a imagem se n\u00e3o estiver dispon\u00edvel, procura pelo <code>Dockerfile</code> em <code>.</code>.</p> </li> <li> <p><code>ports:</code>: mapeia portas do cont\u00eainer para o host.</p> </li> <li> <p><code>\"8000:8000\"</code>: mapeia a porta 8000 do cont\u00eainer para a porta 8000 do host.</p> </li> <li> <p><code>depends_on:</code>: especifica que <code>fastzero_app</code> depende de <code>fastzero_database</code>. Isto garante que o banco de dados seja iniciado antes da aplica\u00e7\u00e3o.</p> </li> <li> <p><code>DATABASE_URL: ...</code>: \u00e9 uma vari\u00e1vel de ambiente que nossa aplica\u00e7\u00e3o usar\u00e1 para se conectar ao banco de dados. Aqui, ele se conecta ao servi\u00e7o <code>fastzero_database</code> que definimos anteriormente.</p> </li> <li> <p><code>volumes:</code> (n\u00edvel superior): define volumes que podem ser usados pelos servi\u00e7os.</p> </li> <li> <p><code>pgdata:</code>: define um volume chamado \"pgdata\". Este volume \u00e9 usado para persistir os dados do PostgreSQL entre as execu\u00e7\u00f5es do cont\u00eainer.</p> </li> </ol> <p>Sobre o docker-compose</p> <p>Para usar o Docker Compose, voc\u00ea precisa t\u00ea-lo instalado em seu sistema. Ele n\u00e3o est\u00e1 inclu\u00eddo na instala\u00e7\u00e3o padr\u00e3o do Docker, ent\u00e3o lembre-se de instal\u00e1-lo separadamente!</p> <p>O guia oficial de instala\u00e7\u00e3o pode ser encontrado aqui</p> <p>Com este arquivo <code>compose.yaml</code>, voc\u00ea pode iniciar ambos os servi\u00e7os (aplica\u00e7\u00e3o e banco de dados) simultaneamente usando:</p> <pre><code>docker-compose up\n</code></pre> <p>Para parar os servi\u00e7os e manter os dados seguros nos volumes definidos, use:</p> <pre><code>docker-compose down\n</code></pre> <p>Esses comandos simplificam o fluxo de trabalho e garantem que os servi\u00e7os iniciem corretamente e se comuniquem conforme o esperado.</p> <p>Execu\u00e7\u00e3o em modo desanexado</p> <p>Voc\u00ea pode iniciar os servi\u00e7os em segundo plano com a flag <code>-d</code> usando <code>docker-compose up -d</code>. Isso permite que os cont\u00eaineres rodem em segundo plano, liberando o terminal para outras tarefas.</p>"},{"location":"11/#rodando-as-migracoes-de-forma-automatica","title":"Rodando as migra\u00e7\u00f5es de forma autom\u00e1tica","text":"<p>Automatizar as migra\u00e7\u00f5es do banco de dados \u00e9 uma pr\u00e1tica recomendada para garantir que sua aplica\u00e7\u00e3o esteja sempre sincronizada com o estado mais atual do seu esquema de banco de dados. \u00c9 como preparar todos os ingredientes antes de come\u00e7ar a cozinhar: voc\u00ea garante que tudo o que \u00e9 necess\u00e1rio est\u00e1 pronto para ser usado.</p> <p>Para automatizar as migra\u00e7\u00f5es em nossos cont\u00eaineres Docker, utilizamos um <code>entrypoint</code>. O <code>entrypoint</code> define o comando que ser\u00e1 executado quando o cont\u00eainer iniciar. Em outras palavras, \u00e9 o primeiro ponto de entrada de execu\u00e7\u00e3o do cont\u00eainer.</p> <p>Por que usar o Entrypoint?</p> <p>No Docker, o <code>entrypoint</code> permite que voc\u00ea configure um ambiente de cont\u00eainer que ser\u00e1 executado como um execut\u00e1vel. \u00c9 \u00fatil para preparar o ambiente, como realizar migra\u00e7\u00f5es de banco de dados, antes de iniciar a aplica\u00e7\u00e3o propriamente dita. Isso significa que qualquer comando definido no <code>CMD</code> do Dockerfile n\u00e3o ser\u00e1 executado automaticamente se um <code>entrypoint</code> estiver definido. Em vez disso, precisamos incluir explicitamente esse comando no script de <code>entrypoint</code>.</p> <p>Implementando o Entrypoint</p> <p>Criamos um script chamado <code>entrypoint.sh</code> que ir\u00e1 preparar nosso ambiente antes de a aplica\u00e7\u00e3o iniciar:</p> entrypoint.sh<pre><code>#!/bin/sh\n\n# Executa as migra\u00e7\u00f5es do banco de dados\npoetry run alembic upgrade head\n\n# Inicia a aplica\u00e7\u00e3o\npoetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app\n</code></pre> <p>Explica\u00e7\u00e3o Detalhada do Script:</p> <ul> <li><code>#!/bin/sh</code>: indica ao sistema operacional que o script deve ser executado no shell Unix.</li> <li><code>poetry run alembic upgrade head</code>: roda as migra\u00e7\u00f5es do banco de dados at\u00e9 a \u00faltima vers\u00e3o.</li> <li><code>poetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app</code>: inicia a aplica\u00e7\u00e3o. Este \u00e9 o comando que normalmente estaria no <code>CMD</code> do Dockerfile, mas agora est\u00e1 inclu\u00eddo no <code>entrypoint</code> para garantir que as migra\u00e7\u00f5es sejam executadas antes do servidor iniciar.</li> </ul> <p>Como Funciona na Pr\u00e1tica?</p> <p>Quando o cont\u00eainer \u00e9 iniciado, o Docker executa o script de <code>entrypoint</code>, que por sua vez executa as migra\u00e7\u00f5es e s\u00f3 ent\u00e3o inicia a aplica\u00e7\u00e3o. Isso garante que o banco de dados esteja atualizado com as \u00faltimas migra\u00e7\u00f5es antes de qualquer intera\u00e7\u00e3o com a aplica\u00e7\u00e3o.</p> <p>Visualizando o Processo:</p> <p>Voc\u00ea pode pensar no <code>entrypoint.sh</code> como o ato de aquecer e verificar todos os instrumentos antes de uma apresenta\u00e7\u00e3o musical. Antes de a m\u00fasica come\u00e7ar, cada instrumento \u00e9 afinado e testado. Da mesma forma, nosso script assegura que o banco de dados est\u00e1 em harmonia com a aplica\u00e7\u00e3o antes de ela come\u00e7ar a receber requisi\u00e7\u00f5es.</p> <p>Adicionando o Entrypoint ao Docker Compose:</p> <p>Inclu\u00edmos o <code>entrypoint</code> no nosso servi\u00e7o no arquivo <code>compose.yaml</code>, garantindo que esteja apontando para o script correto:</p> compose.yaml<pre><code>  fastzero_app:\n    image: fastzero_app\n    entrypoint: ./entrypoint.sh\n    build: .\n</code></pre> <p>Reconstruindo e Executando com Novas Configura\u00e7\u00f5es:</p> <p>Para aplicar as altera\u00e7\u00f5es, reconstru\u00edmos e executamos os servi\u00e7os com a op\u00e7\u00e3o <code>--build</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose up --build\n</code></pre> <p>Observando o Comportamento Esperado:</p> <p>Quando o cont\u00eainer \u00e9 iniciado, voc\u00ea deve ver as migra\u00e7\u00f5es sendo aplicadas, seguidas pela inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o:</p> $ Exemplo do resultado no terminal!<pre><code>fastzero_app-1  | INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nfastzero_app-1  | INFO  [alembic.runtime.migration] Will assume transactional DDL.\nfastzero_app-1  | INFO:     Started server process [10]\nfastzero_app-1  | INFO:     Waiting for application startup.\nfastzero_app-1  | INFO:     Application startup complete.\nfastzero_app-1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\n</code></pre> <p>Este processo garante que as migra\u00e7\u00f5es do banco de dados s\u00e3o realizadas automaticamente, mantendo a base de dados alinhada com a aplica\u00e7\u00e3o e pronta para a\u00e7\u00e3o assim que o servidor Uvicorn entra em cena.</p> Nota de revis\u00e3o sobre vari\u00e1veis de ambiente <p>Utilizar vari\u00e1veis de ambiente definidas em um arquivo <code>.env</code> \u00e9 uma pr\u00e1tica recomendada para cen\u00e1rios de produ\u00e7\u00e3o devido \u00e0 seguran\u00e7a que oferece. No entanto, para manter a simplicidade e o foco nas funcionalidades do FastAPI neste curso, optamos por explicitar essas vari\u00e1veis no <code>compose.yaml</code>. Isso \u00e9 particularmente relevante, pois o Docker Compose \u00e9 utilizado apenas para o ambiente de desenvolvimento; no deploy para fly.io, o qual \u00e9 o nosso foco, o compose n\u00e3o ser\u00e1 utilizado em produ\u00e7\u00e3o.</p> <p>Ainda assim, \u00e9 valioso mencionar como essa configura\u00e7\u00e3o mais segura seria realizada, especialmente para aqueles que planejam utilizar o Docker Compose em produ\u00e7\u00e3o.</p> <p>Em ambientes de produ\u00e7\u00e3o com Docker Compose, \u00e9 uma boa pr\u00e1tica gerenciar vari\u00e1veis de ambiente sens\u00edveis, como credenciais, por meio de um arquivo <code>.env</code>. Isso previne a exposi\u00e7\u00e3o dessas informa\u00e7\u00f5es diretamente no arquivo <code>compose.yaml</code>, contribuindo para a seguran\u00e7a do projeto.</p> <p>As vari\u00e1veis de ambiente podem ser definidas em nosso arquivo <code>.env</code> localizado na raiz do projeto:</p> .env<pre><code># Vari\u00e1veis do banco de dados\nPOSTGRES_USER=app_user\nPOSTGRES_DB=app_db\nPOSTGRES_PASSWORD=app_password\n\n# Vari\u00e1veis da aplica\u00e7\u00e3o\nDATABASE_URL=postgresql+psycopg://app_user:app_password@fastzero_database:5432/app_db\nSECRET_KEY=\"your-secret-key\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> <p>Para aplicar essas vari\u00e1veis, referencie o arquivo <code>.env</code> no <code>compose.yaml</code>:</p> compose.yaml<pre><code>services:\n  fastzero_database:\n    image: postgres\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    ports:\n      - \"5432:5432\"\n    env_file:\n      - .env\n\n  fastzero_app:\n    image: fastzero_app\n    entrypoint: ./entrypoint.sh\n    build: .\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - fastzero_database\n    env_file:\n      - .env\n\nvolumes:\n  pgdata:\n</code></pre> <p>Adotar essa abordagem evita a exposi\u00e7\u00e3o das vari\u00e1veis de ambiente no arquivo de configura\u00e7\u00e3o. Esta n\u00e3o foi a abordagem padr\u00e3o no curso devido \u00e0 complexidade adicional e \u00e0 inten\u00e7\u00e3o de evitar confus\u00f5es. Dependendo do ambiente estabelecido pela equipe de DevOps/SRE em um projeto real, essa gest\u00e3o pode variar entre vari\u00e1veis de ambiente, arquivos <code>.env</code> ou solu\u00e7\u00f5es mais avan\u00e7adas como Vault.</p> <p>Se optar por utilizar um arquivo <code>.env</code> com as configura\u00e7\u00f5es do PostgreSQL, configure o Pydantic para ignorar vari\u00e1veis de ambiente que n\u00e3o s\u00e3o necess\u00e1rias, adicionando <code>extra='ignore'</code> a chamada de <code>SettingsConfigDic</code>:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file='.env', env_file_encoding='utf-8', extra='ignore'\n    )\n\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Com essa configura\u00e7\u00e3o, o Pydantic ir\u00e1 ignorar quaisquer vari\u00e1veis no <code>.env</code> que n\u00e3o sejam explicitamente declaradas na classe <code>Settings</code>, evitando assim conflitos e erros inesperados.</p> <p>Agradecimentos especiais a @vcwild e @williangl pelas revis\u00f5es valiosas nesta aula que me fizeram criar essa nota. </p> Boas pr\u00e1ticas de inicializa\u00e7\u00e3o do banco de dados <p>Como esse \u00e9 um caso pensado em estudo, possivelmente n\u00e3o haver\u00e1 problemas relacionados \u00e0 inicializa\u00e7\u00e3o. Em um ambiente de produ\u00e7\u00e3o, por\u00e9m, n\u00e3o existe a garantia de que o postgres est\u00e1 pronto para uso no momento em que o <code>entrypoint</code> for executado. Seria necess\u00e1rio que, antes da execu\u00e7\u00e3o da migra\u00e7\u00e3o, o container do banco de dados tivesse a inicializa\u00e7\u00e3o finalizada.</p> <p>Isso \u00e9 feito usando o campo <code>healthcheck</code> do <code>compose.yaml</code>:</p> compose.yaml<pre><code>services:\n  fastzero_database:\n  image: postgres\n  # parte inicial da configura\u00e7\u00e3o ...\n  healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready\"]\n      interval: 5s\n      timeout: 5s\n      retries: 10\n</code></pre> <p>Dessa forma, ele ir\u00e1 executar o comando <code>pg_isready</code> a cada 5 segundos por 10 vezes. <code>pg_isready</code> \u00e9 um utilit\u00e1rio do PostgreSQL que verifica se ele j\u00e1 est\u00e1 operando e pronto para receber conex\u00f5es. Desta forma, a inicializa\u00e7\u00e3o do container s\u00f3 termina quando o postgres estiver ouvindo conex\u00f5es.</p> <p>Dica do @ayharano nessa issue.</p>"},{"location":"11/#testes-e-docker","title":"Testes e Docker","text":"<p>Uma das partes importantes dos testes \u00e9 tentar chegar o mais pr\u00f3ximo poss\u00edvel do ambiente de desenvolvimento. Contudo, nessa aula, introduzimos uma depend\u00eancia que vai al\u00e9m do python, o postgres.</p> <p>Isso pode tornar o nosso c\u00f3digo mais complicado de testar, por existir um DoC. Um \"componente dependente\" para ser executado. Nesse caso, por\u00e9m, \u00e9 interno ao sqlalchemy. Para usar o <code>psycopg</code>, temos uma depend\u00eancia externa ao python, o banco de dados precisa estar sendo executado, caso contr\u00e1rio os testes falhar\u00e3o.</p> Problemas no <code>Windows</code>, pscycopg e asyncio <p>Existe um comportamento indesej\u00e1vel ao executar o pscycopg de forma ass\u00edncrona no windows (link para o problema).</p> <p>O loop de eventos padr\u00e3o tem alguns problemas para executar as terefas com o postgres no <code>Windows</code>. Para contornar isso, podemos adicionar manualmente o loop de eventos do windows ao asyncio, para que tudo seja executado corretamente:</p> fast_zero/app.py<pre><code>import asyncio\nimport sys\nfrom http import HTTPStatus\n\nfrom fastapi import FastAPI\n\nfrom fast_zero.routers import auth, todos, users\nfrom fast_zero.schemas import Message\n\nif sys.platform == 'win32': #(1)!\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\napp = FastAPI()\n</code></pre> <ol> <li>Faz a valida\u00e7\u00e3o se o c\u00f3digo est\u00e1 sendo usado no Windows.</li> </ol> <p>Adicionando essa valida\u00e7\u00e3o, o comportamento deve permanecer o mesmo tanto no windows quanto no linux, lembre-se de que o c\u00f3digo em produ\u00e7\u00e3o ser\u00e1 executado no linux, ent\u00e3o o <code>if</code> \u00e9 de extrema import\u00e2ncia, pois n\u00e3o existe um <code>WindowsSelectorEventLoopPolicy</code> no linux.</p> <p>Embora isso seja o suficiente pra a execu\u00e7\u00e3o da aplica\u00e7\u00e3o, a migra\u00e7\u00e3o, quando aplicada no windows tamb\u00e9m ir\u00e1 esbarrar no mesmo problema. Logo, podemos usar o mesmo condicional no arquivo <code>env.py</code>:</p> migrations/env.py<pre><code>import asyncio\nimport sys\n\n# ...\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())\n\nif context.is_offline_mode():\n    run_migrations_offline()\n# ...\n</code></pre> <p>Desta forma, n\u00e3o deve ser um problema executar as migra\u00e7\u00f5es pelo windows, mesmo que o banco esteja em um container.</p>"},{"location":"11/#executando-testes-com-o-banco-de-dados-em-um-container","title":"Executando testes com o banco de dados em um container","text":"<p>Os testes contemplam um ciclo de feedback positivo, eles t\u00eam que ser executados de forma r\u00e1pida e eficiente. Adicionar o container do Postgres a nossa aplica\u00e7\u00e3o, torna o processo de testes um pouco mais complexo. Pois existe uma depend\u00eancia ao n\u00edvel de sistema para os testes serem executados.</p> <p>Come\u00e7aremos com o contraexemplo. Vamos alterar o comportamento da fixture do banco de dados para usar o postgres:</p> tests/conftest.py<pre><code>from fast_zero.app import app\nfrom fast_zero.database import get_session\nfrom fast_zero.models import table_registry\nfrom fast_zero.settings import Settings\nfrom fast_zero.security import get_password_hash\n\n\n@pytest_asyncio.fixture\nasync def session():\n    engine = create_async_engine(Settings().DATABASE_URL)\n\n    async with engine.begin() as conn:\n        await conn.run_sync(table_registry.metadata.create_all)\n\n    async with AsyncSession(engine, expire_on_commit=False) as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(table_registry.metadata.drop_all)\n</code></pre> <p>Com essa modifica\u00e7\u00e3o, agora estamos apontando para o PostgreSQL, conforme definido nas configura\u00e7\u00f5es da nossa aplica\u00e7\u00e3o (<code>Settings().DATABASE_URL</code>). A transi\u00e7\u00e3o do SQLite para o PostgreSQL \u00e9 facilitada pela abstra\u00e7\u00e3o fornecida pelo SQLAlchemy, que nos permite mudar de um banco para outro sem problemas.</p> <p>\u00c9 importante notar que essa flexibilidade se deve ao fato de n\u00e3o termos utilizado recursos espec\u00edficos do PostgreSQL que n\u00e3o s\u00e3o suportados pelo SQLite. Caso contr\u00e1rio, a mudan\u00e7a poderia n\u00e3o ser t\u00e3o direta.</p> <p>Partindo desse exemplo, para os testes serem executados, o banco de dados precisaria estar de p\u00e9. O que nos cobraria um container em execu\u00e7\u00e3o para os testes poderem rodar.</p> <p>Por exemplo:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Isso originaria esse erro:</p> <pre><code>============================= test session starts ==============================\nplatform linux -- Python 3.12.3, pytest-8.2.1, pluggy-1.5.0 -- /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/10/.venv/bin/python\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/10\nconfigfile: pyproject.toml\nplugins: anyio-4.4.0, cov-5.0.0, Faker-25.4.0\ncollecting ... collected 28 items\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo ERROR\n\n==================================== ERRORS ====================================\n___________ ERROR at setup of test_root_deve_retornar_ok_e_ola_mundo ___________\n\nself = &lt;sqlalchemy.engine.base.Connection object at 0x7ad981fb7380&gt;\nengine = Engine(postgresql+psycopg://app_user:***@localhost:5432/app_db)\nconnection = None, _has_events = None, _allow_revalidate = True\n_allow_autobegin = True\n\n# ...\n        if not rv:\n            assert last_ex\n&gt;           raise last_ex.with_traceback(None)\nE           psycopg.OperationalError: connection failed: connection to server at \"127.0.0.1\", port 5432 failed: Connection refused\nE               Is the server running on that host and accepting TCP/IP connections?\n\n.venv/lib/python3.12/site-packages/psycopg/connection.py:748: OperationalError\n</code></pre> <p>Obtivemos o erro <code>psycopg.OperationalError: connection failed: connection to server at \"127.0.0.1\", port 5432 failed: Connection refused</code>. Ele diz que ouve uma falha na comunica\u00e7\u00e3o com o nosso host na porta <code>5432</code>. O endere\u00e7o que colocamos no <code>.env</code>. Para que ele fique acess\u00edvel, temos que iniciar o container antes de executar os testes.</p> <p>Para isso:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose up -d fastzero_database #(1)!\n</code></pre> <ol> <li>Inicia somente o container no banco de dados via docker compose</li> </ol> <p>E em seguida executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Agora, sucesso. O resultado \u00e9 exatamente o que esper\u00e1vamos:</p> <pre><code>All checks passed!\n========== test session starts ==========\nplatform linux -- Python 3.12.3, pytest-8.2.1, pluggy-1.5.0 -- /.../10/.venv/bin/python\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/10\nconfigfile: pyproject.toml\nplugins: anyio-4.4.0, cov-5.0.0, Faker-25.4.0\ncollected 28 items\n\ntests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_auth.py::test_token_expired_after_time PASSED\ntests/test_auth.py::test_token_inexistent_user PASSED\ntests/test_auth.py::test_token_wrong_password PASSED\ntests/test_auth.py::test_refresh_token PASSED\ntests/test_auth.py::test_token_expired_dont_refresh PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_db.py::test_create_todo PASSED\ntests/test_security.py::test_jwt PASSED\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos_should_return_5_todos PASSED\ntests/test_todos.py::test_list_todos_pagination_should_return_2_todos PASSED\ntests/test_todos.py::test_list_todos_filter_title_should_return_5_todos PASSED\ntests/test_todos.py::test_list_todos_filter_description_should_return_5_todos PASSED\ntests/test_todos.py::test_list_todos_filter_state_should_return_5_todos PASSED\ntests/test_todos.py::test_list_todos_filter_combined_should_return_5_todos PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\ntests/test_todos.py::test_delete_todo PASSED\ntests/test_todos.py::test_delete_todo_error PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user_wrong_user PASSED\n\n---------- coverage: platform linux, python 3.12.3-final-0 -----------\nName                         Stmts   Miss  Cover\n------------------------------------------------\nfast_zero/__init__.py            0      0   100%\nfast_zero/app.py                11      0   100%\nfast_zero/database.py            7      2    71%\nfast_zero/models.py             29      0   100%\nfast_zero/routers/auth.py       26      0   100%\nfast_zero/routers/todos.py      50      0   100%\nfast_zero/routers/users.py      47      4    91%\nfast_zero/schemas.py            35      0   100%\nfast_zero/security.py           42      3    93%\nfast_zero/settings.py            7      0   100%\n------------------------------------------------\nTOTAL                          254      9    96%\n\n\n========== 28 passed in 4.94s ==========\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Embora essa seja uma abordagem que funciona, ela \u00e9 trabalhosa e temos que garantir que o container sempre esteja de p\u00e9. E como garantir isso durante a execu\u00e7\u00e3o dos testes?</p>"},{"location":"11/#containers-de-testes","title":"Containers de testes","text":"<p>Uma forma interessante de usar containers em testes \u00e9 usar containers espec\u00edficos para testes. Em python temos uma biblioteca chamada testcontainers.</p> <p>TestContainers \u00e9 uma biblioteca que fornece uma interface python para executarmos os containers diretamente no c\u00f3digo dos testes. Voc\u00ea importa o c\u00f3digo referente a um container e ele te retorna todas as configura\u00e7\u00f5es para que voc\u00ea possa usar durante os testes. Desta forma, podemos controlar o fluxo de inicializa\u00e7\u00e3o/finaliza\u00e7\u00e3o dos containers diretamente no c\u00f3digo.</p> <p>A biblioteca TestContainers tem diversas op\u00e7\u00f5es de containers, principalmente de bancos de dados. Como MariaDB, MongoDB, InfluxDB, etc. Tamb\u00e9m temos a op\u00e7\u00e3o de iniciar o PostgreSQL. Para isso, vamos instalar o testcontainters:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev testcontainers\n</code></pre> <p>Com o <code>testcontainers</code> instalado iremos alterar a fixture de conex\u00e3o com o banco de dados, para usar um container que ser\u00e1 gerenciado pela fixture:</p> tests/conftest.py<pre><code>from testcontainers.postgres import PostgresContainer #(1)!\n\n# ...\n\n@pytest_asyncio.fixture\nasync def session():\n    with PostgresContainer('postgres:16', driver='psycopg') as postgres: #(2)!\n        engine = create_async_engine(postgres.get_connection_url()) #(3)!\n\n        async with engine.begin() as conn:\n            await conn.run_sync(table_registry.metadata.create_all)\n\n        async with AsyncSession(engine, expire_on_commit=False) as session:\n            yield session\n\n        async with engine.begin() as conn:\n            await conn.run_sync(table_registry.metadata.drop_all)\n</code></pre> <ol> <li>Faz o import do <code>PostgresContainer</code> dos testcontainers. O que quer dizer que ela ser\u00e1 iniciada somente uma vez durante toda a sess\u00e3o de testes.</li> <li>Cria um container de postgres na vers\u00e3o 16. Usando o <code>psycopg</code> como driver.</li> <li><code>get_connection_url()</code> pega a URI do container postgres criado pelo <code>testcontainers</code>.</li> </ol> <p>Agora, todas \u00e0s vezes em que a fixture de <code>session</code> for usada nos testes. Ser\u00e1 iniciado um novo container postgres na vers\u00e3o 16. E as intera\u00e7\u00f5es com o banco ser\u00e3o feitas nesse container.</p> Caso esteja usando Podman <p>Existe um tutorial oficial do podman ensinando a ativar a compatibilidade.</p> <p>Tudo pronto para execu\u00e7\u00e3o dos testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Os testes devem ser executados com sucesso, mas algumas mensagens estranhas podem come\u00e7ar a aparecer entre o nome dos testes. Algo como:</p> $ Parte da resposta do comando de testes<pre><code>tests/test_users.py::test_delete_user_wrong_user Pulling image postgres:16\nContainer started: beff0853dde0\nWaiting for container &lt;Container: beff0853dde0&gt; with image postgres:16 to be ready ...\nWaiting for container &lt;Container: beff0853dde0&gt; with image postgres:16 to be ready ...\nPASSED\n# ...\n========= 28 passed in 80.92s (0:01:20) =========\n</code></pre> <p>A mensagem <code>Pulling image postgres:16</code> est\u00e1 dizendo que o container do postgres est\u00e1 sendo baixado do hub. Logo em seguida temos a mensagem <code>Container started: beff0853dde0</code>. Que diz que o container com id <code>beff0853dde0</code> foi iniciado. Ap\u00f3s essa mensagem vemos o <code>Waiting for container</code>, que diz que est\u00e1 aguardando o container estar pronto para operar durante os testes.</p> <p>Uma coisa preocupante nessa execu\u00e7\u00e3o \u00e9 a mensagem final: <code>28 passed in 80.92s (0:01:20)</code>. Embora todos os testes tenham sido executados com sucesso, levaram 80 segundos para serem executados (isso na minha m\u00e1quina).</p> <p>Isso faz com que o tempo de feedback dos testes seja alto. Quando isso acontece, tendemos a executar menos os testes, por conta da demora. Ent\u00e3o, temos que melhorar esse tempo.</p>"},{"location":"11/#fixtures-de-sessao","title":"Fixtures de sess\u00e3o","text":"<p>As fixtures do pytest, por padr\u00e3o, s\u00e3o executadas todas \u00e0s vezes em que uma fun\u00e7\u00e3o de teste recebe a fixture como argumento:</p> c\u00f3digo de exemplo<pre><code>@pytest.fixture\ndef fixture_de_exemplo():\n    # arrange\n    yield\n    # teardown\n\ndef teste_de_exemplo(fixture_de_exemplo): ...\n</code></pre> <p>Antes de executar o <code>teste_de_exemplo</code>, ser\u00e1 executado o c\u00f3digo da fixture at\u00e9 a instru\u00e7\u00e3o <code>yield</code> ser executada. A prepara\u00e7\u00e3o para o teste (arrange). Quando a fun\u00e7\u00e3o de teste \u00e9 finalizada, o bloco ap\u00f3s o yield \u00e9 executado. Chamamos ele de \"teardown\", para desfazer o efeito do \"arrage\". A volta do ambiente como era antes do \"arrange\".</p> <p>Dizemos que uma fixture \"tradicional\" tem o escopo de fun\u00e7\u00e3o. Pois ela \u00e9 iniciada e finalizada em todas as fun\u00e7\u00f5es de teste.</p> <p>Contudo, existem outros escopos, que precisam ser expl\u00edcitos durante a declara\u00e7\u00e3o da fixture, pelo par\u00e2metro <code>scope</code>. Existem diversos escopos:</p> <ul> <li><code>function</code>: executada em todas as fun\u00e7\u00f5es de teste;</li> <li><code>class</code>: executada uma vez por classe de teste;</li> <li><code>module</code>: executada uma vez por m\u00f3dulo;</li> <li><code>package</code>: executada uma vez por pacote;</li> <li><code>session</code>: executava uma vez por execu\u00e7\u00e3o dos testes;</li> </ul> <p>Para resolver o problema com a lentid\u00e3o dos testes, iremos criar uma fixture para iniciar o container do banco de dados com o escopo <code>\"session\"</code>.</p> <pre><code>sequenceDiagram\n    PytestRunner--&gt;&gt;Fixture: Executa a fixture at\u00e9 o yield\n    PytestRunner-&gt;&gt;Testes: Executa todos os testes\n    Testes--&gt;&gt;Testes: Executa um teste\n    PytestRunner--&gt;&gt;Fixture: Executa a fixture depois do yield</code></pre> <p>Dessa forma, a fixture \u00e9 inicializada antes de todos os testes, est\u00e1 dispon\u00edvel durante a execu\u00e7\u00e3o das fun\u00e7\u00f5es, sendo finalizada ap\u00f3s a execu\u00e7\u00e3o de todos os testes.</p>"},{"location":"11/#fixture-para-engine","title":"Fixture para engine","text":"<p>Para resolver o problema da lentid\u00e3o, vamos criar nova fixture para a <code>engine</code> no escopo <code>session</code>. Ela ficar\u00e1 respons\u00e1vel por iniciar o container (arrange), criar a conex\u00e3o persistente com o postgres (yield) e desfazer o container ap\u00f3s a execu\u00e7\u00e3o de todos os testes (teardown):</p> tests/conftest.py<pre><code>@pytest.fixture(scope='session') #(1)!\ndef engine():\n    with PostgresContainer('postgres:16', driver='psycopg') as postgres:\n        _engine = create_async_engine(postgres.get_connection_url())\n        yield _engine\n</code></pre> <ol> <li>fixture sendo definida com o escopo <code>'session'</code>.</li> </ol> <p>Desta forma, por consequ\u00eancia, n\u00e3o iremos mais definir a engine na fixture de <code>session</code>. Usaremos a fixture de engine, que ser\u00e1 criada somente uma vez durante toda a execu\u00e7\u00e3o dos testes:</p> tests/conftest.py<pre><code>@pytest_asyncio.fixture\nasync def session(engine):#(1)!\n    async with engine.begin() as conn:\n        await conn.run_sync(table_registry.metadata.create_all)\n\n    async with AsyncSession(engine, expire_on_commit=False) as session:\n        yield session\n\n    async with engine.begin() as conn:\n        await conn.run_sync(table_registry.metadata.drop_all)\n</code></pre> <ol> <li><code>engine</code> agora \u00e9 definida pela fixture de <code>engine</code>.</li> </ol> <p>Com isso, podemos executar os testes novamente e devemos ver uma diferen\u00e7a significativa de tempo:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n========= 28 passed in 7.96s =========\n</code></pre> <p>Com o container sendo iniciado somente uma vez, o tempo total de execu\u00e7\u00e3o dos testes caiu para <code>7.96s</code>, em compara\u00e7\u00e3o com os 80 segundos que t\u00ednhamos antes. Um tempo de feedback aceit\u00e1vel para execu\u00e7\u00e3o de testes.</p> <p>Desta forma temos uma separa\u00e7\u00e3o do nosso container postgres de desenvolvimento, do container usado pelos testes. Fazendo com que a execu\u00e7\u00e3o dos testes n\u00e3o remova os dados inseridos durante o desenvolvimento da aplica\u00e7\u00e3o.</p>"},{"location":"11/#commit","title":"Commit","text":"<p>Para finalizar, ap\u00f3s criar nosso arquivo <code>Dockerfile</code> e <code>compose.yaml</code>, executar os testes e construir nosso ambiente, podemos fazer o commit das altera\u00e7\u00f5es no Git:</p> <ol> <li>Adicionando todos os arquivos modificados nessa aula com <code>git add .</code></li> <li>Fa\u00e7a o commit das altera\u00e7\u00f5es com <code>git commit -m \"Dockerizando nossa aplica\u00e7\u00e3o e inserindo o PostgreSQL\"</code></li> <li>Envie as altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code></li> </ol>"},{"location":"11/#suplementar-para-proxima-aula","title":"Suplementar / Para pr\u00f3xima aula","text":"<p>Na pr\u00f3xima aula vamos conversar sobre como criar estruturas de testes que rodam no github, via integra\u00e7\u00e3o cont\u00ednua. Uma boa introdu\u00e7\u00e3o para o assunto \u00e9 essa live de python:</p> <p>Github Actions - Live de Python #170 - Com Willian Lopes</p>"},{"location":"11/#conclusao","title":"Conclus\u00e3o","text":"<p>Dockerizar nossa aplica\u00e7\u00e3o FastAPI, com o PostgreSQL, nos permite garantir consist\u00eancia em diferentes ambientes. A combina\u00e7\u00e3o de Docker e Docker Compose simplifica o processo de desenvolvimento e implanta\u00e7\u00e3o. Na pr\u00f3xima aula, aprenderemos como levar nossa aplica\u00e7\u00e3o para o pr\u00f3ximo n\u00edvel executando os testes de forma remota com a integra\u00e7\u00e3o cont\u00ednua do GitHub Actions.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p>"},{"location":"12/","title":"Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua","text":""},{"location":"12/#automatizando-os-testes-com-integracao-continua-ci","title":"Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender a pr\u00e1tica de Integra\u00e7\u00e3o Cont\u00ednua (CI) e sua import\u00e2ncia no processo de desenvolvimento de software.</li> <li>Aprender a usar o GitHub Actions para criar workflows de CI que automatizem a execu\u00e7\u00e3o de testes a cada commit.</li> <li>Configurar um pipeline de CI para nossa aplica\u00e7\u00e3o FastAPI que execute testes automaticamente.</li> <li>Reconhecer a import\u00e2ncia de manter uma cobertura de testes abrangente e consistente.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz </p> <p>Na aula anterior, preparamos nossa aplica\u00e7\u00e3o para execu\u00e7\u00e3o em containers Docker, um passo fundamental para replicar o ambiente de produ\u00e7\u00e3o. Agora, vamos garantir que nossa aplica\u00e7\u00e3o mantenha sua integridade a cada mudan\u00e7a, implementando Integra\u00e7\u00e3o Cont\u00ednua.</p>"},{"location":"12/#integracao-continua-ci","title":"Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"<p>Integra\u00e7\u00e3o Cont\u00ednua (CI) \u00e9 uma pr\u00e1tica de desenvolvimento que envolve a integra\u00e7\u00e3o regular do c\u00f3digo-fonte ao reposit\u00f3rio principal, acompanhada de testes automatizados para garantir a qualidade. O objetivo dessa pr\u00e1tica \u00e9 identificar e corrigir erros de forma precoce, facilitando o desenvolvimento cont\u00ednuo e colaborativo. Pois, caso algu\u00e9m esque\u00e7a de rodar os testes ou exista algum problema na integra\u00e7\u00e3o entre dois commits, ou em algum merge, isso seja detectado no momento em que a integra\u00e7\u00e3o cont\u00ednua \u00e9 executada.</p>"},{"location":"12/#github-actions","title":"GitHub Actions","text":"<p>Entre as ferramentas dispon\u00edveis para CI, o GitHub Actions \u00e9 um servi\u00e7o do GitHub que automatiza workflows dentro do seu reposit\u00f3rio. Voc\u00ea pode configurar o GitHub Actions para executar a\u00e7\u00f5es espec\u00edficas \u2014 como testes automatizados \u2014 cada vez que um novo c\u00f3digo \u00e9 commitado no reposit\u00f3rio.</p>"},{"location":"12/#exemplo-de-workflow","title":"Exemplo de workflow","text":"<p>Workflows no GitHub Actions come\u00e7am com a constru\u00e7\u00e3o de um ambiente (escolher um sistema operacional e instalar suas depend\u00eancias) e criar diversos passos (steps em ingl\u00eas) para executar todas as etapas que fazemos no nosso computador durante o desenvolvimento. \u00c9 uma forma de garantir que o sistema funciona em um ambiente controlado. Dessa forma, todas \u00e0s vezes que subimos o c\u00f3digo para o reposit\u00f3rio (damos push) esse ambiente e a sequ\u00eancia de passos ser\u00e1 executada.</p> <p>Por exemplo, como nosso sistema usar\u00e1 um sistema operacional GNU/Linux, podemos selecionar uma distribui\u00e7\u00e3o como Ubuntu para executar todos os passos da execu\u00e7\u00e3o dos nossos testes. Isso inclui diversas etapas como preparar o banco de dados, ler as vari\u00e1veis de ambiente, instalar o python e o poetry, etc.</p> <p>Antes de mergulharmos na configura\u00e7\u00e3o do YAML, vamos visualizar o processo de constru\u00e7\u00e3o do nosso ambiente de CI com um fluxograma. Este diagrama mostra os passos essenciais, desde a instala\u00e7\u00e3o do Python at\u00e9 a execu\u00e7\u00e3o dos testes, ajudando a entender a sequ\u00eancia de opera\u00e7\u00f5es no GitHub Actions.</p> <pre><code>flowchart LR\n    Push -- Inicia --&gt; Ubuntu\n    Ubuntu -- Execute os --&gt; Passos\n    Ubuntu --&gt; Z[Configure as vari\u00e1veis de ambiente]\n    subgraph Passos\n      A[Instale a vers\u00e3o 3.11 do Python] --&gt; B[Copie os arquivos do reposit\u00f3rio para o ambiente]\n      B --&gt; C[Instale o Poetry]\n      C --&gt; D[Instale as depend\u00eancia do projeto com Poetry]\n      D --&gt; E[Poetry execute os testes do projeto]\n    end</code></pre> <p>Com o fluxograma em mente, nosso objetivo de aula \u00e9 traduzir esses passos para a configura\u00e7\u00e3o pr\u00e1tica no GitHub Actions. Agora que temos uma vis\u00e3o clara do que nosso workflow envolve, nos aprofundaremos em como transformar essa teoria em pr\u00e1tica. </p>"},{"location":"12/#configurando-o-workflow-de-ci","title":"Configurando o workflow de CI","text":"<p>As configura\u00e7\u00f5es dos workflows no GitHub Actions s\u00e3o definidas em um arquivo YAML localizado em um path especificado pelo github no reposit\u00f3rio <code>.github/workflows/</code>. Dentro desse diret\u00f3rio podemos criar quantos workflows quisermos. Iniciaremos nossa configura\u00e7\u00e3o com um \u00fanico arquivo que chamaremos de <code>pipeline.yaml</code>:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.14'\n</code></pre> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.13'\n</code></pre> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.12'\n</code></pre> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.11'\n</code></pre> <p>Basicamente um arquivo de workflow precisa de tr\u00eas componentes essenciais para serem definidos:</p> <ul> <li>Um nome para o workflow (<code>name</code>);</li> <li>Uma condi\u00e7\u00e3o de execu\u00e7\u00e3o (a chave <code>on</code>) para sabermos o que iniciar\u00e1 o processo de workflow; e</li> <li>Um <code>job</code>: Onde escolheremos um sistema e descreveremos a lista de passos para serem executados.</li> </ul> <p>Nesse bloco de c\u00f3digo definimos que toda vez em que um <code>push</code> ou um <code>pull_request</code> ocorrer no nosso reposit\u00f3rio o <code>Pipeline</code> ser\u00e1 executado. Esse workflow tem um job chamado <code>test</code> que roda na \u00faltima vers\u00e3o do Ubuntu <code>runs-on: ubuntu-latest</code>. Nesse job chamado <code>test</code> temos uma lista de passos para serem executados, os <code>steps</code>.</p> <p>O \u00fanico step que definimos \u00e9 a instala\u00e7\u00e3o do Python:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 <pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.14'\n</code></pre> <pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.13'\n</code></pre> <pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.12'\n</code></pre> <pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.11'\n</code></pre> <p>Nesse momento, se executarmos um commit do arquivo <code>.github/workflows/pipeline.yaml</code> e um push em nosso reposit\u00f3rio, um workflow ser\u00e1 iniciado.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Instala\u00e7\u00e3o do Python\"\ngit push\n</code></pre> <p>Nisso, podemos ir at\u00e9 a p\u00e1gina do nosso reposit\u00f3rio no github e clicar na aba <code>Actions</code>, isso exibir\u00e1 todas \u00e0s vezes que um workflow for executado. Se clicarmos no wokflow seremos levados a p\u00e1gina dos jobs executados e se clicarmos nos jobs, temos uma descri\u00e7\u00e3o dos steps executados:</p> Guia Actions -&gt;Jobs executados -&gt;Steps executados <p></p> <p></p> <p></p> <p>Isso nos mostra que tudo que configuramos no arquivo <code>pipelines.yaml</code> foi executado pelo actions no momento que em executamos um <code>push</code> no git.</p> \u00c9 poss\u00edvel executar o CI localmente? <p>Existe um projeto bastante famoso chamado <code>Act</code>. Ele possibilita a execu\u00e7\u00e3o do pipeline do github actions localmente usando Docker/Podman.</p> <p>Isso pode ser bastante interessante para evitar muitos commits e chamadas excessivas ao reposit\u00f3rio, elas costumam demorar um pouco.</p> <p>A instala\u00e7\u00e3o varia entre os diversos sistemas operacionais e est\u00e1 explicada nesta p\u00e1gina da documenta\u00e7\u00e3o.</p> <p>Com a instala\u00e7\u00e3o feita, podemos simplesmente executar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>act\n</code></pre> <p>E o pipeline ser\u00e1 executado.</p> Poss\u00edveis problemas no windows <p>Como qualquer coisa que suporta diversos sistemas operacionais, \u00e0s vezes as coisas n\u00e3o funcionam como gostar\u00edamos.</p> <p>Como apontado por @marythealice em #313 \u00e9 preciso criar uma rede para o act: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>docker network create act-network #(1)!\nact --network act-network #(2)!\n</code></pre><p></p> <ol> <li>Cria uma rede docker chamada <code>act-network</code></li> <li>Executa os containers do act na rede <code>act-network</code></li> </ol> Testei com Podman e n\u00e3o funcionou <p>Como o act usa o <code>DOCKER_HOST</code> por padr\u00e3o, voc\u00ea precisa criar um alias para ele passando o endere\u00e7o do sock do podman. Como explicado aqui:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>DOCKER_HOST='unix:///var/run/podman/podman.sock' act\n</code></pre> <p>Agora que temos essa vis\u00e3o geral de como o Actions monta e executa workflows, podemos nos concentrar em construir o nosso ambiente.</p>"},{"location":"12/#construcao-do-nosso-ambiente-de-ci","title":"Constru\u00e7\u00e3o do nosso ambiente de CI","text":"<p>Para executar nossos testes no workflow, precisamos seguir alguns passos essenciais:</p> <ol> <li>Instalar o Python: fundamental para executar nosso c\u00f3digo e testes, por ser a linguagem base da nossa aplica\u00e7\u00e3o.</li> <li>Instalar o Poetry: pois toda a nossa aplica\u00e7\u00e3o e depend\u00eancias foram constru\u00eddas com ele.</li> <li>Instalar as depend\u00eancias do projeto: far\u00e3o com que todas as bibliotecas necess\u00e1rias estejam dispon\u00edveis para a execu\u00e7\u00e3o dos testes.</li> <li>Executar os testes: passo crucial para validar a integridade e funcionalidade do c\u00f3digo antes de integr\u00e1-lo ao reposit\u00f3rio principal.</li> </ol> <pre><code>flowchart LR\n   Python[\"1: Python instalado\"] --&gt; Poetry[\"2: Poetry instalado\"]\n   Poetry --&gt; Deps[\"3: Instalar as depend\u00eancias via Poetry\"]\n   Deps --&gt; Testes[\"4: Executar os testes via Poetry\"]</code></pre> <p>Cada um desses passos contribui para estabelecer um ambiente de CI robusto e confi\u00e1vel, assegurando que cada mudan\u00e7a no c\u00f3digo seja validada automaticamente, mantendo a qualidade e a estabilidade da nossa aplica\u00e7\u00e3o.</p> <p>Para isso, devemos criar um <code>step</code> para cada uma dessas a\u00e7\u00f5es no nosso job <code>test</code>. Desta:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 .github/workflows/pipeline.yaml<pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.14'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre> .github/workflows/pipeline.yaml<pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.13'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre> .github/workflows/pipeline.yaml<pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.12'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre> .github/workflows/pipeline.yaml<pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.11'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre> <p>Para testar essa implementa\u00e7\u00e3o no Actions, temos que fazer um commit<sup>1</sup>, para executar o trigger do CI:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando passos para executar os testes no CI\"\ngit push\n</code></pre> <p>Assim, podemos avaliar o impacto desses passos no nosso workflow:</p> <p></p> <p>Se analisarmos com calma o resultado, veremos que a execu\u00e7\u00e3o do nosso workflow apresenta um erro de execu\u00e7\u00e3o. O erro est\u00e1 descrito na linha <code>12</code>: <code>Poetry could not find a pyproject.toml file in &lt;path&gt; or its parents</code>. Se traduzirmos de maneira literal, a linha nos disse <code>Poetry n\u00e3o encontrou o arquivo pyproject.toml no &lt;path&gt; ou em seus parentes</code>.</p> <p>Para solucionar esse problema, adicionaremos um passo antes da execu\u00e7\u00e3o dos testes para copiar o c\u00f3digo do nosso reposit\u00f3rio para o ambiente do workflow. O GitHub Actions oferece uma a\u00e7\u00e3o espec\u00edfica para isso, chamada actions/checkout. Vamos inclu\u00ed-la como o primeiro passo:</p> Vers\u00e3o 3.14Vers\u00e3o 3.13Vers\u00e3o 3.12Vers\u00e3o 3.11 .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v5\n\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.14'\n\n      # continua com os passos anteriormente definidos\n</code></pre> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v5\n\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.13'\n\n      # continua com os passos anteriormente definidos\n</code></pre> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v5\n\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.12'\n\n      # continua com os passos anteriormente definidos\n</code></pre> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v5\n\n      - name: Instalar o python\n        uses: actions/setup-python@v6\n        with:\n          python-version: '3.11'\n\n      # continua com os passos anteriormente definidos\n</code></pre> <p>Para testar a execu\u00e7\u00e3o desse passo faremos um novo commit para triggar o Actions:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando o checkout ao pipeline\"\ngit push\n</code></pre> <p>Com isso, o erro anterior deve ser resolvido e teremos os testes sendo executados no workflow:</p> <p></p> <p>Ap\u00f3s resolver este problema, nos deparamos com outro desafio. Evidenciado no bloco a seguir:</p> Erro do CI!<pre><code>ImportError while loading conftest '/home/runner/work/&lt;path&gt;/tests/conftest.py'.\ntests/conftest.py:6: in &lt;module&gt;\n    from fast_zero.app import app\nfast_zero/app.py:3: in &lt;module&gt;\n    from fast_zero.routes import auth, todos, users\nfast_zero/routes/auth.py:8: in &lt;module&gt;\n    from fast_zero.database import get_session\nfast_zero/database.py:6: in &lt;module&gt;\n    engine = create_engine(Settings().DATABASE_URL)\n../../../.cache/pypoetry/virtualenvs/fast-zero-IubsqyUK-py3.11/lib/python3.11/site-packages/pydantic_settings/main.py:61: in __init__\n    super().__init__(\nE   pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings\nE   DATABASE_URL\nE     Field required [type=missing, input_value={}, input_type=dict]\nE       For further information visit https://errors.pydantic.dev/2.1.2/v/missing\n</code></pre> Erro completo no CI <p></p> <p>Ao iniciar a execu\u00e7\u00e3o dos testes, encontramos um erro relacionado \u00e0 nossa classe <code>settings.Settings</code>. Isso ocorreu porque as vari\u00e1veis de ambiente necess\u00e1rias, como <code>DATABASE_URL</code>, n\u00e3o estavam definidas no workflow do CI. Este problema \u00e9 comum quando as vari\u00e1veis do arquivo <code>.env</code>, que utilizamos localmente, n\u00e3o s\u00e3o transferidas para o ambiente de CI.</p>"},{"location":"12/#configuracao-de-variaveis-de-ambiente-no-actions","title":"Configura\u00e7\u00e3o de vari\u00e1veis de ambiente no Actions","text":"<p>Como vimos anteriormente, nossa configura\u00e7\u00e3o de CI encontrou um problema devido \u00e0 aus\u00eancia de vari\u00e1veis de ambiente. Para resolver isso, utilizaremos uma funcionalidade dos reposit\u00f3rios do GitHub chamada 'Secrets'. Os 'Secrets' s\u00e3o uma maneira segura de armazenar informa\u00e7\u00f5es confidenciais, como vari\u00e1veis de ambiente, de forma criptografada. Eles s\u00e3o acess\u00edveis dentro do nosso workflow, permitindo que o GitHub Actions utilize esses valores sem exp\u00f4-los publicamente.</p>"},{"location":"12/#definindo-secrets-no-repositorio","title":"Definindo Secrets no Reposit\u00f3rio","text":"<p>Para definirmos as vari\u00e1veis de ambiente como 'Secrets', temos duas alternativas. A primeira \u00e9 acessar a aba <code>Settings -&gt; Secrets and variables</code> do nosso reposit\u00f3rio no GitHub. Neste local, podemos inserir manualmente cada 'Secret', como URLs de banco de dados e chaves secretas.</p> <p>A segunda alternativa \u00e9 utilizar o CLI do GitHub (<code>gh</code>) para adicionar todas as vari\u00e1veis de ambiente que temos no nosso arquivo <code>.env</code>. Isso pode ser feito com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>gh secret set -f .env\n</code></pre> <p>Este comando pega todas as vari\u00e1veis de ambiente do arquivo <code>.env</code> e as configura como 'Secrets' no seu reposit\u00f3rio GitHub.</p> Configurando Secrets pela Interface Web <p>Se preferir configurar 'Secrets' pela interface web do GitHub, siga estes passos:</p> 1 - Acesse Settings no seu reposit\u00f3rio2 - Adicione um novo segredo3 - Visualiza\u00e7\u00e3o dos segredos <p>Acesse Settings no seu reposit\u00f3rio GitHub. Em seguida clique na guia \"Secrets and variables\". Ap\u00f3s isso clique em \"New Repository secret\":</p> <p></p> <p>Para adicionar um novo scregredo no campo <code>Name</code> colocamos o nome de um de nossas vari\u00e1veis de ambientes. No campo <code>Secret</code> adicione o valor de uma vari\u00e1vel. Como, por exemplo: </p> <p>Em seguida clique em <code>Add secret</code>.</p> <p>Ap\u00f3s adicionar todos os segredos, sua p\u00e1gina de segredos deve se parecer com isso: </p>"},{"location":"12/#implementacao-no-arquivo-yaml","title":"Implementa\u00e7\u00e3o no Arquivo YAML","text":"<p>Ap\u00f3s definir as 'Secrets', o pr\u00f3ximo passo \u00e9 integr\u00e1-las ao nosso arquivo de workflow (<code>.github/workflows/pipeline.yaml</code>). Aqui, utilizamos uma sintaxe especial para acessar os valores armazenados como 'Secrets'. Cada 'Secret' \u00e9 mapeado para uma vari\u00e1vel de ambiente no job do nosso workflow, tornando esses valores seguros e acess\u00edveis durante a execu\u00e7\u00e3o do workflow. Vejamos como isso \u00e9 feito:</p> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    env:\n      DATABASE_URL: ${{ secrets.DATABASE_URL }}\n      SECRET_KEY: ${{ secrets.SECRET_KEY }}\n      ALGORITHM: ${{ secrets.ALGORITHM }}\n      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}\n</code></pre> <p>Neste trecho de c\u00f3digo, a sintaxe <code>${{ secrets.NOME_DA_VARIAVEL }}</code> \u00e9 usada para referenciar os 'Secrets' que definimos no reposit\u00f3rio. Por exemplo, <code>secrets.DATABASE_URL</code> buscar\u00e1 o valor da 'Secret' chamada <code>DATABASE_URL</code> que definimos. Assim que o workflow \u00e9 acionado, esses valores s\u00e3o injetados no ambiente do job, permitindo que nosso c\u00f3digo os acesse como vari\u00e1veis de ambiente normais.</p> <p>Essa abordagem n\u00e3o s\u00f3 mant\u00e9m nossos dados confidenciais seguros, mas tamb\u00e9m nos permite gerenciar configura\u00e7\u00f5es sens\u00edveis de forma centralizada, facilitando atualiza\u00e7\u00f5es e manuten\u00e7\u00e3o.</p>"},{"location":"12/#atualizando-o-workflow","title":"Atualizando o Workflow","text":"<p>Com as 'Secrets' agora configuradas, precisamos atualizar o nosso workflow para incorporar essas mudan\u00e7as. Isso \u00e9 feito por meio de um novo commit e push para o reposit\u00f3rio, que acionar\u00e1 o workflow com as novas configura\u00e7\u00f5es.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando as vari\u00e1veis de ambiente para o CI\"\ngit push\n</code></pre> <p>A execu\u00e7\u00e3o do workflow com as novas 'Secrets' nos permitir\u00e1 verificar se os problemas anteriores foram resolvidos.</p> <p></p> <p>E SIM, tudo funcionou como esper\u00e1vamos \ud83c\udf89</p> <p>Agora a cada novo commit ou PR em nossa aplica\u00e7\u00e3o, os testes ser\u00e3o executados para garantir que a integra\u00e7\u00e3o pode acontecer sem problemas.</p>"},{"location":"12/#conclusao","title":"Conclus\u00e3o","text":"<p>Atrav\u00e9s deste m\u00f3dulo sobre Integra\u00e7\u00e3o Cont\u00ednua com GitHub Actions, ganhamos uma compreens\u00e3o s\u00f3lida de como a CI \u00e9 vital no desenvolvimento moderno de software. Vimos como o GitHub Actions, uma ferramenta poderosa e vers\u00e1til, pode ser utilizada para automatizar nossos testes e garantir a qualidade e estabilidade do c\u00f3digo a cada commit. Esta pr\u00e1tica n\u00e3o apenas otimiza nosso fluxo de trabalho, mas tamb\u00e9m nos ajuda a identificar e resolver problemas precocemente.</p> <p>No pr\u00f3ximo m\u00f3dulo, o foco ser\u00e1 na prepara\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI para o deployment em produ\u00e7\u00e3o. Exploraremos as etapas necess\u00e1rias e as melhores pr\u00e1ticas para tornar nossa aplica\u00e7\u00e3o pronta para o uso no mundo real, abordando desde configura\u00e7\u00f5es at\u00e9 estrat\u00e9gias de deployment eficazes.</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p> <ol> <li> <p>H\u00e1 alternativas para testar o workflow de CI sem fazer um commit, como a ferramenta Act que simula a execu\u00e7\u00e3o do workflow localmente usando Docker.\u00a0\u21a9</p> </li> </ol>"},{"location":"13/","title":"Fazendo deploy no Fly.io","text":""},{"location":"13/#fazendo-deploy-no-flyio","title":"Fazendo deploy no Fly.io","text":"<p>Objetivos da aula:</p> <ul> <li>Entender o que \u00e9 o Fly.io e como usar sua CLI</li> <li>Aprender a fazer o deploy de uma aplica\u00e7\u00e3o Docker no Fly.io</li> <li>Configurar uma inst\u00e2ncia do PostgreSQL no Fly.io</li> <li>Configurar as vari\u00e1veis de ambiente</li> <li>Rodar as migra\u00e7\u00f5es em produ\u00e7\u00e3o</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Essa aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Aula  Slides  C\u00f3digo  Quiz </p> <p>Agora que temos uma API criada com integra\u00e7\u00e3o ao banco de dados e testes sendo executados via integra\u00e7\u00e3o cont\u00ednua. Chegou a t\u00e3o esperada hora de colocar nossa aplica\u00e7\u00e3o em produ\u00e7\u00e3o para que todas as pessoas possam acess\u00e1-la. Colocaremos nossa aplica\u00e7\u00e3o em produ\u00e7\u00e3o usando um servi\u00e7o de PaaS, chamado Fly.io.</p>"},{"location":"13/#o-flyio","title":"O Fly.io","text":"<p>O Fly.io \u00e9 uma plataforma de deploy que nos permite lan\u00e7ar nossas aplica\u00e7\u00f5es na nuvem e que oferece servi\u00e7os para diversas linguagens de programa\u00e7\u00e3o e frameworks como Python e Django, PHP e Laravel, Ruby e Rails, Elixir e Phoenix, etc. </p> <p>Ao mesmo tempo, em que permite que o deploy de aplica\u00e7\u00f5es em containers docker tamb\u00e9m possam ser utilizadas, como \u00e9 o nosso caso. Al\u00e9m disso, o Fly disponibiliza bancos de dados para serem usados em nossas aplica\u00e7\u00f5es, como PostgreSQL e Redis.</p> <p>O motivo pela escolha do Fly \u00e9 que ele permite que fa\u00e7amos deploys de aplica\u00e7\u00f5es em desenvolvimento / provas de conceito de forma gratuita - o que usaremos para \"colocar nossa aplica\u00e7\u00e3o no mundo\".</p> <p>Para fazer o uso do fly.io \u00e9 necess\u00e1rio que voc\u00ea crie uma conta no servi\u00e7o.</p>"},{"location":"13/#flyctl","title":"Flyctl","text":"<p>Uma das formas de interagir com a plataforma \u00e9 via uma aplica\u00e7\u00e3o de linha de comando disponibilizada pelo Fly, o flyctl.</p> <p>O flyctl precisa ser instalado em seu computador. Em algumas distribui\u00e7\u00f5es linux o flyctl est\u00e1 dispon\u00edvel nos reposit\u00f3rios de aplica\u00e7\u00f5es. Para Mac/Windows ou distribui\u00e7\u00f5es linux que n\u00e3o contam com o pacote no reposit\u00f3rio, voc\u00ea pode seguir o guia de instala\u00e7\u00e3o oficial.</p> <p>Ap\u00f3s a instala\u00e7\u00e3o, voc\u00ea pode verificar se o flyctl est\u00e1 instalado em seu sistema operacional digitando o seguinte comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl version\n</code></pre> <p>flyctl v0.3.205 linux/amd64 Commit: eefac469b8b39c1877aae901e61fee701a93a645 BuildDate: 2025-10-29T08:42:41Z</p> <p>No momento da sua instala\u00e7\u00e3o, voc\u00ea pode se deparar com uma vers\u00e3o mais recente do que a minha no momento, mas os comandos devem funcionar da mesma forma em qualquer vers\u00e3o menor que <code>1.0.0</code>.</p>"},{"location":"13/#fazendo-login-via-terminal","title":"Fazendo login via terminal","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o do <code>flyctl</code> \u00e9 importante que voc\u00ea efetue o login usando suas credenciais, para que o <code>flyctl</code> consiga vincular suas credenciais com a linha de comando. Para isso podemos executar o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl auth login\nOpening https://fly.io/app/auth/cli/91283719231023123 ...\n\nWaiting for session...\n</code></pre> <p>Isso abrir\u00e1 uma janela em seu browser pedindo que voc\u00ea efetue o login:</p> <p></p> <p>Ap\u00f3s inserir suas credenciais, voc\u00ea pode fechar o browser e no shell a execu\u00e7\u00e3o do comando terminar\u00e1 mostrando a conta em que voc\u00ea est\u00e1 logado:</p> $ Continua\u00e7\u00e3o da resposta do terminal<pre><code>Waiting for session... Done\nsuccessfully logged in as &lt;seu-email@de-login.com&gt;\n</code></pre> <p>Desta forma, toda a configura\u00e7\u00e3o necess\u00e1ria para o iniciar o deploy est\u00e1 pronta!</p>"},{"location":"13/#configuracoes-para-o-deploy","title":"Configura\u00e7\u00f5es para o deploy","text":"<p>Agora com o <code>flyctl</code> devidamente configurado. Podemos iniciar o processo de lan\u00e7amento da nossa aplica\u00e7\u00e3o. O <code>flyctl</code> tem um comando espec\u00edfico para lan\u00e7amento, o <code>launch</code>. Contudo, o comando <code>launch</code> \u00e9 bastante interativo e ao final dele, o deploy da aplica\u00e7\u00e3o \u00e9 executado. Para evitar o deploy no primeiro momento, pois ainda existem coisas para serem configuradas, vamos execut\u00e1-lo da seguinte forma:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl launch --no-deploy\n</code></pre> <p>Como resultado desse comando, o <code>flyctl</code> iniciar\u00e1 o modo interativo e exibir\u00e1 uma resposta pr\u00f3xima a essa:</p> $ Resposta do comando `launch`<pre><code>Detected a Dockerfile app\nCreating app in /home/dunossauro/ci-example-fastapi\nWe're about to launch your app on Fly.io. Here's what you're getting:\n\nOrganization: &lt;Seu Nome&gt;             (fly launch defaults to the personal org)\nName:         fast-zero              (derived from your directory name)\nRegion:       Sao Paulo, Brazil      (this is the fastest region for you)\nApp Machines: shared-cpu-1x, 1GB RAM (most apps need about 1GB of RAM)\nPostgres:     &lt;none&gt;                 (not requested)\nRedis:        &lt;none&gt;                 (not requested)\n\n? Do you want to tweak these settings before proceeding? (y/N) \n</code></pre> <p>Nesse texto est\u00e3o destacadas as configura\u00e7\u00f5es padr\u00f5es do Fly. Como a Regi\u00e3o onde seu deploy ser\u00e1 feito (<code>Sao Paulo, Brazil</code>, o mais pr\u00f3ximo a mim nesse momento), a configura\u00e7\u00e3o da m\u00e1quina do deploy <code>App Machines: shared-cpu-1x, 1GB RAM</code> e a op\u00e7\u00e3o padr\u00e3o do Postgres: <code>Postgres: &lt;none&gt;</code>.</p> Uma nota sobre o Postgres + Fly <p>Antes de avan\u00e7armos, \u00e9 importante mencionar uma especificidade do Fly.io: para criar uma inst\u00e2ncia do PostgreSQL, a plataforma requer que um cart\u00e3o de cr\u00e9dito seja fornecido. Esta \u00e9 uma medida de seguran\u00e7a adotada para evitar o uso indevido de seus servi\u00e7os, como a execu\u00e7\u00e3o de ferramentas de minera\u00e7\u00e3o. Apesar dessa exig\u00eancia, o servi\u00e7o de PostgreSQL \u00e9 oferecido de forma gratuita. Mais detalhes podem ser encontrados neste artigo.</p> <p>Caso voc\u00ea n\u00e3o adicione um cart\u00e3o, o erro levatado pelo <code>flyctl</code> est\u00e1 descrito na issue #73</p> <p>A pergunta feita ao final dessa se\u00e7\u00e3o <code>Do you want to tweak these settings before proceeding?</code> pode ser traduzida como: <code>Voc\u00ea deseja ajustar essas configura\u00e7\u00e3o antes de prosseguir?</code>. Diremos que sim, digitando Y e em seguida Enter.</p> <p>Assim, a configura\u00e7\u00e3o do lan\u00e7amento deve avan\u00e7ar e travar novamente com um texto parecido com esse:</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>? Do you want to tweak these settings before proceeding? Yes\nOpening https://fly.io/cli/launch/59f08b31a5efd30bdf5536ac516de5ga ...\n\nWaiting for launch data...\u28fd\n</code></pre> <p>Nesse momento, ele abrir\u00e1 o browser novamente exibira uma tela de ajustes de configura\u00e7\u00f5es.</p> <p>Para as configura\u00e7\u00f5es da m\u00e1quina que executar\u00e1 o aplicativo: </p> <ol> <li>Se\u00e7\u00e3o <code>Basics</code>: adicionaremos o nome da nossa aplica\u00e7\u00e3o no Fly. (Usarei <code>fastzeroapp</code>)</li> <li>Na op\u00e7\u00e3o <code>VM sizes</code>: Usaremos <code>shared-cpu-1x</code></li> <li>Na op\u00e7\u00e3o <code>VM Memory</code>: Usaremos 512MB</li> </ol> <p>Paras configura\u00e7\u00f5es da m\u00e1quina que executar\u00e1 o banco de dados: </p> <ol> <li>Alteraremos o campo <code>Provider</code> para <code>Fly Automated Postgres</code></li> <li>Criaremos um nome para o nosso servi\u00e7o de banco de dados. (Usarei <code>fastzerodb</code>)</li> <li>No campo <code>Configuration</code> alteraremos para <code>Development - Single node, 1x shared CPU, 256MB RAM, 1GB disk</code></li> </ol> <p>Por fim, clicamos em <code>Confirm Settings</code>!</p> <p>Ap\u00f3s esse ajuste, voc\u00ea pode fechar a janela do browser e voltar ao terminal, pois a parte interativa do <code>launch</code> ainda estar\u00e1 em execu\u00e7\u00e3o. Como a resposta a seguir \u00e9 bastante grande, colocarei <code>...</code> para pular algumas linhas que n\u00e3o nos interessam nesse momento:</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>Created app 'fastzeroapp' in organization 'personal'\nAdmin URL: https://fly.io/apps/fastzeroapp\nHostname: fastzeroapp.fly.dev\nCreating postgres cluster in organization personal\nCreating app...\n\n...\n\nPostgres cluster fastzerodb created\n  Username:    postgres\n  Password:    t0Vf35P21eDlIVS\n  Hostname:    fastzerodb.internal\n  Flycast:     fdaa:2:77b0:0:1::a\n  Proxy port:  5432\n  Postgres port:  5433\n  Connection string: postgres://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432\n\n...\n\nPostgres cluster fastzerodb is now attached to fastzeroapp\nThe following secret was added to fastzeroapp:\n  DATABASE_URL=postgres://fastzeroapp:zHgBlc6JNaslGtz@fastzerodb.flycast:5432/fastzeroapp?sslmode=disable\nPostgres cluster fastzerodb is now attached to fastzeroapp\n? Create .dockerignore from .gitignore files? (y/N)\n</code></pre> <p>Nas linhas em destaque, vemos que o Fly se encarregou de criar um dashboard para vermos o status atual da nossa aplica\u00e7\u00e3o (https://fly.io/apps/nome-do-seu-app), inicializou um banco de dados postgres para usarmos em conjunto com nossa aplica\u00e7\u00e3o e tamb\u00e9m adicionou a url do banco de dados a vari\u00e1vel de ambiente <code>DATABASE_URL</code> com a configura\u00e7\u00e3o do postgres referente a nossa aplica\u00e7\u00e3o.</p> <p>A <code>Connection string</code> do banco de dados deve ser armazenada por voc\u00ea, essa informa\u00e7\u00e3o n\u00e3o ser\u00e1 disponibilizada novamente, nem mesmo na parte web do Fly. Por isso guarde-a com cuidado e n\u00e3o compartilhem de forma alguma.</p> <p>Assim sendo, para prosseguir com o <code>launch</code> devemos responder a seguinte pergunta: <code>Create .dockerignore from .gitignore files? (y/N)</code>, que pode ser traduzida como <code>Crie um .dockerignore partindo do arquivo .gitignore?</code>. Vamos novamente responder que sim. Digitando Y e em seguida Enter.</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>Created &lt;seu-path&gt;/.dockerignore from 6 .gitignore files.\nWrote config file fly.toml\nValidating &lt;seu-path&gt;/fly.toml\nPlatform: machines\n\u2713 Configuration is valid\nYour app is ready! Deploy with `flyctl deploy`\n</code></pre> <p>Agora o <code>flyctl</code> criou um arquivo <code>.dockerignore</code> que n\u00e3o copia os arquivos do <code>.gitignore</code> para dentro do container docker e tamb\u00e9m criou um arquivo de configura\u00e7\u00e3o do Fly, o arquivo <code>fly.toml</code>.</p> <p>Na \u00faltima linha ele nos disse que nossa aplica\u00e7\u00e3o est\u00e1 pronta para o deploy. Mas ainda temos mais configura\u00e7\u00f5es a fazer!</p>"},{"location":"13/#configuracao-dos-segredos","title":"Configura\u00e7\u00e3o dos segredos","text":"<p>Para que nossa aplica\u00e7\u00e3o funcione de maneira adequada, todas as vari\u00e1veis de ambiente precisam estar configuradas no ambiente. O <code>flyctl</code> tem um comando para vermos as vari\u00e1veis que j\u00e1 foram definidas no ambiente e tamb\u00e9m para definir novas. O comando <code>secrets</code>.</p> <p>Para vermos as vari\u00e1veis j\u00e1 configuradas no ambiente, podemos executar o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets list\n\nNAME            DIGEST              CREATED AT\nDATABASE_URL    f803df294e7326fa    22m43s ago\n</code></pre> <p>Uma coisa que podemos notar na resposta do <code>secrets</code> \u00e9 que a vari\u00e1vel de ambiente <code>DATABASE_URL</code> foi configurada automaticamente com base no Fly Postgres criado durante o comando <code>launch</code>. Um ponto de aten\u00e7\u00e3o que devemos tomar nesse momento, \u00e9 que a vari\u00e1vel criada \u00e9 iniciada com o prefixo <code>postgres://</code>. Para que o sqlalchemy reconhe\u00e7a esse endere\u00e7o como v\u00e1lido, o prefixo deve ser alterado para <code>postgresql+psycopg://</code>. Para isso, usaremos a url fornecida pelo comando <code>launch</code> e alterar o prefixo.</p> <p>Desta forma, podemos registrar a vari\u00e1vel de ambiente <code>DATABASE_URL</code> novamente. Agora com o valor correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set DATABASE_URL=postgresql+psycopg://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432\nSecrets are staged for the first deployment\n</code></pre> <p>Contudo, n\u00e3o \u00e9 somente a vari\u00e1vel de ambiente do postgres que \u00e9 importante para que nossa aplica\u00e7\u00e3o seja executada. Temos que adicionar as outras vari\u00e1veis contidas no nosso <code>.env</code> ao Fly.</p> <p>Iniciaremos adicionando a vari\u00e1vel <code>ALGORITHM</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set ALGORITHM=\"HS256\"\nSecrets are staged for the first deployment\n</code></pre> <p>Seguida pela vari\u00e1vel <code>SECRET_KEY</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set SECRET_KEY=\"your-secret-key\"\nSecrets are staged for the first deployment\n</code></pre> <p>E por fim a vari\u00e1vel <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set ACCESS_TOKEN_EXPIRE_MINUTES=30\nSecrets are staged for the first deployment\n</code></pre> <p>Com isso, todos os segredos da nossa aplica\u00e7\u00e3o j\u00e1 est\u00e3o configurados no nosso ambiente do Fly. Agora podemos partir para o nosso t\u00e3o aguardado deploy.</p>"},{"location":"13/#deploy-da-aplicacao","title":"Deploy da aplica\u00e7\u00e3o","text":"<p>Para efetuarmos o deploy da aplica\u00e7\u00e3o, podemos usar o comando <code>deploy</code> do<code>flyctl</code>. Uma coisa interessante nessa parte do processo \u00e9 que o Fly pode fazer o deploy de duas formas:</p> <ol> <li>Copiar seus arquivos e fazer o build do docker na nuvem;</li> <li>Voc\u00ea pode fazer o build localmente e subir apenas o container para um reposit\u00f3rio dispon\u00edvel no Fly.</li> </ol> <p>Optaremos por fazer o build localmente para n\u00e3o serem alocadas duas m\u00e1quinas em nossa aplica\u00e7\u00e3o<sup>1</sup>. Para executar o build localmente usamos a flag <code>--local-only</code>.</p> <p>O Fly sobe duas inst\u00e2ncias por padr\u00e3o da nossa aplica\u00e7\u00e3o para melhorar a disponibilidade do app. Como vamos nos basear no uso gratuito, para todos poderem executar o deploy, adicionaremos a flag <code>--ha=false</code> ao deploy. Para desativamos a alta escalabilidade:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly deploy --local-only --ha=false\n</code></pre> <p>Como a resposta do comando <code>deploy</code> \u00e9 bastante grande, substituirei o texto por <code>...</code> para pular algumas linhas que n\u00e3o nos interessam nesse momento:</p> $ Resultado do comando `deploy`<pre><code>==&gt; Verifying app config\nValidating /home/dunossauro/ci-example-fastapi/fly.toml\nPlatform: machines\n\u2713 Configuration is valid\n--&gt; Verified app config\n==&gt; Building image\n==&gt; Building image with Docker\n...\n =&gt; exporting to image                                                  0.0s\n =&gt; =&gt; exporting layers                                                 0.0s\n =&gt; =&gt; writing image sha256:b95a9d9f8abcea085550449a720a0bb9176e195fe4  0.0s\n =&gt; =&gt; naming to registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN4  0.0s\n--&gt; Building image done\n==&gt; Pushing image to fly\nThe push refers to repository [registry.fly.io/fastzeroapp]\n...\ndeployment-01HHKKDMF87FN441VA6H0JR4BS: digest: sha256:153a13e2931f923ab60df7e9dd0f18e2cc89fff7833ac18443935c7d0763a329 size: 2419\n--&gt; Pushing image done\nimage: registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN441VA6H0JR4BS\nimage size: 349 MB\n\nWatch your deployment at https://fly.io/apps/fastzeroapp/monitoring\n\n-------\nUpdating existing machines in 'fastzeroapp' with rolling strategy\n\n-------\n \u2714 Machine 1781551ad22489 [app] update succeeded\n-------\n\nVisit your newly deployed app at https://fastzeroapp.fly.dev/\n</code></pre> <p>As primeiras linhas da resposta est\u00e3o relacionadas ao build do docker e a publica\u00e7\u00e3o no reposit\u00f3rio de imagens docker do Fly.</p> <p>Na sequ\u00eancia, temos algumas informa\u00e7\u00f5es importantes a respeito do deploy da nossa aplica\u00e7\u00e3o. Como a URL de monitoramento (<code>https://fly.io/apps/&lt;nome-do-app&gt;/monitoring</code>), o aviso de que o deploy foi efetuado com sucesso (<code>Machine 1781551ad22489 [app] update succeeded</code>) e por fim, a URL de acesso a nossa aplica\u00e7\u00e3o (<code>https://&lt;nome-do-app&gt;.fly.dev/</code>).</p> <p>Dessa forma podemos acessar a nossa aplica\u00e7\u00e3o acessando a URL fornecida pela \u00faltima linha de resposta em nosso browser, como <code>https://fastzeroapp.fly.dev/</code>:</p> <p></p> <p>E pronto, nossa aplica\u00e7\u00e3o est\u00e1 dispon\u00edvel para acesso! Obtivemos o nosso \"Ol\u00e1 mundo\". \ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80</p> <p>Por\u00e9m, contudo, entretanto, ainda existe um problema na nossa aplica\u00e7\u00e3o no ar. Para ficar evidente, tente acessar o swagger da sua aplica\u00e7\u00e3o no ar e registrar um usu\u00e1rio usando o endpoint <code>/user</code> com o m\u00e9todo POST:</p> <p></p> <p>Voc\u00ea receber\u00e1 uma mensagem de erro, um erro 500: <code>Internal Server Error</code>, por de n\u00e3o efetuarmos a migra\u00e7\u00e3o no banco de dados de produ\u00e7\u00e3o. Por\u00e9m, para ter certeza disso, podemos usar a URL de monitoramento do Fly para ter certeza do erro ocorrido. Acessando: <code>https://fly.io/apps/&lt;nome-do-app&gt;/monitoring</code>, podemos visualizar os erros exibidos no console da nossa aplica\u00e7\u00e3o:</p> <p></p> <p>Podemos ver no console a mensagem: <code>Relation \"users\" does not exist</code>. Que traduzida pode ser lido como <code>A rela\u00e7\u00e3o \"users\" n\u00e3o existe</code>. O significa que a tabela \"users\" n\u00e3o foi criada ou n\u00e3o existe no banco de dados.</p> <p>Desta forma, para que nossa aplica\u00e7\u00e3o funcione corretamente precisamos executar as migra\u00e7\u00f5es.</p>"},{"location":"13/#migrations","title":"Migrations","text":"<p>Agora que nosso container j\u00e1 est\u00e1 em execu\u00e7\u00e3o no fly, podemos executar o comando de migra\u00e7\u00e3o dos dados, pois ele est\u00e1 na mesma rede do postgres configurado pelo Fly<sup>2</sup>. Essa conex\u00e3o \u00e9 feita via SSH e pode ser efetuada com o comando <code>ssh</code> do <code>flyctl</code>.</p> <p>Podemos fazer isso de duas formas, acessando efetivamente o container remotamente ou enviando somente um comando para o Fly. Optarei pela segunda op\u00e7\u00e3o, pois ela n\u00e3o \u00e9 interativa e usar\u00e1 somente uma \u00fanica chamada do shell. Desta forma:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl ssh console -a fastzeroapp -C \"poetry run alembic upgrade head\"\n\nConnecting to fdaa:2:77b0:a7b:1f60:3f74:a755:2... complete\nSkipping virtualenv creation, as specified in config file.\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\nINFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -&gt; de865434f506, create todos table\n</code></pre> Poss\u00edvel erro que pode ocorrer! <p>Uma das formas de funcionamento padr\u00e3o do Fly \u00e9 desativar a m\u00e1quina caso ningu\u00e9m esteja usando. A\u00ed quando uma requisi\u00e7\u00e3o for feita para aplica\u00e7\u00e3o, ele inicia a m\u00e1quina novamente.</p> <p>Caso voc\u00ea tente fazer um ssh e a aplica\u00e7\u00e3o n\u00e3o estiver de p\u00e9 no momento, voc\u00ea vai receber um erro como esse: </p><pre><code>flyctl ssh console -a fastzeroapp -C \"poetry run alembic upgrade head\"\n\nError: app fastzeroapp has no started VMs.\nIt may be unhealthy or not have been deployed yet.\nTry the following command to verify:\n\nfly status\n</code></pre><p></p> <p>Nesse caso, voc\u00ea pode tentar acessar sua aplica\u00e7\u00e3o pelo browser ou via terminal e ela iniciar\u00e1 novamente. Nesse momento, quando a m\u00e1quina estiver rodando, voc\u00ea pode rodar a migra\u00e7\u00e3o novamente.</p> <p>O comando <code>ssh</code> do <code>flyctl</code> \u00e9 um grupo de subcomandos para executar opera\u00e7\u00f5es espec\u00edficas em um container. Podemos pedir os logs de certificado com <code>ssh log</code>, inserir ou recuperar arquivos via FTP com o <code>ssh ftp</code>.</p> <p>O subcomando que utilizamos <code>ssh console</code> nos fornece acesso ao shell do container. Por isso tivemos que especificar com a flag <code>-a</code> o nome da nossa aplica\u00e7\u00e3o (poder\u00edamos acessar o console do banco de dados, tamb\u00e9m). E a flag <code>-C</code> \u00e9 o comando que queremos que seja executado no console do container. Nesse caso, o comando completo representa: \"Acesse o console do app fastzeroapp via SSH e execute o comando <code>poetry run alembic upgrade head</code>\".</p> <p>Dessa forma temos a migra\u00e7\u00e3o executada com sucesso. Voc\u00ea pode usar o comando <code>ssh console</code> sem especificar o comando tamb\u00e9m, dessa forma ele far\u00e1 um login via ssh no container.</p> <p>Com isso, podemos voltar ao swagger e tentar executar a opera\u00e7\u00e3o de cria\u00e7\u00e3o de um novo user com um POST no endpoit <code>/users</code>. Tudo deve ocorrer perfeitamente dessa vez:</p> <p></p> <p>Agora, SIM, nossa aplica\u00e7\u00e3o est\u00e1 em produ\u00e7\u00e3o para qualquer pessoa poder usar e aproveitar da sua aplica\u00e7\u00e3o. Mande o link para geral e veja o que as pessoas acham da sua mais nova aplica\u00e7\u00e3o. \ud83d\ude80</p>"},{"location":"13/#commit","title":"Commit","text":"<p>Agora que fizemos todas as altera\u00e7\u00f5es necess\u00e1rias, devemos adicionar ao nosso reposit\u00f3rio os arquivos criados pelo <code>flyctl launch</code>. Os arquivos <code>.dockerignore</code> e <code>fly.toml</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando arquivos gerados pelo Fly\"\ngit push\n</code></pre> <p>E pronto!</p>"},{"location":"13/#conclusao","title":"Conclus\u00e3o","text":"<p>Assim, como prometido, chegamos ao final da jornada! Temos uma aplica\u00e7\u00e3o pequena, mas funcional em produ\u00e7\u00e3o! \ud83d\ude80</p> <p>Ao longo desta aula, percorremos uma jornada sobre como implantar uma aplica\u00e7\u00e3o FastAPI com Docker no Fly.io, uma plataforma que oferece uma maneira simples e acess\u00edvel de colocar suas aplica\u00e7\u00f5es na nuvem. Exploramos alguns comandos do <code>flyctl</code> e fomos desde a configura\u00e7\u00e3o inicial at\u00e9 o processo de deploy e resolu\u00e7\u00e3o de problemas. Agora, com nossa aplica\u00e7\u00e3o pronta para o mundo, voc\u00ea possui o conhecimento necess\u00e1rio para compartilhar suas cria\u00e7\u00f5es com outras pessoas e continuar sua jornada no desenvolvimento web.</p> <p>Na pr\u00f3xima aula discutiremos um pouco sobre o que mais voc\u00ea pode aprender para continuar desenvolvendo seus conhecimentos em FastAPI e desenvolvimento web, al\u00e9m de claro, de algumas dicas de materiais. At\u00e9 l\u00e1!</p> <p>Agora que a aula acabou, \u00e9 um bom momento para voc\u00ea relembrar alguns conceitos e fixar melhor o conte\u00fado respondendo ao question\u00e1rio referente a ela.</p> <p>Quiz </p> <ol> <li> <p>No plano gratuito existe uma limita\u00e7\u00e3o de m\u00e1quinas dispon\u00edveis por aplica\u00e7\u00e3o. Quando usamos mais de uma m\u00e1quina, temos que ter um plano pago, por esse motivo, faremos o build localmente.\u00a0\u21a9</p> </li> <li> <p>\u00c9 poss\u00edvel executar a migra\u00e7\u00e3o usando a sua m\u00e1quina como ponto de partida. Para isso \u00e9 necess\u00e1rio usar o proxy do Fly: <code>fly proxy 5432 -a fastzerodb</code>. Dessa forma, a porta 5432 \u00e9 disponibilizada localmente para executar o comando. Acredito, por\u00e9m, que a conex\u00e3o via ssh \u00e9 mais proveitosa, no momento em que podemos explorar mais uma forma de interagir com o Fly.\u00a0\u21a9</p> </li> </ol>"},{"location":"14/","title":"Despedida e pr\u00f3ximos passos","text":""},{"location":"14/#despedida-e-proximos-passos","title":"Despedida e pr\u00f3ximos passos","text":"<p>Objetivos da aula:</p> <ul> <li>Fazer uma revis\u00e3o geral dos conceitos e pr\u00e1ticas que abordamos ao longo do curso.</li> <li>Encorajar a explora\u00e7\u00e3o futura e o aprofundamento em \u00e1reas espec\u00edficas.</li> <li>Agradecer a todos que acompanharam esta s\u00e9rie de aulas.</li> <li>Apresentar outros materiais criados com FastAPI.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto ou live! </p> <p>Estamos chegando ao final de nossa jornada juntos neste curso. Durante esse tempo, tivemos a oportunidade de explorar uma s\u00e9rie de conceitos e tecnologias essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. \u00c9 importante lembrar que o que vimos aqui \u00e9 apenas a ponta do iceberg. Ainda h\u00e1 muitos aspectos e detalhes que n\u00e3o pudemos cobrir neste curso, como tratamento de logs, observabilidade, seguran\u00e7a avan\u00e7ada, otimiza\u00e7\u00f5es de desempenho, entre outros. Encorajo a todos que continuem explorando e aprendendo.</p>"},{"location":"14/#revisao","title":"Revis\u00e3o","text":"<p>Ao longo deste curso, cobrimos uma s\u00e9rie de t\u00f3picos essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e robustas:</p> <ul> <li> <p>FastAPI: conhecemos e utilizamos o FastAPI, um moderno framework de desenvolvimento web para Python, que nos permite criar APIs de alto desempenho de forma eficiente e com menos c\u00f3digo.</p> </li> <li> <p>Docker: aprendemos a utilizar o Docker para criar um ambiente isolado e replic\u00e1vel para nossa aplica\u00e7\u00e3o, facilitando tanto o desenvolvimento quanto o deploy em produ\u00e7\u00e3o.</p> </li> <li> <p>Testes e TDD: abordamos a import\u00e2ncia dos testes automatizados e da metodologia TDD (Test Driven Development) para garantir a qualidade e a confiabilidade do nosso c\u00f3digo.</p> </li> <li> <p>Banco de dados e migra\u00e7\u00f5es: trabalhamos com bancos de dados SQL, utilizando o SQLAlchemy para a comunica\u00e7\u00e3o com o banco de dados, e o Alembic para gerenciar as migra\u00e7\u00f5es de banco de dados.</p> </li> <li> <p>Autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o: implementamos funcionalidades de autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o, utilizando o padr\u00e3o JWT.</p> </li> <li> <p>Integra\u00e7\u00e3o Cont\u00ednua (CI): utilizamos o Github Actions para criar um pipeline de CI, garantindo que os testes s\u00e3o sempre executados e que o c\u00f3digo mant\u00e9m uma qualidade constante.</p> </li> <li> <p>Deploy em produ\u00e7\u00e3o: por fim, fizemos o deploy da nossa aplica\u00e7\u00e3o em um ambiente de produ\u00e7\u00e3o real, utilizando o Fly.io, e aprendemos a gerenciar e configurar esse ambiente.</p> </li> </ul>"},{"location":"14/#outros-materiais-produzidos-por-mim-sobre-fastapi","title":"Outros materiais produzidos por mim sobre FastAPI","text":"<p>J\u00e1 cobrimos alguns temas n\u00e3o citados neste curso usando FastAPI em algumas Lives de Python. Voc\u00ea pode assistir para aprender mais tamb\u00e9m.</p>"},{"location":"14/#templates-e-websockets","title":"Templates e WebSockets","text":"<p>Na Live de Python #164 conversamos sobre websockets com Python e usamos FastAPI para exemplificar o comportamento. Durante essa live criamos uma aplica\u00e7\u00e3o de chat e usamos os templates com HTML e Jinja2 e Brython para a\u00e7\u00f5es din\u00e2micas como far\u00edamos com JavaScript.</p> <p></p>"},{"location":"14/#graphql-strawberry","title":"GraphQL (Strawberry)","text":"<p>Na Live de Python #185 conversamos sobre GraphQL um padr\u00e3o alternativo a REST APIs. Todos os exemplos foram aplicados usando Strawberry e FastAPI</p> <p></p>"},{"location":"14/#sqlmodel","title":"SQLModel","text":"<p>Na Live de Python #235 conversamos sobre SQLModel um ORM alternativo ao SQLAlchemy que se integra com o Pydantic. O SQLModel tamb\u00e9m foi desenvolvido pelo Sebastian (criador do FastAPI). Caminhando ao final dessa aula, podemos ver a implementa\u00e7\u00e3o do SQLModel em uma aplica\u00e7\u00e3o b\u00e1sica com FastAPI.</p> <p></p>"},{"location":"14/#fastui","title":"FastUI","text":"<p>Na Live de Python #259 conversamos sobre FastUI. Uma forma de usar modelos do Pydantic para retornar componentes React e contruir o front-end da aplica\u00e7\u00e3o coordenado pelo back-end. Um esquema de intera\u00e7\u00e3o de Back/Front conhecido como SDUI (Server-Driver User Interface).</p> <p></p>"},{"location":"14/#proximos-passos","title":"Pr\u00f3ximos passos","text":"<p>Parte importante do aprendizado vem de entender que o que vimos aqui \u00e9 o b\u00e1sico, o m\u00ednimo que devemos saber para conseguir fazer uma aplica\u00e7\u00e3o consistente usando FastAPI. Agora \u00e9 a hora de trilhar novos caminhos e conhecer mais as possibilidades. Tanto na constru\u00e7\u00e3o de APIs, quanto no aprofundamento de recursos do FastAPI.</p>"},{"location":"14/#observabilidade","title":"Observabilidade","text":"<p>Embora tenhamos conseguido colocar nossa aplica\u00e7\u00e3o no ar sem grandes problemas. Quando a aplica\u00e7\u00e3o passa da nossa m\u00e1quina, em nosso contexto, para ser utilizada em escala no deploy. Perdemos a visualiza\u00e7\u00e3o do que est\u00e1 acontecendo de fato com a aplica\u00e7\u00e3o. Os erros que est\u00e3o acontecendo, quais partes do sistema est\u00e3o sendo mais utilizadas, o tempo que nossa aplica\u00e7\u00e3o est\u00e1 levando para executar algumas tarefas, etc.</p> <p>Temos diversas pr\u00e1ticas e ferramentas que nos ajudam a entender como a aplica\u00e7\u00e3o est\u00e1 rodando em produ\u00e7\u00e3o. Como:</p> <ul> <li> <p>Logs: registros de eventos importantes do nosso sistema. Armazenados de forma estruturada e por data e hora. Por exemplo: se quis\u00e9ssemos saber todas \u00e0s vezes que algu\u00e9m registrou um usu\u00e1rio ou adicionou uma tarefa no banco de dados. Poder\u00edamos escrever isso em um arquivo de texto ou at\u00e9 mesmo enviar para um servidor de logs para vermos isso remotamente e entender um pouco sobre os eventos que est\u00e3o ocorrendo em produ\u00e7\u00e3o. \u00c9 uma forma de criar um \"hist\u00f3rico\" de eventos importantes.</p> <ul> <li>Algumas ferramentas que podem te ajudar a gerar logs com python: loguru, logging e eliot</li> </ul> J\u00e1 fizemos uma live sobre logs! <p></p> </li> <li> <p>Tracing: rastreamento do que acontece na aplica\u00e7\u00e3o. Por exemplo: quando nossa aplica\u00e7\u00e3o recebe uma requisi\u00e7\u00e3o, ela passa pelo ORM, o ORM faz uma chamada no banco de dados. Quanto tempo cada uma dessas opera\u00e7\u00f5es leva? A ideia do tracing \u00e9 rastrear o caminho por onde uma requisi\u00e7\u00e3o passa. Monitorando isso, podemos entender o fluxo que a aplica\u00e7\u00e3o toma em tempo de execu\u00e7\u00e3o.</p> <ul> <li>Algumas ferramentas que podem te ajudar a gerar trace: pytrace e trace.</li> </ul> </li> <li> <p>M\u00e9tricas: dados importantes sobre a utiliza\u00e7\u00e3o da aplica\u00e7\u00e3o. Como quantas vendas foram efetuadas nos \u00faltimos 15 minutos. Quantos erros nossa aplica\u00e7\u00e3o apresenta por dia. Qual a prefer\u00eancia de fluxos que os usu\u00e1rios e etc.</p> </li> </ul> Caso queria aprender mais sobre observabilidade com FastAPI <p>Fizemos uma s\u00e9rie sobre opentelemetry com os exemplos usando FastAPI e diversas integra\u00e7\u00f5es entre servi\u00e7os. Pode ser que voc\u00ea goste e aprenda mais sobre o framework.</p> <p>Uma introdu\u00e7\u00e3o a observabilidade usando FastAPI: </p> <p>M\u00e9tricas de observabilidade usando FastAPI como exemplo: </p> <p>Traces distribu\u00eddos com exemplos com FastAPI: </p> <p>Logs de observabilidade com exemplos com FastAPI: </p> <p>Uma pratica geral sobre observabilidade com FastAPI: </p> <p>Uma forma de unir todos os conceitos de observabilidade \u00e9 utilizando um APM ou construindo sua pr\u00f3pria \"central de  observabilidade\" com ferramentas como o Opentelemetry. Ele permite que instalemos diversas formas de instrumenta\u00e7\u00e3o em nossa aplica\u00e7\u00e3o e distribui os dados gerados para diversos backends. Como o Jaeger e o Grafana Tempo para armazenar traces. O Prometheus para ser um backend de m\u00e9tricas. O Grafana Loki para o armazenamento de logs. E por fim, criar um dashboard juntando todas essas informa\u00e7\u00f5es para exibir a sa\u00fade tanto da aplica\u00e7\u00e3o quanto das regras estabelecidas pelo neg\u00f3cio com o Grafana.</p>"},{"location":"14/#anotacao-de-tipos","title":"Anota\u00e7\u00e3o de tipos","text":"<p>Um dos pontos principais do uso do Pydantic e do FastAPI, que n\u00e3o nos aprofundamos nesse material.</p> <p>Durante esse material vimos tipos embutidos diferentes como <code>typing.Annotated</code>, tipos customizados pelo Pydantic como <code>email: EmailStr</code> ou at\u00e9 mesmo tipos criados pelo SQLAlchemy como: <code>Mapped[str]</code>. Entender como o sistema de tipos usa essas anota\u00e7\u00f5es em tempo de execu\u00e7\u00e3o pode ser bastante proveitoso para escrever um c\u00f3digo que ser\u00e1 mais seguro em suas rela\u00e7\u00f5es.</p> <p>O sistema de tipos do python est\u00e1 descrito aqui. Voc\u00ea pode estudar mais por esse material.</p> Nota do @dunossauro <p>Meu pr\u00f3ximo material em texto ser\u00e1 um livro online e gratuito sobre tipagem gradual com python. Quando estiver dispon\u00edvel, eu atualizarei essa p\u00e1gina com o link!</p>"},{"location":"14/#tarefas-em-background","title":"Tarefas em background","text":"<p>Um exemplo b\u00e1sico</p> <p>Um exemplo b\u00e1sico de uso de tarefas em segundo plano pode ser encontrado no ap\u00eandice B.</p> <p>Uma das coisas legais de poder usar AsyncIO \u00e9 poder realizar tarefas em segundo plano. Isso pode ser uma confirma\u00e7\u00e3o de cria\u00e7\u00e3o de conta, como um e-mail. Ou at\u00e9 mesmo a gera\u00e7\u00e3o de um relat\u00f3rio semanal.</p> <p>Existem v\u00e1rias formas incr\u00edveis de uso, n\u00e3o irei me estender muito nesse t\u00f3pico, pois a documenta\u00e7\u00e3o do fastAPI tem uma \u00f3tima p\u00e1gina em portugu\u00eas sobre Tarefas em segundo plano. Acredito que valha a pena a leitura!</p>"},{"location":"14/#conclusao","title":"Conclus\u00e3o","text":"<p>Todos esses conceitos e pr\u00e1ticas s\u00e3o componentes fundamentais no desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. Eles nos permitem criar aplica\u00e7\u00f5es robustas, confi\u00e1veis e eficientes, que podem ser facilmente mantidas e escaladas.</p> <p>Gostaria de agradecer a todos que acompanharam essa s\u00e9rie de aulas. Espero que tenham encontrado valor nas informa\u00e7\u00f5es e pr\u00e1ticas que compartilhamos aqui. Lembre-se, a jornada do aprendizado \u00e9 cont\u00ednua e cada passo conta. Continue explorando, aprendendo e crescendo.</p> <p>At\u00e9 mais!</p>"},{"location":"15/","title":"Projeto final","text":""},{"location":"15/#projeto-final","title":"Projeto final","text":"<p>Voc\u00ea chegou ao final, PARABAINS \ud83c\udf89</p> <p>No aprendizado, nada melhor que praticar! Para isso, vamos fazer nosso \"TCC\" ou como gostam de chamar no mundo \"interprize bizines\": um teste t\u00e9cnico.</p> <p>A ideia deste projeto final \u00e9 simplesmente extrair tudo que aprendemos no curso para um grande exerc\u00edcio de fixa\u00e7\u00e3o em formato de projeto.</p>"},{"location":"15/#o-projeto","title":"O projeto","text":"<p>Neste projeto vamos construir uma API que segue os mesmos moldes da que desenvolvemos durante o curso, por\u00e9m, com outra proposta. Iremos fazer uma vers\u00e3o simplificado de um acervo digital de livros. Chamaremos de <code>MADR</code> (Mader), uma sigla para \"Meu Acervo Digital de Romances\".</p> <p>O objetivo do projeto \u00e9 criarmos um gerenciador de livros e relacionar com seus autores. Tudo isso em um contexto bastante simplificado. Usando somente as funcionalidades que aprendemos no curso.</p> <p>A implementa\u00e7\u00e3o ser\u00e1 baseada em 3 pilares:</p> <pre><code>graph\n    MADR --&gt; A[\"Controle de acesso / Gerenciamento de contas\"]\n    MADR --&gt; B[\"Gerenciamento de Livros\"]\n    MADR --&gt; C[\"Gerenciamento de Romancistas\"]\n    A --&gt; D[\"Gerenciamento de contas\"]\n    D --&gt; Cria\u00e7\u00e3o\n    D --&gt; Atualiza\u00e7\u00e3o\n    A --&gt; G[\"Acesso via JWT\"]\n    D --&gt; Dele\u00e7\u00e3o\n    B --&gt; E[\"CRUD\"]\n    C --&gt; F[\"CRUD\"]</code></pre>"},{"location":"15/#a-api","title":"A API","text":"<p>Dividiremos os endpoints em tr\u00eas <code>routers</code>:</p> <ol> <li><code>contas</code>: Gerenciamento de contas e de acesso \u00e0 API</li> <li><code>livros</code>: Gerenciamento de livros</li> <li><code>romancistas</code>: Gerenciamento de romancistas</li> </ol>"},{"location":"15/#contas","title":"Contas","text":"<p>O router de conta deve ser respons\u00e1vel pelas opera\u00e7\u00f5es referentes a cria\u00e7\u00e3o, altera\u00e7\u00e3o e dele\u00e7\u00e3o de contas. Os endpoints:</p> <ul> <li> <p>POST <code>/conta</code>: deve ser respons\u00e1vel pela cria\u00e7\u00e3o de uma nova conta</p> <ul> <li>O schema respons\u00e1vel para cria\u00e7\u00e3o desse endpoint deve ser: <pre><code>{\n    \"username\": \"fausto\",\n    \"email\": \"fausto@fausto.com\",\n    \"senha\": \"1234567\",\n}\n</code></pre></li> <li>Esses schema deve ser validado com pydantic</li> <li>O retorno para o caso de sucesso deve ser <code>201</code> e com o schema de exemplo: <pre><code>{\n    \"id\": 10,\n    \"email\": \"fausto@fausto.com\",\n    \"username\": \"fausto\"\n}\n</code></pre></li> <li>A senha deve ser criptografada antes de ser inserida no banco de dados</li> <li>obs: N\u00e3o \u00e9 necess\u00e1rio fazer o login no sistema para enviar uma requisi\u00e7\u00e3o para esse enpoint</li> <li>\ud83d\udea8 Caso o registro j\u00e1 exista na base, conflito</li> <li> Antes de inserir no banco, o nome deve ser sanitizado</li> </ul> </li> <li> <p>PUT <code>/conta/{id}</code>: deve ser respons\u00e1vel pela altera\u00e7\u00e3o de uma conta especificada por <code>id</code></p> <ul> <li>O schema respons\u00e1vel para cria\u00e7\u00e3o desse endpoint deve ser: <pre><code>{\n    \"username\": \"fausto\",\n    \"email\": \"fausto@fausto.com\",\n    \"senha\": \"1234567\",\n}\n</code></pre></li> <li>Esses schema deve ser validado com pydantic</li> <li>O retorno para o caso de sucesso deve ser <code>200</code> e com o schema de exemplo: <pre><code>{\n    \"id\": 10,\n    \"email\": \"fausto@fausto.com\",\n    \"username\": \"fausto\"\n}\n</code></pre></li> <li>\ud83d\udea8 O acesso s\u00f3 pode ocorrer via um <code>Bearer token</code> v\u00e1lido enviado nos headers, erro</li> <li>\ud83d\udea8 Somente a pessoa detentora da sua pr\u00f3pria conta pode alterar seus dados</li> <li>\ud83d\udea8 Caso as altera\u00e7\u00f5es no registro j\u00e1 existam na base, conflito</li> <li> Antes de inserir no banco, o nome deve ser sanitizados</li> </ul> </li> <li> <p>DELETE <code>/conta/{id}</code>: deve ser respons\u00e1vel pela dele\u00e7\u00e3o de uma conta especificada por <code>id</code></p> <ul> <li>O retorno para o caso de sucesso deve ser <code>200</code> e com o schema de exemplo: <pre><code>{\n    \"message\": \"Conta deletada com sucesso\"\n}\n</code></pre></li> <li>\ud83d\udea8 O acesso s\u00f3 pode ocorrer via um <code>Bearer token</code> v\u00e1lido enviado nos headers, erro</li> <li>\ud83d\udea8 Somente a pessoa detentora da sua pr\u00f3pria conta pode alterar seus dados</li> </ul> </li> <li> <p>POST <code>/token</code>: Respons\u00e1vel pelo login</p> <ul> <li>O endpoint dever\u00e1 receber o seguinte schema via <code>OAuth2PasswordRequestForm</code>: <pre><code>{\n    \"username\": \"fausto@fausto.com\",\n    \"password\": \"12345\"\n}\n</code></pre></li> <li>O conta deve ser validada com \"username\" e \"password\"</li> <li>\ud83d\udea8 O acesso s\u00f3 pode ocorrer via um <code>Bearer token</code> v\u00e1lido enviado nos headers, erro</li> <li>O retorno para o caso de sucesso deve ser <code>200</code> e com o schema de exemplo: <pre><code>{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\",\n    \"token_type\": \"bearer\"\n}\n</code></pre></li> </ul> </li> <li> <p>POST <code>/refresh-token</code>: Respons\u00e1vel por atualizar o token</p> <ul> <li>O endpoint dever\u00e1 receber os headers: <pre><code>{\n    \"Authorization\": \" Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\"\n}\n</code></pre></li> <li>O retorno para o caso de sucesso deve ser <code>200</code> e com o schema de exemplo: <pre><code>{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\",\n    \"token_type\": \"bearer\"\n}\n</code></pre></li> <li>\ud83d\udea8 Caso as coisas n\u00e3o ocorram como o esperado: Erros</li> </ul> </li> </ul>"},{"location":"15/#as-condicoes-do-token-jwt","title":"As condi\u00e7\u00f5es do token JWT","text":"<p>O tempo de expira\u00e7\u00e3o do token deve ser de <code>60</code> minutos, o algor\u00edtimo usado deve ser <code>HS256</code> e o subject deve ser o <code>email</code>.</p>"},{"location":"15/#livros","title":"Livros","text":"<ul> <li> <p>POST <code>/livro</code>: Respons\u00e1vel pela adi\u00e7\u00e3o de um livro no MADR</p> <ul> <li>O livro deve ser criado com base no seguinte schema: <pre><code>{\n    \"ano\": 1973,\n    \"titulo\": \"Caf\u00e9 Da Manh\u00e3 Dos Campe\u00f5es\",\n    \"romancista_id\": 42\n}\n</code></pre></li> <li>O retorno de sucesso <code>200</code> deve ser: <pre><code>{\n    \"id\": 3,\n    \"ano\": 1973,\n    \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n    \"romancista_id\": 42\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li> Antes de inserir no banco, os nomes devem ser sanitizados</li> <li>\ud83d\udea8 Caso o novo nome j\u00e1 exista na base, conflito</li> </ul> </li> <li> <p>DELETE <code>/livro/{id}</code>: Respons\u00e1vel por deletar um livro usando o <code>id</code> como base</p> <ul> <li>O caso de sucesso <code>200</code> deve retornar o schema: <pre><code>{\n    \"message\": \"Livro deletado no MADR\"\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> </ul> </li> <li> <p>PATCH <code>/livro/{id}</code>: Respons\u00e1vel por alterar um livro usando o <code>id</code> como base</p> <ul> <li>O livro deve ser alterado com o seguinte schema: <pre><code>{\n    \"ano\": 1974\n}\n</code></pre></li> <li>O schema para o caso de sucesso <code>200</code> deve ser: <pre><code>{\n    \"ano\": 1974,\n    \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n    \"romancista_id\": 1\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li> Antes de inserir no banco, os nomes devem ser sanitizados</li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> <li>\ud83d\udea8 Caso o novo nome j\u00e1 exista na base, conflito</li> </ul> </li> <li> <p>GET <code>/livro/{id}</code>: Busca um livro por <code>id</code></p> <ul> <li>O retorno deve ser <code>200 OK</code> com o schema: <pre><code>{\n    \"id\": 1,\n    \"ano\": 1974,\n    \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n    \"romancista_id\": 1\n}\n</code></pre></li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> </ul> </li> <li> <p>GET <code>/livro?nome=xxxx&amp;ano=xxxx</code>: Busca por livros quando query parameters</p> <ul> <li>Deve ser capaz de filtrar por nome de forma parcial</li> <li>Deve ser capaz de filtrar por ano</li> <li>Deve paginar os resultados maiores que 20</li> <li>Exemplo de chamada: <pre><code>/livro/?titulo=a&amp;ano=1900\n</code></pre></li> <li>Exemplo do schema de resposta: <pre><code>{\n    \"livros\": [\n        {\"ano\": 1900, \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\", \"romancista_id\": 1, \"id\": 1},\n        {\"ano\": 1900, \"titulo\": \"mem\u00f3rias p\u00f3stumas de br\u00e1s cubas\", \"romancista_id\": 2, \"id\": 2}\n    ]\n}\n</code></pre></li> <li> Caso n\u00e3o encontre nenhuma correspond\u00eancia, dever\u00e1 retornar <code>200 OK</code> com a lista vazia: <pre><code>{\n    \"livros\": []\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"15/#romancistas","title":"Romancistas","text":"<ul> <li> <p>POST <code>/romancista</code>: Respons\u00e1vel pela adi\u00e7\u00e3o de romancistas no MADR</p> <ul> <li>Romancista devem ser criadas com base no seguinte schema: <pre><code>{\n    \"nome\": \"Clarice Lispector\"\n}\n</code></pre></li> <li>A resposta padr\u00e3o deve retornar <code>201</code> com o schema: <pre><code>{\n    \"id\": 42,\n    \"nome\": \"Clarice Lispector\"\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li> Antes de inserir no banco, os nomes devem ser sanitizados</li> <li>\ud83d\udea8 Caso o novo nome j\u00e1 exista na base, conflito</li> </ul> </li> <li> <p>DELETE <code>/romancista/{id}</code>: respons\u00e1vel pela dele\u00e7\u00e3o de romancistas por <code>id</code></p> <ul> <li>O retorno para o caso de sucesso deve ser <code>200</code> e com o schema de exemplo: <pre><code>{\n    \"message\": \"Romancista deletada no MADR\"\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> </ul> </li> <li> <p>PATCH <code>/romancista/{id}</code>: respons\u00e1vel pela altera\u00e7\u00e3o de romancistas por <code>id</code></p> <ul> <li>Romancista devem ser alteradas com base no seguinte schema: <pre><code>{\n    \"nome\": \"Clarice Lispector\"\n}\n</code></pre></li> <li>A resposta padr\u00e3o deve retornar <code>200</code> com o schema: <pre><code>{\n    \"id\": 42,\n    \"nome\": \"Clarice Lispector\"\n}\n</code></pre></li> <li> Dispon\u00edvel somente via autentica\u00e7\u00e3o, caso contr\u00e1rio erro</li> <li> Antes de inserir no banco, os nomes devem ser sanitizados</li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> <li>\ud83d\udea8 Caso o novo nome j\u00e1 exista na base, conflito</li> </ul> </li> <li> <p>GET <code>/romancista/{id}</code>: Busca um romancista por <code>id</code></p> <ul> <li>O retorno deve ser <code>200 OK</code> com o schema: <pre><code>{\n    \"id\": 1,\n    \"nome\": \"machado de assis\"\n}\n</code></pre></li> <li>\ud83d\udea8 Caso o <code>id</code> n\u00e3o exista no MADR, erro</li> </ul> </li> <li> <p>GET <code>/romancista?</code>: Busca romancistas baseado em nomes parciais</p> <ul> <li>Deve ser capaz de filtrar por nome de forma parcial</li> <li>Deve paginar os resultados maiores que 20</li> <li>Exemplo de chamada: <pre><code>/romancista/?nome=a\n</code></pre></li> <li>Exemplo do schema de resposta: <pre><code>{\n    \"romancistas\": [\n        {\"nome\": \"machado de assis\", \"id\": 1},\n        {\"nome\": \"clarice lispector\", \"id\": 2},\n        {\"nome\": \"jos\u00e9 de alencar\", \"id\": 3},\n    ]\n}\n</code></pre></li> <li> Caso n\u00e3o encontre nenhuma correspond\u00eancia, dever\u00e1 retornar <code>200 OK</code> com a lista vazia: <pre><code>{\n    \"romancistas\": []\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"15/#sanitizacao-de-dados","title":"Sanitiza\u00e7\u00e3o de dados","text":"<p>Antes de inserir no banco, os nomes de romancistas ou livros devem ser sanitizados.</p> <p>Exemplos para os nomes:</p> Entrada Sanitizado \"Machado de Assis\" machado de assis \"Manuel\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Bandeira\" manuel bandeira \"Edgar Alan Poe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\" edgar alan poe \"Androides Sonham Com Ovelhas El\u00e9tricas?\" androides sonham com ovelhas el\u00e9tricas \"\u00a0\u00a0breve \u00a0hist\u00f3ria \u00a0do tempo\u00a0\" breve hist\u00f3ria do tempo \"O mundo assombrado pelos dem\u00f4nios\" o mundo assombrado pelos dem\u00f4nios"},{"location":"15/#erros","title":"Erros","text":""},{"location":"15/#erros-de-autenticacao","title":"Erros de autentica\u00e7\u00e3o","text":"<p>Todos os erros relativos \u00e0 autentica\u00e7\u00e3o devem retornar o status code <code>400 BAD REQUEST</code> com o seguinte schema:</p> <pre><code>{\n    \"message\": \"Email ou senha incorretos\"\n}\n</code></pre>"},{"location":"15/#erros-de-permissao","title":"Erros de permiss\u00e3o","text":"<p>Caso uma pessoa tente fazer uma opera\u00e7\u00e3o sem a permiss\u00e3o necess\u00e1ria, o status code<code>401 Unauthorized</code> dever\u00e1 ser retornado com o json:</p> <pre><code>{\n    \"message\": \"N\u00e3o autorizado\"\n}\n</code></pre>"},{"location":"15/#erro-nao-encontrado","title":"Erro n\u00e3o encontrado","text":"<p>Caso o <code>id</code> n\u00e3o exista no MADR, um erro <code>404 NOT FOUND</code> deve ser retornado com o json:</p> <pre><code>{\n    \"message\": \"Romancista n\u00e3o consta no MADR\"\n}\n</code></pre> <p>ou ent\u00e3o</p> <pre><code>{\n    \"message\": \"Livro n\u00e3o consta no MADR\"\n}\n</code></pre>"},{"location":"15/#erro-de-conflito","title":"Erro de conflito","text":"<p>Caso o recurso j\u00e1 exista, devemos retornar <code>409 CONFLICT</code> com o json:</p> <pre><code>{\n    \"message\": \"{recurso} j\u00e1 consta no MADR\"\n}\n</code></pre> <p>Onde a vari\u00e1vel <code>recurso</code> \u00e9 relativa ao recurso que est\u00e1 duplicado. Exemplos para:</p> <ul> <li>contas: <code>\"conta j\u00e1 consta no MADR\"</code></li> <li>livros: <code>\"livro j\u00e1 consta no MADR\"</code></li> <li>romancista: <code>\"romancista j\u00e1 consta no MADR\"</code></li> </ul>"},{"location":"15/#o-banco-de-dados-orm","title":"O banco de dados / ORM","text":"<p>A modelagem do banco deve contar com tr\u00eas tabelas: <code>User</code>, <code>Livro</code> e <code>Romancista</code>. Onde <code>Livro</code> e <code>Romancista</code> se relacionam da forma que romancistas podem estar relacionado a diversos livros e diversos livros devem ser associados a uma \u00fanica romancista. Como sugere o DER:</p> <pre><code>erDiagram\n  Romancista |o -- |{ Livro : livros\n  User {\n      int id PK\n      string email UK\n      string username UK\n      string senha\n  }\n  Livro {\n      int id  PK\n      string ano\n      string titulo UK\n      string id_romancista FK\n  }\n  Romancista {\n      int id PK\n      string nome UK\n      string livros\n  }</code></pre>"},{"location":"15/#relacionamentos-no-orm","title":"Relacionamentos no ORM","text":"<p>Alguns problemas podem ser encontrados durante a cria\u00e7\u00e3o dos relacionamentos com SQLAlchemy, ent\u00e3o segue uma cola simples caso sinta que travou.</p> Em caso de emerg\u00eancia quebre o vidro <pre><code>class Livro:\n    ...\n\n    autoria: Mapped[Romancista] = relationship(\n        init=False, back_populates='livros'\n    )\n\nclass Romancista:\n    ...\n\n    livros: Mapped[list['Livro']] = relationship(\n        init=False, back_populates='romancista', cascade='all, delete-orphan'\n    )\n</code></pre>"},{"location":"15/#cenarios-de-teste","title":"Cen\u00e1rios de teste","text":"<p>O ideal \u00e9 que esse projeto tenha uma cobertura de testes de 100%. Afinal, foi dessa forma que passamos nosso tempo no curso, testando absolutamente tudo e garantindo que o c\u00f3digo funcione da maneira como deveria.</p> <p>Nesse t\u00f3pico separei alguns cen\u00e1rios de testes usando a linguagem gherkin para te ajudar a pensar em como as requisi\u00e7\u00f5es ser\u00e3o recebidas e devem ser respondidas pela aplica\u00e7\u00e3o.</p> <p>Esses cen\u00e1rios podem te guiar tanto para escrever a aplica\u00e7\u00e3o, quanto os testes.</p>"},{"location":"15/#gerenciamento-de-contas","title":"Gerenciamento de contas","text":"Cria\u00e7\u00e3o de contasCasos de erroAutentica\u00e7\u00e3o e autoriza\u00e7\u00e3o <pre><code>Funcionalidade: Gerenciamento de conta\n\nCen\u00e1rio: Cria\u00e7\u00e3o de conta\n    Quando enviar um \"POST\" em \"/user\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"123456\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"201\"\n    E o json contendo\n    \"\"\"\n    {\n        \"email\": \"dudu@dudu.com\",\n        \"username\": \"dunossauro\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Altera\u00e7\u00e3o de conta\n    Quando enviar um \"POST\" em \"/user\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"123456\"\n    }\n    \"\"\"\n    Quando enviar um \"PUT\" em \"/user/1\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"654321\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Dele\u00e7\u00e3o da conta\n    Quando enviar um \"POST\" em \"/user\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"123456\"\n    }\n    \"\"\"\n    Quando enviar um \"DELETE\" em \"/user/1\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"message\": \"Conta deletada com sucesso\"\n    }\n    \"\"\"\n</code></pre> <pre><code>Cen\u00e1rio: Cria\u00e7\u00e3o de conta j\u00e1 existente\n    Quando enviar um \"POST\" em \"/user\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"123456\"\n    }\n    \"\"\"\n    Quando enviar um \"POST\" em \"/user\"\n    \"\"\"\n    {\n        \"username\": \"dunossauro\",\n        \"email\": \"dudu@dudu.com\",\n        \"password\": \"123456\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"400\"\n    E o json contendo\n    \"\"\"\n    {\n        \"message\": \"Conta j\u00e1 cadastrada\"\n    }\n    \"\"\"\n</code></pre> <pre><code>Cen\u00e1rio: Autentica\u00e7\u00e3o via JWT\n    Quando enviar um \"POST\" em \"/token\"\n    \"\"\"\n    {\n        \"username\": \"fausto@fausto.com\",\n        \"password\": \"12345\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\",\n        \"token_type\": \"bearer\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Autentica\u00e7\u00e3o via JWT com usu\u00e1rio n\u00e3o existente\n    Quando enviar um \"POST\" em \"/token\"\n    \"\"\"\n    {\n        \"username\": \"fausto@fausto.com\",\n        \"password\": \"12345\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"400\"\n    E o json contendo\n    \"\"\"\n    {\n        \"detail\": \"Incorrect email or password\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Autoriza\u00e7\u00e3o via Bearer token\n    Dado que envie um \"POST\" em \"/token\"\n    \"\"\"\n    {\n        \"username\": \"fausto@fausto.com\",\n        \"password\": \"12345\"\n    }\n    \"\"\"\n    Quando enviar um \"POST\" em \"/livro\"\n    \"\"\"\n    {\n        \"nome\": \"Clarice Lispector\"\n    }\n    \"\"\"\n    Ent\u00e3o deve receber o status \"201\"\n    E o json contendo\n    \"\"\"\n    {\n        \"id\": 42,\n        \"nome\": \"Clarice Lispector\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Tentativa de opera\u00e7\u00e3o sem autoriza\u00e7\u00e3o\n   Quando enviar um \"POST\" em \"/livro\"\n    \"\"\"\n    {\n        \"nome\": \"Clarice Lispector\"\n    }\n    \"\"\"\n    Ent\u00e3o deve receber o status \"401\"\n    E o json contendo\n    \"\"\"\n    {\n        \"message\": \"N\u00e3o autorizado\"\n    }\n    \"\"\"\n</code></pre>"},{"location":"15/#gerenciamento-de-livros","title":"Gerenciamento de livros","text":"<pre><code>Funcionalidade: Livro\n\nCen\u00e1rio: Registro de livro\n    Quando enviar um \"POST\" em \"/livro/\"\n    \"\"\"\n    {\n        \"ano\": 1973,\n        \"titulo\": \"Caf\u00e9 Da Manh\u00e3 Dos Campe\u00f5es\",\n        \"romancista_id\": 1\n    }\n    \"\"\"\n\n    Ent\u00e3o devo receber o status \"201\"\n    E o json contendo\n    \"\"\"\n    {\n        \"ano\": 1973,\n        \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n        \"romancista_id\": 1\n    }\n    \"\"\"\n\n\nCen\u00e1rio: Altera\u00e7\u00e3o de livro\n    Quando enviar um \"PATCH\" em \"/livro/1\"\n    \"\"\"\n    {\n        \"ano\": 1974\n    }\n    \"\"\"\n\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"ano\": 1974,\n        \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n        \"romancista_id\": 1\n    }\n    \"\"\"\n\nCen\u00e1rio: Buscar livro por ID\n    Quando enviar um \"GET\" em \"/livro/1\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"ano\": 1974,\n        \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\",\n        \"romancista_id\": 1\n    }\n    \"\"\"\n\nCen\u00e1rio: Dele\u00e7\u00e3o de livro\n    Quando enviar um \"DELETE\" em \"/livro/1\"\n\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"message\": \"Livro deletado no MADR\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Filtro de livros\n    Quando enviar um \"POST\" em \"/livro/\"\n    \"\"\"\n    {\n        \"ano\": 1900,\n        \"titulo\": \"Caf\u00e9 Da Manh\u00e3 Dos Campe\u00f5es\",\n        \"romancista_id\": 1\n    }\n    \"\"\"\n    E enviar um \"POST\" em \"/livro/\"\n    \"\"\"\n    {\n        \"ano\": 1900,\n        \"titulo\": \"Mem\u00f3rias P\u00f3stumas de Br\u00e1s Cubas\",\n        \"romancista_id\": 2\n    }\n    \"\"\"\n    E enviar um \"POST\" em \"/livro/\"\n    \"\"\"\n    {\n        \"ano\": 1865,\n        \"titulo\": \"Iracema\",\n        \"romancista_id\": 3\n    }\n    \"\"\"\n    E enviar um \"GET\" em \"/livro/?titulo=a&amp;ano=1900\"\n\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"livros\": [\n            {\"ano\": 1900, \"titulo\": \"caf\u00e9 da manh\u00e3 dos campe\u00f5es\", \"romancista_id\": 1, \"id\": 1},\n            {\"ano\": 1900, \"titulo\": \"mem\u00f3rias p\u00f3stumas de br\u00e1s cubas\", \"romancista_id\": 2, \"id\": 2}\n        ]\n    }\n    \"\"\"\n</code></pre>"},{"location":"15/#gerenciamento-de-romancistas","title":"Gerenciamento de romancistas","text":"<pre><code>Funcionalidade: Romancistas\n\n\nCen\u00e1rio: Cria\u00e7\u00e3o de Romancista\n    Quando enviar um \"POST\" em \"/romancista\"\n    \"\"\"\n    {\n        \"nome\": \"Clarice Lispector\"\n    }\n    \"\"\"\n\n    Ent\u00e3o devo receber o status \"201\"\n    E o json contendo\n    \"\"\"\n    {\n        \"nome\": \"clarice lispector\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Buscar romancista por ID\n    Quando enviar um \"GET\" em \"/romancista/1\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"nome\": \"clarice lispector\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Altera\u00e7\u00e3o de Romancista\n    Quando enviar um \"PUT\" em \"/romancista/1\"\n    \"\"\"\n    {\n        \"nome\": \"manuel bandeira\"\n    }\n    \"\"\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"nome\": \"manuel bandeira\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Dele\u00e7\u00e3o de Romancista\n    Quando enviar um \"DELETE\" em \"/romancista/1\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"message\": \"Romancista deletada no MADR\"\n    }\n    \"\"\"\n\nCen\u00e1rio: Busca de romancistas por filtro\n    Quando enviar um \"POST\" em \"/romancista\"\n    \"\"\"\n    {\n        \"nome\": \"Clarice Lispector\"\n    }\n    \"\"\"\n\n    E enviar um \"POST\" em \"/romancista\"\n    \"\"\"\n    {\n        \"nome\": \"Manuel Bandeira\"\n    }\n    \"\"\"\n\n    E enviar um \"POST\" em \"/romancista\"\n    \"\"\"\n    {\n        \"nome\": \"Paulo Leminski\"\n    }\n    \"\"\"\n\n    Quando enviar um \"GET\" em \"/romancista?nome=a\"\n    Ent\u00e3o devo receber o status \"200\"\n    E o json contendo\n    \"\"\"\n    {\n        \"romancistas\": [\n            {\"nome\": \"clarice lispector\", \"id\": 1},\n            {\"nome\": \"manuel bandeira\", \"id\": 2},\n            {\"nome\": \"paulo leminski\", \"id\": 3}\n        ]\n    }\n    \"\"\"\n</code></pre>"},{"location":"15/#ferramentas","title":"Ferramentas","text":"<p>Gostaria que voc\u00ea se sentissem livres para escolher o conjunto de ferramentas que mais gostarem para fazer esse projeto. O formatador preferido, o servidor de aplica\u00e7\u00e3o preferido, projeto de vari\u00e1veis de ambiente preferido, etc.</p> <p>As \u00fanicas coisas exigidas para a cria\u00e7\u00e3o desse projeto s\u00e3o:</p> <ol> <li>Python 3.11+</li> <li>FastAPI</li> <li>SQLAlchemy</li> <li>Alguma ferramenta para gerenciamento de projeto que suporte <code>pyproject.toml</code></li> <li>PostgreSQL</li> <li>Containers (a ferramenta que preferir. Podman/docker/k8s/...)</li> <li>Pytest</li> </ol>"},{"location":"15/#entrega-do-projeto-final","title":"Entrega do projeto final","text":"<p>Criar um projeto utilizando git e hospedado em alguma plataforma (github/gitlab/codeberg/...) e postar nessa issue. Ao final, juntarei todos os projetos finais em uma tabela nesse site para que as pessoas possam aprender com as diferen\u00e7as entre os projetos.</p> <p>\u00c9 imprescind\u00edvel que seu projeto tenha um <code>README.md</code> explicando quais foram as suas escolhas e como executar o seu projeto. Para podermos rodar e aprender com ele.</p>"},{"location":"alteracoes/","title":"Altera\u00e7\u00f5es","text":""},{"location":"alteracoes/#alteracoes","title":"Altera\u00e7\u00f5es","text":""},{"location":"alteracoes/#fastapi-do-zero-alteracoes-ainda-sem-release-2025-10-31","title":"fastapi-do-zero Altera\u00e7\u00f5es ainda sem release (2025-10-31)","text":""},{"location":"alteracoes/#atualizacoes","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>fastapi</code> 0.120.1 -&gt; 0.120.3</li> <li><code>ruff</code> 0.14.2 -&gt; 0.14.3</li> </ul>"},{"location":"alteracoes/#fastapi-do-zero-43-2025-10-29","title":"fastapi-do-zero 4.3 (2025-10-29)","text":""},{"location":"alteracoes/#pontos-da-release","title":"Pontos da release","text":"<ul> <li>Suporte ao Python 3.14 no material</li> <li>Altera\u00e7\u00e3o no <code>mapped_as_dataclass</code> para seguir as novas recomenda\u00e7\u00f5es do SQLAlchemy</li> <li>Altera\u00e7\u00f5es na fixture do sqlalchemy para n\u00e3o gerar <code>ResourceWarning</code></li> </ul>"},{"location":"alteracoes/#adicionado","title":"Adicionado","text":"<ul> <li>Suporte ao python <code>3.14</code> (#453)</li> <li>Aula 08: nota sobre a execu\u00e7\u00e3o do <code>coverage</code> e a escolha fixada no <code>ctrace</code></li> </ul>"},{"location":"alteracoes/#correcoes","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Adicionando <code>engine.dispose</code> para garatir que a DBAPI n\u00e3o levante warnings relativos ao n\u00e3o fechamento do fixture do banco de dados</li> <li>Ajuste de typo na p\u00e1gina inicial</li> </ul>"},{"location":"alteracoes/#alterado","title":"Alterado","text":"<ul> <li><code>mapped_as_dataclass</code> agora segue o novo formato definido na vers\u00e3o <code>2.0.44</code> do <code>sqlalchemy</code></li> </ul>"},{"location":"alteracoes/#atualizacoes_1","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>alembic</code> 1.16.5 -&gt; 1.17.1</li> <li><code>fastapi[standard]</code> 0.116.2 -&gt; 0.120.1</li> <li><code>poetry</code> 2.2.0 -&gt; 2.2.1</li> <li><code>psycopg</code> 3.2.10 -&gt; 3.2.12</li> <li><code>pwdlib</code> 0.2.1 -&gt; 0.3.0</li> <li><code>pydantic-settings</code> 2.10.1 -&gt; 2.11.1</li> <li><code>pydantic</code> 2.12.0 -&gt; 2.12.3</li> <li><code>ruff</code> 0.13.0 -&gt; 0.14.2</li> <li><code>sqlalchemy[asyncio]</code> 2.0.43 -&gt; 2.0.44</li> <li><code>testcontainers</code> 4.13.0 -&gt; 4.13.2</li> </ul>"},{"location":"alteracoes/#interno","title":"Interno","text":"<ul> <li>CI: Agora a vers\u00e3o padr\u00e3o para os steps fora dos testes \u00e9 o 3.14 (#453)</li> <li>CI: Build das imagens docker em um novo job</li> </ul>"},{"location":"alteracoes/#420-2025-09-17","title":"4.2.0 (2025-09-17)","text":""},{"location":"alteracoes/#pontos-da-release_1","title":"Pontos da release","text":"<ul> <li>Suporte a PEP 735 <code>[dependency-groups]</code></li> <li>Corre\u00e7\u00f5es de texto</li> <li>Updates de ver\u00f5es de bibliotecas</li> <li>Updates do CI</li> </ul>"},{"location":"alteracoes/#correcoes_1","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Typo corrigido nas aulas 08 e 11 por @thiagonebuloni (#429)</li> </ul>"},{"location":"alteracoes/#alterado_1","title":"Alterado","text":"<ul> <li>Usando <code>[dependency-groups]</code> da pep 735 implementando no <code>poetry 2.2</code>. Por @taconi (#292)</li> </ul>"},{"location":"alteracoes/#atualizacoes_2","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li>Update das actions do CI na 12. <code>checkout</code> v4 -&gt; v5</li> <li>Update das actions do CI na 12. <code>setup-python</code> v5 -&gt; v6</li> <li><code>alembic</code> 1.16.2 -&gt; 1.16.5</li> <li><code>fastapi[standard]</code> 0.115.14 -&gt; 0.116.2</li> <li><code>freezegun</code> 1.5.2 -&gt; 1.5.5</li> <li><code>pytest-asyncio</code> 1.0.0 -&gt; 1.2.0</li> <li><code>pytest-cov</code> 6.3.0 -&gt; 7.0.0</li> <li><code>pytest</code> 8.4.1 -&gt; 8.4.2</li> <li><code>ruff</code> 0.12.1 -&gt; 0.13.0</li> <li><code>sqlalchemy</code> 2.0.41 -&gt; 2.0.43</li> <li><code>testcontainers</code> 4.10.0 -&gt; 4.13.0</li> </ul>"},{"location":"alteracoes/#interno_1","title":"Interno","text":"<ul> <li>Atualiza\u00e7\u00e3o de actions do CI <code>setup-python</code> e <code>checkout</code></li> <li><code>CI</code>: Ajustando o update do sqlite</li> <li><code>mkdocs-material</code> 9.6.14 -&gt; 9.6.20</li> </ul>"},{"location":"alteracoes/#410-2025-06-29","title":"4.1.0 (2025-06-29)","text":""},{"location":"alteracoes/#adicionado_1","title":"Adicionado","text":"<ul> <li>Valida\u00e7\u00f5es de querystrings com Fields do pydantic para valores num\u00e9ricos [aula 07] (#391)</li> <li>Valida\u00e7\u00f5es de querystrings com Fields do pydantic para valores de texto [aula 10] (#406)</li> <li>Novo exerc\u00edcio (06) a aula 10 para exercitar os filtros no schema dos todos (#406)</li> <li><code>Flyctl</code> nas vers\u00f5es de instala\u00e7\u00f5es em <code>C</code> (#411)</li> <li><code>refreshUrl</code> no <code>OAuth2PasswordBearer</code> (#417)</li> </ul>"},{"location":"alteracoes/#correcoes_2","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Typos na aula 07 por @0xluc (#393)</li> <li>Adicionando nota no windows para eventloop nas migra\u00e7\u00f5es async (#420)</li> </ul>"},{"location":"alteracoes/#alterado_2","title":"Alterado","text":"<ul> <li>Instru\u00e7\u00f5es do SQLAlchemy para futura v2.1 (#363)</li> </ul>"},{"location":"alteracoes/#atualizacoes_3","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>alembic</code> 1.16.1 -&gt; 1.16.2</li> <li><code>fastapi[standard]</code> 0.115.12 -&gt; 0.115.14</li> <li><code>pydantic-settings</code> 2.9.1 -&gt; 2.10.1</li> <li><code>pytest</code> 8.4.0 -&gt; 8.4.1</li> <li><code>ruff</code> 0.11.13 -&gt; 0.12.1</li> </ul>"},{"location":"alteracoes/#interno_2","title":"Interno","text":"<ul> <li>CI: Adicionando valida\u00e7\u00f5es do windows para executar os testes da \u00faltima aula</li> <li>Vers\u00e3o do <code>flyctl</code> movida para o markdown-exec</li> </ul>"},{"location":"alteracoes/#slides","title":"Slides","text":"<ul> <li>Adicionando loop de eventos para windows na aula 11. (#409)</li> <li>Removendo <code>aiosqlite</code> na aula 11 (#412)</li> </ul>"},{"location":"alteracoes/#404-2025-06-13","title":"4.0.4 (2025-06-13)","text":""},{"location":"alteracoes/#pontos-da-release_2","title":"Pontos da release","text":"<ul> <li>Atualiza\u00e7\u00f5es gerais</li> <li>Upgrades dos slides faltantes para 2025</li> <li>Slides somente em HTML</li> </ul>"},{"location":"alteracoes/#adicionado_2","title":"Adicionado","text":"<ul> <li>Slides para aula 08 (#283)</li> </ul>"},{"location":"alteracoes/#correcoes_3","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Corre\u00e7\u00e3o de typo na aula 03, por @0xluc (#388)</li> <li>Typos na aula 11, por @0xluc (#395)</li> <li>Corre\u00e7\u00e3o de typo na aula 13, por @0xluc (#396)</li> <li>Corre\u00e7\u00e3o de typo na aula 05, por @thiagonebuloni (#397)</li> <li>Corre\u00e7\u00f5es de typos na aula 06 por @renan-asantos (#401)</li> <li>Corre\u00e7\u00e3o de typo na aula 13</li> <li>Revis\u00e3o gramatical na aula <code>01</code></li> <li>Typo nos exerc\u00edcios da aula 09</li> </ul>"},{"location":"alteracoes/#alterado_3","title":"Alterado","text":"<ul> <li>Alterando as vers\u00f5es das actions para mais atuais (#410)</li> <li>Padroniza\u00e7\u00e3o nos t\u00edtulos das aulas</li> </ul>"},{"location":"alteracoes/#atualizacoes_4","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>coverage</code> 7.9.0 -&gt; 7.9.1</li> <li><code>pydantic</code> 2.11.5 -&gt; 2.11.6</li> <li><code>pytest-cov</code> 6.1.1 -&gt; 6.2.1</li> <li><code>pytest</code> 8.3.5 -&gt; 8.4.0</li> <li><code>ruff</code> 0.11.11 -&gt; 0.11.13</li> </ul>"},{"location":"alteracoes/#interno_3","title":"Interno","text":"<ul> <li>Slides servidos somente em html (#402)</li> <li><code>typos</code> 1.32.0 -&gt; 1.33.1</li> </ul>"},{"location":"alteracoes/#slides_1","title":"Slides","text":"<ul> <li>Revis\u00e3o de todos os slides para apresenta\u00e7\u00f5es de 2025 (#283)</li> <li>Corre\u00e7\u00e3o de typos na aula 05 por @thiagonebuloni (#404)</li> <li>Corre\u00e7\u00f5es nos testes async da aula <code>10</code> (#408)</li> </ul>"},{"location":"alteracoes/#403-2025-05-27","title":"4.0.3 (2025-05-27)","text":""},{"location":"alteracoes/#adicionado_3","title":"Adicionado","text":"<ul> <li>Tip para rodar os testcontaners caso esteja usando podman</li> </ul>"},{"location":"alteracoes/#correcoes_4","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Diversas corre\u00e7\u00f5es de texto na aula 01 por @renan-asantos (#356)</li> <li>Diversos typos na aula 03 por @renan-asantos (#376)</li> <li>Corre\u00e7\u00f5es de typos na aula 08 por @kylefelipe (#380)</li> <li>Remo\u00e7\u00e3o de warning na resolu\u00e7\u00e3o do exerc\u00edcio 04 da aula 10, por @kylefelipe (#382)</li> <li>Ajustando todos os endpoints para usarem Annotated na aula 07</li> </ul>"},{"location":"alteracoes/#alterado_4","title":"Alterado","text":"<ul> <li>Adicionando flag para n\u00e3o instalar as depend\u00eancias de desenvolvimento no container docker. (#369)</li> <li>Coes\u00e3o e fluidez de texto na aula 04 por @renan-asantos (#383)</li> <li>Links para aulas 01 \u00e0 06 atualizadas no cabe\u00e7alho do texto</li> <li>Playlist de fun\u00e7\u00f5es como refer\u00eancia dos pr\u00e9-requisitos</li> </ul>"},{"location":"alteracoes/#atualizacoes_5","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>alembic</code> 1.15.2 -&gt; 1.16.1</li> <li><code>freezegun</code> 1.5.1 -&gt; 1.5.2</li> <li><code>psycopg[binary]</code> 3.2.7 -&gt; 3.2.9</li> <li><code>pytest-asyncio</code> 0.26 -&gt; 1.0.0</li> <li><code>ruff</code> 0.11.8 -&gt; 0.11.11</li> <li><code>sqlalchemy</code> 2.0.40 -&gt; 2.0.41</li> </ul>"},{"location":"alteracoes/#interno_4","title":"Interno","text":"<ul> <li>Adicionando badge \"not by ai\" no footer e na p\u00e1gina principal (#357)</li> <li>CI rodando somente em altera\u00e7\u00f5es de c\u00f3digo</li> <li><code>mkdocs-material</code> 9.6.12 -&gt; 9.6.14</li> </ul>"},{"location":"alteracoes/#slides_2","title":"Slides","text":"<ul> <li>Corre\u00e7\u00e3o dos links em <code>04</code> (#283)</li> <li>Atualiza\u00e7\u00e3o da aula <code>06</code> para v4X (#283)</li> <li>Atualiza\u00e7\u00e3o da aula <code>05</code> para v4X (#283)</li> <li>Adequa\u00e7\u00e3o dos slides <code>07</code> para v4 (#283)</li> <li>Corre\u00e7\u00f5es e expans\u00e3o dos slides <code>04</code></li> <li>Remo\u00e7\u00e3o do download de fontes no HTML</li> </ul>"},{"location":"alteracoes/#402-2025-05-08","title":"4.0.2 (2025-05-08)","text":""},{"location":"alteracoes/#adicionado_4","title":"Adicionado","text":"<ul> <li>Op\u00e7\u00e3o de instala\u00e7\u00e3o do poetry shell via pipx</li> </ul>"},{"location":"alteracoes/#correcoes_5","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Corre\u00e7\u00e3o gramatical na p\u00e1gina de mudan\u00e7as, por @ViniciusSouzaRoque</li> <li>Typo ver\u00f5es -&gt; vers\u00f5es no template de vers\u00f5es</li> </ul>"},{"location":"alteracoes/#interno_5","title":"Interno","text":"<ul> <li>Redirecionamento para 404 via netlify (#355)</li> <li>Adicionando as playlists nas p\u00e1ginas de aulas por ano</li> <li>Criando macro para vers\u00e3o m\u00ednima suportada do python</li> <li>Listando mais ferramentas de apoio a p\u00e1gina inicial</li> </ul>"},{"location":"alteracoes/#slides_3","title":"Slides","text":"<ul> <li>Ajustando links e adicionando configura\u00e7\u00e3o do taskipy em <code>01</code></li> <li>Corre\u00e7\u00e3o dos links em <code>00</code></li> </ul>"},{"location":"alteracoes/#401-2025-05-06","title":"4.0.1 (2025-05-06)","text":""},{"location":"alteracoes/#pontos-principais-da-release","title":"Pontos principais da release","text":"<ul> <li>Atualiza\u00e7\u00e3o das bibliotecas</li> <li>Versionamento das p\u00e1ginas do curso via mike</li> <li>Atualiza\u00e7\u00e3o dos primeiros slides para apresenta\u00e7\u00e3o de 2025</li> </ul>"},{"location":"alteracoes/#adicionado_5","title":"Adicionado","text":"<ul> <li>Lock no apendice C</li> </ul>"},{"location":"alteracoes/#correcoes_6","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Todos os links agora contam com target blank, iniciado por ThiagoEidi (#337)</li> <li>Links absolutos na vers\u00e3o est\u00e1vel (#348)</li> <li>Corrigindo typos (secutiry -&gt; security), por @nothiel</li> </ul>"},{"location":"alteracoes/#alterado_5","title":"Alterado","text":"<ul> <li>Nota de revis\u00e3o sobre env files no docker recebeu mais insumos</li> <li>Simplifica\u00e7\u00f5es de texto na p\u00e1gina inicial</li> </ul>"},{"location":"alteracoes/#atualizacoes_6","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li>Novas respostas sobre ambiente no F.A.Q.</li> <li><code>FastAPI</code> 0.115.11 -&gt; 0.115.12</li> <li><code>alembic</code> 1.15.1 -&gt; 1.15.2</li> <li><code>poetry</code> 2.1.1 -&gt; 2.1.3</li> <li><code>psycopg[binary]</code> 3.2.6 -&gt; 3.2.7</li> <li><code>pytest-asyncio</code> 0.25 -&gt; 0.26</li> <li><code>pytest-cov</code> 6.0 -&gt; 6.1.1</li> <li><code>ruff</code> 0.10.0 -&gt; 0.11.8</li> <li><code>sqlalchemy</code> 2.0.39 -&gt; 2.0.40</li> <li><code>testcontainers</code> 4.9.2 -&gt; 4.10</li> </ul>"},{"location":"alteracoes/#interno_6","title":"Interno","text":"<ul> <li>Versionamento no material de texto (#345)</li> <li>Remo\u00e7\u00e3o do export para pdf das p\u00e1ginas (#346)</li> <li>Macros para tags de redirecionamento correto de slides de c\u00f3digos para vers\u00f5es 4+ (#347)</li> <li>[quiz] Ao clicar no label do form, agora o id \u00e9 mapeado corretamente. Por @EvandroNetoo (#352)</li> <li>Atualiza\u00e7\u00e3o typos <code>1.30.2</code> -&gt; <code>1.32.0</code></li> <li><code>mkdocs-material</code> 9.6.8 -&gt; 9.6.12</li> </ul>"},{"location":"alteracoes/#slides_4","title":"Slides","text":"<ul> <li>Revis\u00e3o <code>00</code> para 4.0.1 (#283)</li> <li>Revis\u00e3o <code>01</code> para 4.0.1 (#283)</li> <li>Revis\u00e3o <code>02</code> para 4.0.1 (#283)</li> <li>Revis\u00e3o <code>03</code> para 4.0.1 (#283)</li> </ul>"},{"location":"alteracoes/#40-2025-03-13","title":"4.0 (2025-03-13)","text":""},{"location":"alteracoes/#pontos-principais-da-release_1","title":"Pontos principais da release","text":"<ul> <li>Cria\u00e7\u00e3o de uma nova aula sobre programa\u00e7\u00e3o ass\u00edncrona (08)</li> <li>Remo\u00e7\u00e3o do pyenv em detrimento do poetry 2.0</li> <li>Material suplementar ao fim das aulas</li> <li>Novas quest\u00f5es no quiz</li> <li>Amplia\u00e7\u00e3o dos textos em diversas aulas</li> <li>Diversas novas adi\u00e7\u00f5es de coment\u00e1rios em blocos</li> <li>Datas para apresenta\u00e7\u00e3o do curso em 2025</li> </ul>"},{"location":"alteracoes/#adicionado_6","title":"Adicionado","text":"<ul> <li>Cen\u00e1rios de testes para o TCC sobre autoriza\u00e7\u00e3o e autentica\u00e7\u00e3o (#281)</li> <li>Notas sobre <code>OperationalError</code> em todas as resolu\u00e7\u00f5es de exerc\u00edcios de migra\u00e7\u00e3o (04 e 09) (#291)</li> <li>Material complementar (live de python) ao fim do texto das aulas (#296)</li> <li>Nova aula: <code>Tornando o projeto ass\u00edncrono</code> (#301)</li> <li>Uma nova quest\u00e3o foi adicionadas ao quiz da aula 06 (#304)</li> <li>Novas 4 quest\u00f5es foram adicionadas ao quiz da aula 10 (#304)</li> <li>Novas 3 quest\u00f5es foram adicionadas ao quiz da aula 12 (#304)</li> <li>Novas 3 quest\u00f5es foram adicionadas ao quiz da aula 11 (#304)</li> <li>Novas 5 quest\u00f5es foram adicionadas ao quiz da aula 07 (#304)</li> <li>Adicionando nota para psycopg no windows, testado por @raiguilhermems (#310)</li> <li>Nota sobre a execu\u00e7\u00e3o do <code>Act</code> no Windows. Contribui\u00e7\u00e3o de @marythealice (#313)</li> <li>Material suplementar (live) sobre Factory-boy (#315)</li> <li>Ap\u00eancide C com vers\u00f5es das bibliotecas e ferramentas pinadas para consultas futuras (#317)</li> <li>Gerenciamento de vers\u00f5es do python via poetry (#319)</li> <li><code>FAST</code> ao ruff na aula de refatora\u00e7\u00e3o (#323)</li> <li>Diversas adi\u00e7\u00f5es de texto e coment\u00e1rios expandidos em <code>Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI</code></li> <li>Nota sobre a execu\u00e7\u00e3o do CI localmente via <code>Act</code> no docker e podman</li> <li>Nota sobre changelogs no topo da p\u00e1gina principal</li> <li>Novo exerc\u00edcio na aula <code>Criando Rotas CRUD para Gerenciamento de Tarefas</code></li> <li>Texto sobre tarefas em background no ap\u00eandice B</li> </ul>"},{"location":"alteracoes/#correcoes_7","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Tips na aula 06 em <code>get_current_user</code> (#298)</li> <li>Erro no exercicio 09 da aula 06: <code>current_user</code> -&gt; <code>get_current_user</code>, por @matheussricardoo (#299)</li> <li>[Aula 06] Corre\u00e7\u00e3o do status code 409 -&gt; 401. Por @azmovi (#327)</li> <li>Alterando quest\u00e3o 03 do quiz na aula 04, por @ThiagoEidi</li> </ul>"},{"location":"alteracoes/#alterado_6","title":"Alterado","text":"<ul> <li>[Aula 10] - Quiz agora com <code>add_all</code> (#312)</li> <li>[aula 01] Usando o pacote no estilo <code>flat</code> na cria\u00e7\u00e3o do projeto (#318)</li> <li>Corre\u00e7\u00e3o dos status codes na aula 09 (#321)</li> <li>Corre\u00e7\u00e3o dos status codes na aula 05 (#321)</li> <li>Corre\u00e7\u00e3o dos status codes na aula 06 (#321)</li> <li>Corre\u00e7\u00e3o dos status codes na aula 07 (#321)</li> <li><code>refresh_access_token</code> agora usa Annotated (#323)</li> <li>[readme] Atualiza\u00e7\u00e3o do t\u00f3pico \"O que voc\u00ea vai aprender\" (#330)</li> <li>Alterando aula <code>Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI</code> para async N\u00e3o compat\u00edvel com vers\u00e3o anterior</li> <li>Alterando aula <code>Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL</code> para async N\u00e3o compat\u00edvel com vers\u00e3o anterior</li> <li>Alterando aula <code>Tornando o sistema de autentica\u00e7\u00e3o robusto</code> para async N\u00e3o compat\u00edvel com vers\u00e3o anterior</li> <li>URL fixa para os changelogs</li> </ul>"},{"location":"alteracoes/#removido","title":"Removido","text":"<ul> <li>[aula 10] - Quest\u00e3o do quiz sobre #noqa (#303)</li> <li>Instala\u00e7\u00e3o do python via pyenv (#319)</li> </ul>"},{"location":"alteracoes/#atualizacoes_7","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li><code>poetry</code> 2.0.1 -&gt; 2.1.1 (#307)</li> <li><code>factory-boy</code> 3.3.1 -&gt; 3.3.3</li> <li><code>psycopg[binary]</code> 3.2.5 -&gt; 3.2.6</li> <li><code>pydantic-settings</code> 2.7.1 -&gt; 2.8.0</li> <li><code>ruff</code> 0.9.4 -&gt; 0.10.0</li> <li><code>sqlalchemy</code> 2.0.37 -&gt; 2.0.39</li> <li><code>alembic</code> 1.14.1 -&gt; 1.15.1</li> <li><code>fastapi[standard]</code> 0.115.9 -&gt; 0.115.11</li> <li><code>pytest</code> = 8.3.4 -&gt; 8.3.5</li> <li><code>testcontainers</code> 4.9.1 -&gt; 4.9.2</li> </ul>"},{"location":"alteracoes/#interno_7","title":"Interno","text":"<ul> <li>Adicionando <code>markdown-exec</code> ao projeto</li> <li>Atualiza\u00e7\u00e3o do <code>mkdocs-material</code></li> <li>Reposit\u00f3rio do curso com <code>package-mode=false</code></li> </ul>"},{"location":"alteracoes/#300-2025-02-02","title":"3.0.0 (2025-02-02)","text":""},{"location":"alteracoes/#adicionado_7","title":"Adicionado","text":"<ul> <li>Nota sobre poss\u00edvel erro no exercicio exerc\u00edcio 04 da aula 04 por @taconi (#279)</li> <li>[Windows] Notas para erro de Policies na instala\u00e7\u00e3o do <code>pyenv</code> no guia de instala\u00e7\u00e3o (#284)</li> <li>Notas sobre <code>OAuth2PasswordRequestForm</code> na aula 06 por KennedyRichard (#285)</li> </ul>"},{"location":"alteracoes/#correcoes_8","title":"Corre\u00e7\u00f5es","text":"<ul> <li>Integridade conceitual em testes de dicion\u00e1rios (#286)</li> <li>Texto sobre a instala\u00e7\u00e3o do <code>poetry</code> + <code>poetry-plugins-shell</code> na aula 01</li> </ul>"},{"location":"alteracoes/#alterado_7","title":"Alterado","text":"<ul> <li>Alterando a m\u00e1quina padr\u00e3o do deploy para 512MB de mem\u00f3ria por conta das novas atualiza\u00e7\u00f5es do fly.io (#288)</li> <li>Revisitando o Exerc\u00edcio 01 da aula 02 para ficar mais expl\u00edcito.</li> </ul>"},{"location":"alteracoes/#removido_1","title":"Removido","text":"<ul> <li><code>TokenData</code> da aulas 06 e 08, para simplificar o fluxo JWT e causar menos confus\u00e3o (#290)</li> </ul>"},{"location":"alteracoes/#atualizacoes_8","title":"Atualiza\u00e7\u00f5es","text":"<ul> <li>FastAPI para vers\u00e3o 0.115.8 (#282)</li> <li>Alembic para vers\u00e3o 1.14.1</li> <li>Ruff para vers\u00e3o 0.9.4</li> <li>testecontainers para vers\u00e3o 4.9.1</li> </ul>"},{"location":"alteracoes/#interno_8","title":"Interno","text":"<ul> <li>Atualiza\u00e7\u00e3o do <code>mkdocs-material</code></li> <li>Atualiza\u00e7\u00e3o do <code>typos</code></li> </ul>"},{"location":"alteracoes/#slides_5","title":"Slides","text":"<ul> <li>Revis\u00e3o dos slides da aula 01 para conformidade com o texto</li> </ul>"},{"location":"apendices/a_instalacoes/","title":"A - Instalando as ferramentas externas","text":""},{"location":"apendices/a_instalacoes/#a-instalando-as-ferramentas-externas","title":"A - Instalando as ferramentas externas","text":"Sobre as vers\u00f5es das bibliotecas instaladas <p>A \u00faltima atualiza\u00e7\u00e3o dos pacotes deste material foi feita em: 31/10/2025 \u00e0s 11:47.</p> <p>Caso voc\u00ea esteja lendo este material em um futuro distante ou enfrente erros de instala\u00e7\u00e3o, o ap\u00eandice C cont\u00e9m todas as vers\u00f5es usadas no ambiente de forma detalhada.</p> <p>Durante as aulas s\u00edncronas, diversas d\u00favidas sobre a configura\u00e7\u00e3o e instala\u00e7\u00e3o das ferramentas fora do python foram levantadas. A ideia dessa p\u00e1gina \u00e9 te auxiliar nas instala\u00e7\u00f5es.</p> <p>S\u00e3o comandos r\u00e1pidos e simples, n\u00e3o tenho a intens\u00e3o de explicar o que essas ferramentas fazem exatamente, muitas explica\u00e7\u00f5es j\u00e1 foram escritas sobre elas na p\u00e1gina de configura\u00e7\u00e3o do projeto. A ideia \u00e9 agrupar todas as instala\u00e7\u00f5es um \u00fanico lugar.</p>"},{"location":"apendices/a_instalacoes/#pipx","title":"pipx","text":"<p>O pipx \u00e9 uma ferramenta para simplificar a instala\u00e7\u00e3o de pacotes globais.</p> <p>Para isso, voc\u00ea pode executar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pip install pipx\n</code></pre> Instala\u00e7\u00e3o do pipx <p>Embora seja poss\u00edvel instalar via pip, em algumas vers\u00f5es \u00e9 exigido o escopo de usu\u00e1rio <code>--user</code> para fazer a instala\u00e7\u00e3o global.</p> <p>A melhor forma de instalar o pipx ainda \u00e9 usando o seu sistema operacional. Voc\u00ea pode consultar a documenta\u00e7\u00e3o sobre como fazer isso. documenta\u00e7\u00e3o</p> <p>A resposta do comando dever\u00e1 ser parecida com essa:</p> <pre><code>Collecting pipx\n  Downloading pipx-1.6.0-py3-none-any.whl.metadata (18 kB)\nCollecting argcomplete&gt;=1.9.4 (from pipx)\n  Downloading argcomplete-3.3.0-py3-none-any.whl.metadata (16 kB)\nCollecting colorama&gt;=0.4.4 (from pipx)\n  Downloading colorama-0.4.6-py2.py3-none-any.whl.metadata (17 kB)\nCollecting packaging&gt;=20 (from pipx)\n  Downloading packaging-24.1-py3-none-any.whl.metadata (3.2 kB)\nCollecting platformdirs&gt;=2.1 (from pipx)\n  Downloading platformdirs-4.2.2-py3-none-any.whl.metadata (11 kB)\nCollecting userpath!=1.9,&gt;=1.6 (from pipx)\n  Downloading userpath-1.9.2-py3-none-any.whl.metadata (3.0 kB)\nCollecting click (from userpath!=1.9,&gt;=1.6-&gt;pipx)\n  Downloading click-8.1.7-py3-none-any.whl.metadata (3.0 kB)\nDownloading pipx-1.6.0-py3-none-any.whl (77 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 77.8/77.8 kB 2.2 MB/s eta 0:00:00\nDownloading argcomplete-3.3.0-py3-none-any.whl (42 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 42.6/42.6 kB ? eta 0:00:00\nDownloading colorama-0.4.6-py2.py3-none-any.whl (25 kB)\nDownloading packaging-24.1-py3-none-any.whl (53 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 54.0/54.0 kB ? eta 0:00:00\nDownloading platformdirs-4.2.2-py3-none-any.whl (18 kB)\nDownloading userpath-1.9.2-py3-none-any.whl (9.1 kB)\nDownloading click-8.1.7-py3-none-any.whl (97 kB)\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 97.9/97.9 kB 295.3 kB/s eta 0:00:00\nInstalling collected packages: platformdirs, packaging, colorama, argcomplete, click, userpath, pipx\nSuccessfully installed argcomplete-3.3.0 click-8.1.7 colorama-0.4.6 packaging-24.1 pipx-1.6.0 platformdirs-4.2.2 userpath-1.9.2\n</code></pre> <p>Para testar se o pipx foi instalado com sucesso, podemos executar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx --version\n</code></pre> <p>Se a vers\u00e3o for respondida, tudo est\u00e1 certo :)</p> <p>Uma coisa recomendada de fazer, \u00e9 adicionar os paths do pipx nas vari\u00e1veis de ambiente, para isso podemos executar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx ensurepath\n</code></pre> <p>Dessa forma, os pacotes estar\u00e3o no path. Podendo ser chamados pelo terminal sem problemas. A \u00faltima coisa que precisa ser feita \u00e9 abrir o terminal novamente, para que as novas vari\u00e1veis de ambiente sejam lidas.</p>"},{"location":"apendices/a_instalacoes/#poetry","title":"poetry","text":"<p>Com o pipx voc\u00ea pode executar:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx install poetry\n</code></pre>"},{"location":"apendices/a_instalacoes/#gh","title":"GH","text":"<p>Gh \u00e9 um CLI para o github. Facilita em diversos momentos.</p> <p>A instala\u00e7\u00e3o para diversos sistemas e variantes pode ser encontrada aqui.</p>"},{"location":"apendices/a_instalacoes/#docker","title":"Docker","text":"<p>A instala\u00e7\u00e3o do docker \u00e9 bastante diferente para sistemas operacionais diferentes e at\u00e9 mesmo em arquiteturas de processadores diferentes. Por exemplo, MacOS com intel ou arm, ou windows com WSL, ou hyper-V.</p> <p>Por esse motivo, acredito que seja interessante voc\u00ea seguir os tutoriais oficiais:</p> <ul> <li>Linux</li> <li>Windows</li> <li>MacOS</li> </ul>"},{"location":"apendices/a_instalacoes/#docker-compose","title":"Docker Compose","text":"<p>A instala\u00e7\u00e3o varia bastante de sistema para sistema, mas voc\u00ea pode olhar o guia de instala\u00e7\u00e3o oficial.</p>"},{"location":"apendices/a_instalacoes/#git","title":"Git","text":"<p>O git pode ser baixado no site oficial para windows e mac. No Linux acredito que todas as distribui\u00e7\u00f5es t\u00eam o <code>git</code> como um pacote dispon\u00edvel para instala\u00e7\u00e3o.</p>"},{"location":"apendices/b_proximos_passos/","title":"B - Pr\u00f3ximos passos","text":""},{"location":"apendices/b_proximos_passos/#b-proximos-passos","title":"B - Pr\u00f3ximos passos","text":"<p>Esse ap\u00eandice se destina a mostrar alguns exemplos de c\u00f3digo da p\u00e1gina de despedida/pr\u00f3ximos passos. Alguns exemplos simples de como fazer algumas tarefas que n\u00e3o trabalhamos durante o curso.</p>"},{"location":"apendices/b_proximos_passos/#templates","title":"Templates","text":"<p>O FastAPI conta com um recurso de carregamento de arquivos est\u00e1ticos, como CSS e JS. E tamb\u00e9m permite a renderiza\u00e7\u00e3o de templates com jinja.</p> <p>Os templates s\u00e3o formas de passar informa\u00e7\u00f5es para o HTML diretamente dos endpoints. Mas, comecemos pela estrutura. Criaremos dois diret\u00f3rios. Um para os templates e um para os arquivos est\u00e1ticos:</p> Estrutura dos arquivos<pre><code>.\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 static #(1)!\n\u2502  \u2514\u2500\u2500 style.css\n\u2514\u2500\u2500 templates #(2)!\n   \u2514\u2500\u2500 index.html\n</code></pre> <ol> <li>Diret\u00f3rio para arquivos est\u00e1ticos.</li> <li>Diret\u00f3rio para os templates do jinja</li> </ol> <p>Vamos adicionar um arquivo de estilo bastante simples, somente para ver o efeito da configura\u00e7\u00e3o:</p> static/style.css<pre><code>h1 {\n    text-align: center;\n}\n</code></pre> <p>E um arquivo html usando a tag dos templates:</p> templates/index.html<pre><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"/&gt;\n    &lt;title&gt;index.html&lt;/title&gt;\n    &lt;link href=\"static/style.css\" rel=\"stylesheet\"/&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Ol\u00e1 {{ nome }}&lt;/h1&gt; &lt;!-- (1)! --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li>Nomes dentro de <code>{{ }}</code> s\u00e3o vari\u00e1veis que ser\u00e3o preenchidas pelo contexto</li> </ol> <p>Todas as vari\u00e1veis inclu\u00eddas em <code>{{ vari\u00e1vel }}</code> s\u00e3o passadas pelo endpoint no momento de retornar o template jinja. Com isso, podemos incluir valores da aplica\u00e7\u00e3o no HTML.</p> <p>Para unir os arquivos est\u00e1ticos e os templates na aplica\u00e7\u00e3o, podemos aplicar o seguinte bloco de c\u00f3digo:</p> app.py<pre><code>from fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\n\napp = FastAPI()\n\n# Diret\u00f3rio contendo arquivos est\u00e1ticos\napp.mount('/static', StaticFiles(directory='static'), name='static')#(1)!\n\n# Diret\u00f3rio contendo os templates Jinja\ntemplates = Jinja2Templates(directory='templates')#(2)!\n\n\n@app.get('/{nome}', response_class=HTMLResponse)\ndef home(request: Request, nome: str):#(3)!\n    return templates.TemplateResponse(#(4)!\n        request=request, name='index.html', context={'nome': nome}\n    )\n</code></pre> <ol> <li>O m\u00e9todo <code>.mount</code> cria um endpoint <code>/static</code> para retornar os arquivos no diret\u00f3rio <code>static</code>.</li> <li><code>Jinja2Templates</code> mapeia um diret\u00f3rio em nossa aplica\u00e7\u00e3o onde armazenamos templates jinja para serem lidos pela aplica\u00e7\u00e3o.</li> <li>O objeto <code>Request</code> do FastAPI \u00e9 o objeto que representa corpo da requisi\u00e7\u00e3o e seu escopo.</li> <li>O m\u00e9todo <code>TemplateResponse</code> se encarrega de dizer qual o nome (<code>name</code>) do template que ser\u00e1 renderizado no html e <code>context</code> \u00e9 um dicion\u00e1rio que passa as vari\u00e1veis do endpoint para o arquivo html.</li> </ol> <p>Para que os templates sejam renderizados pelo FastAPI precisamos instalar o jinja:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add jinja2\n</code></pre> <p>E executar nosso projeto com:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre> <p>Desta forma, ao acessar o endpoint pela API, temos a jun\u00e7\u00e3o de templates e est\u00e1ticos acontecendo:</p> <p></p>"},{"location":"apendices/b_proximos_passos/#tarefas-em-segundo-plano-background","title":"Tarefas em segundo plano (Background)","text":"<p>Em algumas aplica\u00e7\u00f5es, \u00e9 preciso realizar tarefas que possam ser feitas sem atrapalhar o funcionamento principal do programa. \u00c9 \u00fatil para enviar e-mails, processar arquivos ou fazer c\u00e1lculos demorados, mas sem impactar a experi\u00eancia do usu\u00e1rio, que pode continuar interagindo com a aplica\u00e7\u00e3o.</p> <p>O FastAPI oferece suporte nativo para a execu\u00e7\u00e3o de tarefas em segundo plano usando o objeto <code>BackgroundTasks</code>. Esse objeto permite que voc\u00ea adicione fun\u00e7\u00f5es que ser\u00e3o executadas ap\u00f3s a resposta ser enviada ao cliente. Dessa forma, o cliente n\u00e3o precisa esperar que a tarefa seja conclu\u00edda para continuar suas intera\u00e7\u00f5es.</p>"},{"location":"apendices/b_proximos_passos/#exemplo-de-implementacao","title":"Exemplo de implementa\u00e7\u00e3o","text":"<p>No exemplo a seguir, criamos uma tarefa simples que dorme por um tempo especificado e retorna uma resposta indicando que a requisi\u00e7\u00e3o foi recebida e est\u00e1 sendo processada.</p> app.py<pre><code>from time import sleep\n\nfrom fastapi import BackgroundTasks, FastAPI\n\n\napp = FastAPI()\n\n\ndef tarefa_em_segundo_plano(tempo=0):#(1)!\n    sleep(tempo)  # Simula um processo demorado\n\n\n@app.get('/segundo-plano/{tempo}')\ndef segundo_plano(tempo: int, task: BackgroundTasks):#(2)!\n    task.add_task(tarefa_em_segundo_plano, tempo)#(3)!\n    return {'message': 'Sua requisi\u00e7\u00e3o est\u00e1 sendo processada!'}\n</code></pre> <ol> <li> <p>Fun\u00e7\u00e3o de Tarefa: A fun\u00e7\u00e3o <code>tarefa_em_segundo_plano</code> simula uma tarefa demorada, utilizando a fun\u00e7\u00e3o <code>sleep</code> para interromper a execu\u00e7\u00e3o por um tempo determinado pelo par\u00e2metro <code>tempo</code>. Essa fun\u00e7\u00e3o pode ser qualquer fun\u00e7\u00e3o Python que voc\u00ea deseje rodar em segundo plano.</p> </li> <li> <p>Recebendo BackgroundTasks: O tipo <code>BackgroundTasks</code> \u00e9 injetado automaticamente no endpoint, e ele permite que voc\u00ea adicione tarefas ao loop de eventos do FastAPI. Ao receber esse tipo, o endpoint poder\u00e1 adicionar tarefas para execu\u00e7\u00e3o em segundo plano, sem afetar a resposta imediata ao cliente.</p> </li> <li> <p>Adicionando a tarefa ao background: A fun\u00e7\u00e3o <code>.add_task()</code> do <code>BackgroundTasks</code> \u00e9 usada para adicionar a fun\u00e7\u00e3o <code>tarefa_em_segundo_plano</code> ao evento em segundo plano, passando o par\u00e2metro necess\u00e1rio (<code>tempo</code>, no caso). Assim, quando o cliente acessar o endpoint, a tarefa ser\u00e1 iniciada em segundo plano enquanto a resposta j\u00e1 \u00e9 enviada para ele.</p> </li> </ol>"},{"location":"apendices/b_proximos_passos/#como-funciona-a-execucao","title":"Como funciona a execu\u00e7\u00e3o","text":"<p>Quando um cliente acessa o endpoint <code>/segundo-plano/{tempo}</code>, o FastAPI envia imediatamente a resposta <code>{'message': 'Sua requisi\u00e7\u00e3o est\u00e1 sendo processada!'}</code>. A tarefa, que simula um processo demorado, \u00e9 executada em segundo plano, sem que o cliente tenha que aguardar sua conclus\u00e3o.</p> <p>Isso permite que voc\u00ea realize opera\u00e7\u00f5es demoradas sem prejudicar a experi\u00eancia do usu\u00e1rio, que pode seguir usando a aplica\u00e7\u00e3o enquanto a tarefa est\u00e1 em andamento.</p>"},{"location":"apendices/b_proximos_passos/#eventos-de-ciclo-de-vida","title":"Eventos de ciclo de vida","text":"<p>Os eventos de ciclo de vida s\u00e3o formas de iniciar ou testar alguma condi\u00e7\u00e3o antes de a aplica\u00e7\u00e3o ser de fato inicializada. Voc\u00ea pode criar valida\u00e7\u00f5es, como saber se outra aplica\u00e7\u00e3o est\u00e1 de p\u00e9, configurar coisas antes de a aplica\u00e7\u00e3o ser iniciada, como iniciar o banco de dados, etc.</p> <p>Da mesma forma, alguns casos para antes de a aplica\u00e7\u00e3o ser finalizada tamb\u00e9m podem ser criadas. Como garantir que todas as tarefas em segundo plano estejam de fato finalizadas antes da aplica\u00e7\u00e3o parar de rodar.</p> app.py<pre><code>from logging import getLogger\nfrom time import sleep\n\nfrom fastapi import FastAPI\n\n\nlogger = getLogger('uvicorn')\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    logger.info('Iniciando a aplica\u00e7\u00e3o')#(1)!\n    yield  # Executa a aplica\u00e7\u00e3o\n    logger.info('Finalizando a aplica\u00e7\u00e3o')#(2)!\n\n\napp = FastAPI(lifespan=lifespan)#(3)!\n</code></pre> <ol> <li>Log que ser\u00e1 emitido antes da aplica\u00e7\u00e3o ser iniciada</li> <li>Log que ser\u00e1 emitido antes da aplica\u00e7\u00e3o ser finalizada</li> <li>O par\u00e2metro <code>lifespan</code> recebe uma fun\u00e7\u00e3o ass\u00edncrona com <code>yield</code> para uma condi\u00e7\u00e3o de parada. Assim como uma fixture do pytest.</li> </ol> <p>Podemos observar que os logs foram adicionados ao uvicorn antes e depois da execu\u00e7\u00e3o da aplica\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn app:app\nINFO:     Started server process [254037]\nINFO:     Waiting for application startup.\nINFO:     Iniciando a aplica\u00e7\u00e3o\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\n# Apertando Ctrl + C\n^C\nINFO:     Shutting down\nINFO:     Waiting for application shutdown.\nINFO:     Finalizando a aplica\u00e7\u00e3o\nINFO:     Application shutdown complete.\nINFO:     Finished server process [254037]\n</code></pre>"},{"location":"apendices/c_versoes_usadas/","title":"C - Vers\u00f5es das bibliotecas","text":""},{"location":"apendices/c_versoes_usadas/#c-versoes-das-bibliotecas","title":"C - Vers\u00f5es das bibliotecas","text":"Sobre as vers\u00f5es das bibliotecas instaladas <p>A \u00faltima atualiza\u00e7\u00e3o dos pacotes deste material foi feita em: 31/10/2025 \u00e0s 11:47.</p>"},{"location":"apendices/c_versoes_usadas/#bibliotecas-do-projeto","title":"Bibliotecas do projeto","text":"<pre><code>dependencies = [\n    \"alembic (&gt;=1.17.1,&lt;2.0.0)\",\n    \"fastapi[standard] (&gt;=0.120.3,&lt;0.121.0)\",\n    \"pwdlib[argon2] (&gt;=0.3.0,&lt;0.4.0)\",\n    \"pydantic-settings (&gt;=2.11.0,&lt;3.0.0)\",\n    \"pyjwt (&gt;=2.10.1,&lt;3.0.0)\",\n    \"aiosqlite (&gt;=0.21.0,&lt;0.22.0)\",\n    \"sqlalchemy[asyncio] (&gt;=2.0.44,&lt;3.0.0)\",\n    \"psycopg[binary] (&gt;=3.2.12,&lt;4.0.0)\",\n    \"tzdata (&gt;=2025.2,&lt;2026.0)\"\n]\n</code></pre>"},{"location":"apendices/c_versoes_usadas/#bibliotecas-de-desenvolvimento","title":"Bibliotecas de desenvolvimento","text":"<pre><code>dev = [\n    \"pytest (&gt;=8.4.2,&lt;9.0.0)\",\n    \"pytest-cov (&gt;=7.0.0,&lt;8.0.0)\",\n    \"taskipy (&gt;=1.14.1,&lt;2.0.0)\",\n    \"ruff (&gt;=0.14.3,&lt;0.15.0)\",\n    \"pytest-asyncio (&gt;=1.2.0,&lt;2.0.0)\",\n    \"factory-boy (&gt;=3.3.3,&lt;4.0.0)\",\n    \"freezegun (&gt;=1.5.5,&lt;2.0.0)\",\n    \"testcontainers (&gt;=4.13.2,&lt;5.0.0)\"\n]\n</code></pre>"},{"location":"apendices/c_versoes_usadas/#lock-de-todo-o-ambiente","title":"Lock de todo o ambiente","text":"<p>O lock do projeto final pode ser encontrado aqui!</p>"},{"location":"apendices/c_versoes_usadas/#ferramentas-instaladas-do-ambiente","title":"Ferramentas instaladas do ambiente","text":"<p>Aqui est\u00e3o listadas as vers\u00f5es que foram usadas das ferramentas instaladas no meu sistema de forma determin\u00edstica:</p> <ul> <li>Poetry: Poetry (version 2.2.1)</li> <li>Pipx: 1.8.0</li> <li>Docker: Docker version 28.5.1, build e180ab8ab8</li> <li>Docker-compose: Docker Compose version 2.40.3</li> <li>Flyctl: flyctl v0.3.205 linux/amd64 Commit: eefac469b8b39c1877aae901e61fee701a93a645 BuildDate: 2025-10-29T08:42:41Z</li> </ul>"},{"location":"aulas/2024/","title":"Aulas s\u00edncronas 2024","text":""},{"location":"aulas/2024/#aulas-sincronas-2024","title":"Aulas s\u00edncronas 2024","text":"<p>Faremos 15 encontros para as aulas s\u00edncronas em formato de live no meu canal do YouTube entre as datas de 11/06 e 30/07.</p>"},{"location":"aulas/2024/#como-vai-funcionar","title":"Como vai funcionar?","text":"<p>Nossos encontros acontecer\u00e3o as ter\u00e7as e quintas com dura\u00e7\u00e3o de 1h30m. Entre \u00e0s 20:00h e 21:30. Com chat aberto para tirar d\u00favidas enquanto a aula acontece. O material base \u00e9 o que est\u00e1 disposto neste site.</p>"},{"location":"aulas/2024/#agenda","title":"Agenda","text":"N Aula Data Link 00 Abertura e apresenta\u00e7\u00e3o do curso 11/06 Aula 00 01 Configurando o Ambiente de Desenvolvimento 13/06 Aula 01 02 Introdu\u00e7\u00e3o ao desenvolvimento WEB 18/06 Aula 02 03 Estruturando o Projeto e Criando Rotas CRUD 20/06 Aula 03 04 Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic 25/06 Aula 04 05 Integrando Banco de Dados a API 27/06 Aula 05 06 Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT 02/07 Aula 06 07 Refatorando a Estrutura do Projeto 04/07 Aula 07 S Aula reservada para tirar d\u00favidas 09/07 Aula d\u00favidas 08 Tornando o sistema de autentica\u00e7\u00e3o robusto 11/07 Aula 08 09 Criando Rotas CRUD para Gerenciamento de Tarefas 16/07 Aula 09 10 Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL 18/07 Aula 10 11 Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI) 23/07 Aula 11 12 Fazendo deploy no Fly.io 25/07 Aula 12 13 Despedida e pr\u00f3ximos passos 30/07 Aula 13 <p>Agenda com as datas:</p> <ul> <li>iCal</li> <li>Google Agenda</li> </ul> <p>Caso queira conversar e tirar d\u00favidas com as pessoas que tamb\u00e9m est\u00e3o/ir\u00e3o fazer o curso, temos um grupo no Telegram.</p>"},{"location":"aulas/2024/#o-que-sera-necessario-para-acompanhar","title":"O que ser\u00e1 necess\u00e1rio para acompanhar?","text":"<ol> <li>Um link com internet para participar das lives</li> <li>Um computador para acompanhar as aulas</li> <li>Um sistema operacional que seja capaz de rodar o Docker (algumas vers\u00f5es do Windows tem problemas com isso)</li> <li>Uma conta no GitHub para hospedar os c\u00f3digos e exerc\u00edcios</li> <li>Uma conta no Fly.io para fazer o deploy de sua aplica\u00e7\u00e3o</li> </ol>"},{"location":"aulas/2024/#playlist-das-aulas-ministradas","title":"Playlist das aulas ministradas","text":""},{"location":"aulas/2025/","title":"Aulas s\u00edncronas 2025","text":""},{"location":"aulas/2025/#aulas-sincronas-2025","title":"Aulas s\u00edncronas 2025","text":"<p>Faremos 15 encontros para as aulas s\u00edncronas em formato de live no meu canal do YouTube entre as datas de 06/05 e 26/06.</p>"},{"location":"aulas/2025/#como-vai-funcionar","title":"Como vai funcionar?","text":"<p>Nossos encontros acontecer\u00e3o as ter\u00e7as e quintas com dura\u00e7\u00e3o de 2h00m. Entre \u00e0s 20:00h e 22:00. Com chat aberto para tirar d\u00favidas enquanto a aula acontece. O material base \u00e9 o que est\u00e1 disposto neste site.</p>"},{"location":"aulas/2025/#agenda","title":"Agenda","text":"N Aula Data Link 00 Abertura e apresenta\u00e7\u00e3o do curso 06/05 Aula 00 01 Configurando o ambiente de desenvolvimento 08/05 Aula 01 02 Introdu\u00e7\u00e3o ao desenvolvimento WEB 13/05 Aula 02 03 Estruturando seu projeto e criando rotas CRUD 15/05 Aula 03 04 Configurando o banco de dados e gerenciando migra\u00e7\u00f5es com Alembic 20/05 Aula 04 05 Integrando banco de dados \u00e0 API 22/05 Aula 05 06 Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o 27/05 Aula 06 07 Refatorando a estrutura do projeto 29/05 Aula 07 08 Tornando o projeto ass\u00edncrono 05/06 Aula 08 09 Tornando o sistema de autentica\u00e7\u00e3o robusto 10/06 Aula 09 10 Criando rotas CRUD para gerenciamento de tarefas 12/06 Aula 10 11 Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL 17/06 Aula 11 12 Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI) 19/06 Aula 12 13 Fazendo deploy no Fly.io 24/06 Aula 13 14 Despedida e pr\u00f3ximos passos 26/06 Aula 13 <p>Agenda com as datas:</p> <ul> <li>iCal</li> <li>Google Agenda</li> </ul> <p>Caso queira conversar e tirar d\u00favidas com as pessoas que tamb\u00e9m est\u00e3o/ir\u00e3o fazer o curso, temos um grupo no Telegram.</p>"},{"location":"aulas/2025/#o-que-sera-necessario-para-acompanhar","title":"O que ser\u00e1 necess\u00e1rio para acompanhar?","text":"<ol> <li>Um link com internet para participar das lives</li> <li>Um computador para acompanhar as aulas</li> <li>O interpretador do python em uma vers\u00e3o oficialmente suportada, atualmente 3.10+</li> <li>Um sistema operacional que seja capaz de rodar o Docker (algumas vers\u00f5es do Windows tem problemas com isso)</li> <li>Uma conta no GitHub para hospedar os c\u00f3digos e exerc\u00edcios</li> <li>Uma conta no Fly.io para fazer o deploy de sua aplica\u00e7\u00e3o</li> </ol>"},{"location":"aulas/2025/#playlist-das-aulas-ministradas","title":"Playlist das aulas ministradas","text":""},{"location":"exercicios_resolvidos/aula_01/","title":"Exerc\u00edcios da aula 01","text":""},{"location":"exercicios_resolvidos/aula_01/#exercicios-da-aula-01","title":"Exerc\u00edcios da aula 01","text":""},{"location":"exercicios_resolvidos/aula_01/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Crie um reposit\u00f3rio para acompanhar o curso e suba em alguma plataforma, como Github, gitlab, codeberg, etc. E compartilhe o link no reposit\u00f3rio do curso para podermos aprender juntos.</p>"},{"location":"exercicios_resolvidos/aula_02/","title":"Exerc\u00edcios da aula 02","text":""},{"location":"exercicios_resolvidos/aula_02/#exercicios-da-aula-02","title":"Exerc\u00edcios da aula 02","text":""},{"location":"exercicios_resolvidos/aula_02/#exercicio-01","title":"Exerc\u00edcio 01","text":"<ol> <li>Crie um novo endpoint em <code>fast_zero/app.py</code> que retorne \"ol\u00e1 mundo\" usando HTML e escreva seu teste em <code>tests/test_app.py</code>.</li> </ol> <p>Dica: para capturar a resposta do HTML do cliente de testes, voc\u00ea pode usar <code>response.text</code></p>"},{"location":"exercicios_resolvidos/aula_02/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Para cria\u00e7\u00e3o do endpoint retornando HTML devemos alterar a classe de resposta padr\u00e3o do FastAPI para <code>HTMLResponse</code>:</p> Implementa\u00e7\u00e3o do endpoint<pre><code>from fastapi.responses import HTMLResponse\n\n# ...\n\n@app.get('/exercicio-html', response_class=HTMLResponse)\ndef exercicio_aula_02():\n    return \"\"\"\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;Nosso ol\u00e1 mundo!&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt; Ol\u00e1 Mundo &lt;/h1&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\"\"\"\n</code></pre> <p>O teste que faz a valida\u00e7\u00e3o do valor retornado pelo endpoint n\u00e3o precisa ser muito robusto. A ideia principal do exerc\u00edcio \u00e9 somente validar se estamos retornando o \"Ol\u00e1 Mundo\" em formato de HTML:</p> Implementa\u00e7\u00e3o do teste<pre><code>def test_exercicio_ola_mundo_em_html():\n    client = TestClient(app)\n\n    response = client.get('/exercicio-html')\n\n    assert response.status_code == HTTPStatus.OK\n    assert '&lt;h1&gt; Ol\u00e1 Mundo &lt;/h1&gt;' in response.text\n</code></pre> <p>O <code>response.text</code> \u00e9 um m\u00e9todo do cliente de testes do FastAPI que converte os bytes de resposta em string.</p>"},{"location":"exercicios_resolvidos/aula_03/","title":"Exerc\u00edcios da aula 03","text":""},{"location":"exercicios_resolvidos/aula_03/#exercicios-da-aula-03","title":"Exerc\u00edcios da aula 03","text":""},{"location":"exercicios_resolvidos/aula_03/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Escreva um teste para o erro de <code>404</code> (NOT FOUND) para o endpoint de PUT.</p>"},{"location":"exercicios_resolvidos/aula_03/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>A ideia de um teste de <code>404</code> para o PUT \u00e9 tentar fazer a altera\u00e7\u00e3o de um usu\u00e1rio que n\u00e3o existe no banco de dados.</p> Teste de 404<pre><code>def test_update_user_should_return_not_found__exercicio(client):\n    response = client.put(\n        '/users/666', #(1)!\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.NOT_FOUND #(2)!\n    assert response.json() == {'detail': 'User not found'} #(3)!\n</code></pre> <ol> <li>O user com id <code>666</code> n\u00e3o existe no nosso sistema.</li> <li>Como o user n\u00e3o existe, o status code retornado pela fun\u00e7\u00e3o ser\u00e1 <code>404</code></li> <li>Por entrar no bloco de valida\u00e7\u00e3o do <code>if</code> o <code>HTTPException</code> foi preenchido com <code>detail='User not found'</code></li> </ol>"},{"location":"exercicios_resolvidos/aula_03/#exercicio-02","title":"Exerc\u00edcio 02","text":"<p>Escreva um teste para o erro de <code>404</code> (NOT FOUND) para o endpoint de DELETE</p>"},{"location":"exercicios_resolvidos/aula_03/#solucao_1","title":"Solu\u00e7\u00e3o","text":"<p>A ideia de um teste de 404 para o DELETE \u00e9 tentar fazer a altera\u00e7\u00e3o de um usu\u00e1rio que n\u00e3o existe no banco de dados.</p> Teste de 404<pre><code>def test_delete_user_should_return_not_found__exercicio(client):\n    response = client.delete('/users/666') #(1)!\n\n    assert response.status_code == HTTPStatus.NOT_FOUND #(2)!\n    assert response.json() == {'detail': 'User not found'} #(3)!\n</code></pre> <ol> <li>O user com id <code>666</code> n\u00e3o existe no nosso sistema.</li> <li>Como o user n\u00e3o existe, o status code retornado pela fun\u00e7\u00e3o ser\u00e1 <code>404</code></li> <li>Por entrar no bloco de valida\u00e7\u00e3o do <code>if</code> o <code>HTTPException</code> foi preenchido com <code>detail='User not found'</code></li> </ol>"},{"location":"exercicios_resolvidos/aula_03/#exercicio-03","title":"Exerc\u00edcio 03","text":"<p>Crie um endpoint de GET para pegar um \u00fanico recurso como <code>users/{id}</code> e fazer seus testes para <code>200</code> e <code>404</code>.</p>"},{"location":"exercicios_resolvidos/aula_03/#solucao_2","title":"Solu\u00e7\u00e3o","text":"<p>A implementa\u00e7\u00e3o do endpoint \u00e9 bastante parecida com as que fizemos at\u00e9 agora. Precisamos validar se existe um <code>id</code> compat\u00edvel no nosso banco de dados falso, nos baseando pela posi\u00e7\u00e3o do elemento na lista.</p> <pre><code>@app.get('/users/{user_id}', response_model=UserPublic)\ndef read_user__exercicio(user_id: int):\n    if user_id &gt; len(database) or user_id &lt; 1:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    return database[user_id - 1]\n</code></pre> <p>Um dos testes \u00e9 sobre o retorno <code>404</code>, que \u00e9 retornado um user que n\u00e3o existe na base de dados e outro \u00e9 o comportamento padr\u00e3o para quando o user \u00e9 retornado com sucesso:</p> <pre><code>def test_get_user_should_return_not_found__exercicio(client):\n    response = client.get('/users/666')\n\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'User not found'}\n\n\ndef test_get_user___exercicio(client):\n    response = client.get('/users/1')\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n</code></pre>"},{"location":"exercicios_resolvidos/aula_04/","title":"Exerc\u00edcios da aula 04","text":""},{"location":"exercicios_resolvidos/aula_04/#exercicios-da-aula-04","title":"Exerc\u00edcios da aula 04","text":""},{"location":"exercicios_resolvidos/aula_04/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Fazer uma altera\u00e7\u00e3o no modelo (tabela <code>User</code>) e adicionar um campo chamado <code>updated_at</code>:</p> <ul> <li>Esse campo deve ser mapeado para o tipo <code>datetime</code></li> <li>Esse campo n\u00e3o deve ser inicializado por padr\u00e3o <code>init=False</code></li> <li>O valor padr\u00e3o deve ser <code>now</code></li> <li>Toda vez que a tabela for atualizada esse campo deve ser atualizado:   <pre><code>mapped_column(onupdate=func.now())\n</code></pre></li> </ul>"},{"location":"exercicios_resolvidos/aula_04/#solucao","title":"Solu\u00e7\u00e3o","text":"<pre><code>@mapped_as_dataclass(table_registry)\nclass User:\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(init=False, primary_key=True)\n    username: Mapped[str] = mapped_column(unique=True)\n    password: Mapped[str]\n    email: Mapped[str] = mapped_column(unique=True)\n    created_at: Mapped[datetime] = mapped_column(\n        init=False, server_default=func.now()\n    )\n    updated_at: Mapped[datetime] = mapped_column(  # Exerc\u00edcio\n        init=False, server_default=func.now(), onupdate=func.now()\n    )\n</code></pre>"},{"location":"exercicios_resolvidos/aula_04/#exercicio-02","title":"Exerc\u00edcio 02","text":"<p>Altere o evento de testes (<code>mock_db_time</code>) para ser contemplado no mock o campo <code>updated_at</code> na valida\u00e7\u00e3o do teste.</p>"},{"location":"exercicios_resolvidos/aula_04/#solucao_1","title":"Solu\u00e7\u00e3o","text":"<p>A ideia \u00e9 adicionar mais um campo na verifica\u00e7\u00e3o do modelo, para que o update tamb\u00e9m esteja um hor\u00e1rio determin\u00edstico:</p> <pre><code>@contextmanager\ndef _mock_db_time(*, model, time=datetime(2024, 1, 1)):\n\n    def fake_time_handler(mapper, connection, target):\n        if hasattr(target, 'created_at'):\n            target.created_at = time\n        if hasattr(target, 'updated_at'):\n            target.updated_at = time\n\n    event.listen(model, 'before_insert', fake_time_handler)\n\n    yield time\n\n    event.remove(model, 'before_insert', fake_time_handler)\n</code></pre> <p>Com a altera\u00e7\u00e3o do modelo, o teste tamb\u00e9m passar\u00e1 a falhar. Isso pode ser modificado adicionando o campo <code>updated_at</code> no dicion\u00e1rio de valida\u00e7\u00e3o:</p> <pre><code>def test_create_user(session, mock_db_time):\n    with mock_db_time(model=User) as time:\n        new_user = User(\n            username='alice', password='secret', email='teste@test'\n        )\n        session.add(new_user)\n        session.commit()\n\n        user = session.scalar(select(User).where(User.username == 'alice'))\n\n    assert asdict(user) == {\n        'id': 1,\n        'username': 'alice',\n        'password': 'secret',\n        'email': 'teste@test',\n        'created_at': time,\n        'updated_at': time,\n    }\n</code></pre>"},{"location":"exercicios_resolvidos/aula_04/#exercicio-03","title":"Exerc\u00edcio 03","text":"<p>Criar uma nova migra\u00e7\u00e3o autogerada com alembic.</p>"},{"location":"exercicios_resolvidos/aula_04/#solucao_2","title":"Solu\u00e7\u00e3o","text":"<p>Comando explicado na aula para gerar uma migra\u00e7\u00e3o autom\u00e1tica:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"exercicio 02 aula 04\"\n</code></pre> <p>O Comando deve retornar algo parecido com isso: </p>Resultado do comando<pre><code>INFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.autogenerate.compare] Detected added column 'users.updated_at'\n  Generating /home/dunossauro/git/fastapi-do-\n  zero/codigo_das_aulas/04/migrations/versions/bb77f9679811_exercicio_02_aula_04.py ...  done\n</code></pre><p></p> <p>O arquivo de migra\u00e7\u00f5es deve se parecer com esse:</p> /migrations/versions/bb77f9679811_exercicio_02_aula_04.py<pre><code>\"\"\"exercicio 02 aula 04\n\nRevision ID: bb77f9679811\nRevises: 74f39286e2f6\nCreate Date: ...\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'bb77f9679811'\ndown_revision: Union[str, None] = '74f39286e2f6'\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column('users', sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False)) #(1)!\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_column('users', 'updated_at') #(2)!\n    # ### end Alembic commands ###\n</code></pre> <ol> <li>Adiciona a coluna <code>updated_at</code> na tabela <code>users</code></li> <li>Remove a coluna <code>updated_at</code> na tabela <code>users</code></li> </ol>"},{"location":"exercicios_resolvidos/aula_04/#exercicio-04","title":"Exerc\u00edcio 04","text":"<p>Aplicar essa migra\u00e7\u00e3o ao banco de dados</p>"},{"location":"exercicios_resolvidos/aula_04/#solucao_3","title":"Solu\u00e7\u00e3o","text":"<p>Para aplicar a ultima migra\u00e7\u00e3o devemos nos mover at\u00e9 a head:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade 74f39286e2f6 -&gt; bb77f9679811, exercicio 02 aula 04\n</code></pre> sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) <p>Caso voc\u00ea receba esse erro ao aplicar a migra\u00e7\u00e3o, recomendo que veja a Live de Python #211 sobre <code>migra\u00e7\u00f5es e bancos de dados evolutivos</code> (recomendada no texto da aula 04 - \"Caso nunca tenha trabalhado com Migra\u00e7\u00f5es\").</p> <p>No minuto 1:28:33 o motivo e a solu\u00e7\u00e3o desse erro s\u00e3o abordados em mais detalhes.</p> <p>Mas, em resumo, isso \u00e9 um problema causado pelo modo como o python se comunica com o sqlite, fazendo com que cada altera\u00e7\u00e3o no banco seja aplicado linha, a linha. Para fazer todas as modifica\u00e7\u00f5es de uma vez, usamos as <code>opera\u00e7\u00f5es em batch</code>. A ideia \u00e9 abrir uma \u00fanica conex\u00e3o com o banco de dados e executar determinadas opera\u00e7\u00f5es para todas as linhas antes da conex\u00e3o ser fechada.</p> <p>Para isso ser\u00e1 preciso alterar o arquivo de migra\u00e7\u00f5es manualmente. O arquivo deve se parecer com esse:</p> /migrations/versions/bb77f9679811_exercicio_02_aula_04.py<pre><code># ...\ndef upgrade():\n    with op.batch_alter_table('users', schema=None) as batch_op:  #(1)!\n        batch_op.add_column(   #(2)!\n            sa.Column(\n                'updated_at',\n                sa.DateTime(),\n                server_default=sa.text('(CURRENT_TIMESTAMP)'),\n                nullable=False,\n            )\n        )\n\n\ndef downgrade():\n    with op.batch_alter_table('users', schema=None) as batch_op:  #(1)!\n        batch_op.drop_column('updated_at')  #(3)!\n</code></pre> <ol> <li>Entrando no contexto das opera\u00e7\u00f5es em lote</li> <li>Adiciona a coluna <code>updated_at</code> na tabela <code>users</code> com o <code>batch_op</code></li> <li>Remove a coluna <code>updated_at</code> da tabela <code>users</code> com o <code>batch_op</code></li> </ol> <p>Checando o resultado no schema do banco de dados:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db \nSQLite version 3.46.1 2024-08-13 09:16:08\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\n        version_num VARCHAR(32) NOT NULL, \n        CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nCREATE TABLE users (\n        id INTEGER NOT NULL, \n        username VARCHAR NOT NULL, \n        password VARCHAR NOT NULL, \n        email VARCHAR NOT NULL, \n        created_at DATETIME DEFAULT (CURRENT_TIMESTAMP) NOT NULL,\n        updated_at DATETIME DEFAULT (CURRENT_TIMESTAMP) NOT NULL, \n        PRIMARY KEY (id), \n        UNIQUE (email), \n        UNIQUE (username)\n);\n</code></pre> <p>Podemos ver que o campo <code>updated_at</code> foi criado com o tipo <code>DATETIME</code> e com o valor padr\u00e3o para <code>CURRENT_TIMESTAMP</code>, assim como no <code>created_at</code>.</p>"},{"location":"exercicios_resolvidos/aula_05/","title":"Exerc\u00edcios da aula 05","text":""},{"location":"exercicios_resolvidos/aula_05/#exercicios-da-aula-05","title":"Exerc\u00edcios da aula 05","text":""},{"location":"exercicios_resolvidos/aula_05/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Escrever um teste para o endpoint de POST (create_user) que contemple o cen\u00e1rio onde o username j\u00e1 foi registrado. Validando o erro <code>409</code>.</p>"},{"location":"exercicios_resolvidos/aula_05/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Para testar esse cen\u00e1rio, precisamos de um username que j\u00e1 esteja registrado na base de dados. Para isso, podemos usar a fixture de <code>user</code> que criamos. Ela \u00e9 uma garantia que o valor j\u00e1 est\u00e1 inserido no banco de dados:</p> /tests/test_app.py<pre><code>def test_create_user_should_return_409_username_exists__exercicio(client, user):\n    response = client.post(\n        '/users/',\n        json={\n            'username': user.username,\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CONFLICT\n    assert response.json() == {'detail': 'Username already exists'}\n</code></pre>"},{"location":"exercicios_resolvidos/aula_05/#exercicio-02","title":"Exerc\u00edcio 02","text":"<p>Escrever um teste para o endpoint de POST (create_user) que contemple o cen\u00e1rio onde o e-mail j\u00e1 foi registrado. Validando o erro <code>409</code>.</p>"},{"location":"exercicios_resolvidos/aula_05/#solucao_1","title":"Solu\u00e7\u00e3o","text":"<p>Para testar esse cen\u00e1rio, precisamos de um e-mail que j\u00e1 esteja registrado na base de dados. Para isso, podemos usar a fixture de <code>user</code> que criamos. Ela \u00e9 uma garantia que o valor j\u00e1 est\u00e1 inserido no banco de dados:</p> /tests/test_app.py<pre><code>def test_create_user_should_return_409_email_exists__exercicio(client, user):\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': user.email,\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == HTTPStatus.CONFLICT\n    assert response.json() == {'detail': 'Email already exists'}\n</code></pre>"},{"location":"exercicios_resolvidos/aula_05/#exercicio-03","title":"Exerc\u00edcio 03","text":"<p>Atualizar os testes criados nos exerc\u00edcios 1 e 2 da aula 03 para suportarem o banco de dados.</p>"},{"location":"exercicios_resolvidos/aula_05/#solucao_2","title":"Solu\u00e7\u00e3o","text":"<p>O objetivo desse exerc\u00edcio n\u00e3o necessariamente uma atualiza\u00e7\u00e3o dos testes, mas o caso de uma execu\u00e7\u00e3o para validar se os testes, como foram feitos ainda funcionariam nessa nova estrutura.</p> <p>Os meus testes da aula 03:</p> <pre><code>def test_delete_user_should_return_not_found__exercicio(client):\n    response = client.delete('/users/666')\n\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'User not found'}\n\n\ndef test_update_user_should_return_not_found__exercicio(client):\n    response = client.put(\n        '/users/666',\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'User not found'}\n</code></pre> <p>Ao executar eles continuam passando.</p>"},{"location":"exercicios_resolvidos/aula_05/#exercicio-04","title":"Exerc\u00edcio 04","text":"<p>Implementar o banco de dados para o endpoint de listagem por id, criado no exerc\u00edcio 3 da aula 03.</p>"},{"location":"exercicios_resolvidos/aula_05/#solucao_3","title":"Solu\u00e7\u00e3o","text":"<p>Esse exerc\u00edcio basicamente consiste em duas partes. A primeira \u00e9 alterar o endpoint para usar o banco de dados. Isso pode ser feito de maneira simples injetando a depend\u00eancia da <code>session</code>:</p> <pre><code>@app.get('/users/{user_id}', response_model=UserPublic)\ndef read_user__exercicio(\n    user_id: int, session: Session = Depends(get_session)\n):\n    db_user = session.scalar(select(User).where(User.id == user_id))\n\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    return db_user\n</code></pre> <p>A segunda parte \u00e9 entender o que precisa ser feito nos testes para que eles consigam cobrir os dois casos previstos. O de sucesso e o de falha.</p> <p>O teste de falha continua passando, pois ele de fato n\u00e3o depende de nenhuma intera\u00e7\u00e3o com o banco de dados: </p><pre><code>def test_get_user_should_return_not_found__exercicio(client):\n    response = client.get('/users/666')\n\n    assert response.status_code == HTTPStatus.NOT_FOUND\n    assert response.json() == {'detail': 'User not found'}\n</code></pre><p></p> <p>J\u00e1 o teste de sucesso, depende que exista um usu\u00e1rio na base dados. Com isso podemos usar a fixture de <code>user</code> tanto na chamada, quanto na valida\u00e7\u00e3o dos dados:</p> <pre><code>def test_get_user___exercicio(client, user):\n    response = client.get(f'/users/{user.id}')\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {\n        'username': user.username,\n        'email': user.email,\n        'id': user.id,\n    }\n</code></pre>"},{"location":"exercicios_resolvidos/aula_06/","title":"Exerc\u00edcios da aula 06","text":""},{"location":"exercicios_resolvidos/aula_06/#exercicios-da-aula-06","title":"Exerc\u00edcios da aula 06","text":""},{"location":"exercicios_resolvidos/aula_06/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Fa\u00e7a um teste para cobrir o cen\u00e1rio que levanta exception <code>credentials_exception</code> na autentica\u00e7\u00e3o caso o <code>email</code> n\u00e3o seja enviado via JWT. Ao olhar a cobertura de <code>security.py</code> voc\u00ea vai notar que esse contexto n\u00e3o est\u00e1 coberto.</p>"},{"location":"exercicios_resolvidos/aula_06/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Para executar o bloco de c\u00f3digo voc\u00ea deve fazer uma chamada a qualquer endpoint que dependa do token (currentUser) e enviar um token que n\u00e3o contenha um endere\u00e7o de e-mail (sub):</p> tests/test_app.py<pre><code>def test_get_current_user_not_found__exercicio(client):\n    data = {'no-email': 'test'}\n    token = create_access_token(data)\n\n    response = client.delete(\n        '/users/1',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.status_code == HTTPStatus.UNAUTHORIZED\n    assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre>"},{"location":"exercicios_resolvidos/aula_06/#exercicio-02","title":"Exerc\u00edcio 02","text":"<p>Fa\u00e7a um teste para cobrir o cen\u00e1rio que levanta exception <code>credentials_exception</code> na autentica\u00e7\u00e3o caso o email seja enviado, mas n\u00e3o exista um <code>User</code> correspondente cadastrado na base de dados. Ao olhar a cobertura de <code>security.py</code> voc\u00ea vai notar que esse contexto n\u00e3o est\u00e1 coberto.</p>"},{"location":"exercicios_resolvidos/aula_06/#solucao_1","title":"Solu\u00e7\u00e3o","text":"<p>Para executar o bloco de c\u00f3digo voc\u00ea deve fazer uma chamada a qualquer endpoint que dependa do token (currentUser) e enviar um token que contenha um endere\u00e7o de email (sub) que n\u00e3o esteja cadastrado na base de dados:</p> tests/test_app.py<pre><code>def test_get_current_user_does_not_exists__exercicio(client):\n    data = {'sub': 'test@test'}\n    token = create_access_token(data)\n\n    response = client.delete(\n        '/users/1',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.status_code == HTTPStatus.UNAUTHORIZED\n    assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre>"},{"location":"exercicios_resolvidos/aula_06/#exercicio-03","title":"Exerc\u00edcio 03","text":"<p>Reveja os testes criados at\u00e9 a aula 5 e veja se eles ainda fazem sentido (testes envolvendo <code>409</code>)</p>"},{"location":"exercicios_resolvidos/aula_06/#solucao_2","title":"Solu\u00e7\u00e3o","text":"<p>Os testes para os endpoints de PUT e DELETE, que verificam usu\u00e1rios n\u00e3o existentes na base de dados n\u00e3o fazem mais sentido. J\u00e1 que para alterar ou deletar um user, voc\u00ea tem que ser validado pelo token. Esses testes podem ser deletados.</p>"},{"location":"exercicios_resolvidos/aula_08/","title":"Exerc\u00edcios da aula 08","text":""},{"location":"exercicios_resolvidos/aula_08/#exercicios-da-aula-08","title":"Exerc\u00edcios da aula 08","text":""},{"location":"exercicios_resolvidos/aula_08/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Reveja os endpoints criados por voc\u00ea em exerc\u00edcios anteriores e adicione <code>async</code> e <code>await</code> para que eles se tornem n\u00e3o bloqueantes tamb\u00e9m.</p>"},{"location":"exercicios_resolvidos/aula_08/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Para o exerc\u00edcio do endpoit que retorna o HTML, a resolu\u00e7\u00e3o \u00e9 bastante simples:</p> <pre><code>@app.get('/exercicio-html', response_class=HTMLResponse)\nasync def exercicio_aula_02():\n    return \"\"\"\n    # ...\n</code></pre> <p>Para o endpoint de GET via ID:</p> <pre><code>@app.get('/users/{user_id}', response_model=UserPublic)\nasync def read_user__exercicio(\n    user_id: int, session: Session = Depends(get_session)\n):\n    db_user = await session.scalar(select(User).where(User.id == user_id))\n\n    if not db_user:\n        raise HTTPException(\n            status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n        )\n\n    return db_user\n</code></pre>"},{"location":"exercicios_resolvidos/aula_08/#exercicios-02","title":"Exerc\u00edcios 02","text":"<p>Altere o endpoint <code>read_root</code> para suportar <code>asyncio</code>.</p>"},{"location":"exercicios_resolvidos/aula_08/#solucao_1","title":"Solu\u00e7\u00e3o","text":"fast_zero/app.py<pre><code>@app.get('/')\nasync def read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre>"},{"location":"exercicios_resolvidos/aula_09/","title":"Exerc\u00edcios da aula 09","text":""},{"location":"exercicios_resolvidos/aula_09/#exercicios-da-aula-09","title":"Exerc\u00edcios da aula 09","text":""},{"location":"exercicios_resolvidos/aula_09/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>O endpoint de <code>PUT</code> usa dois users criados na base de dados, por\u00e9m, at\u00e9 o momento ele cria um novo user no teste via request na API por falta de uma fixture como <code>other_user</code>. Atualize o teste para usar essa nova fixture.</p>"},{"location":"exercicios_resolvidos/aula_09/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Para resolver esse exerc\u00edcio voc\u00ea s\u00f3 precisa remover a chamada para API e fazer com que o 'username' do PUT seja o de <code>other_user</code>:</p> tests/test_users.py<pre><code>def test_update_integrity_error(client, user, other_user, token):\n    response_update = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': other_user.username,\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n\n    assert response_update.status_code == HTTPStatus.CONFLICT\n    assert response_update.json() == {\n        'detail': 'Username or Email already exists'\n    }\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/","title":"Exerc\u00edcios da aula 10","text":""},{"location":"exercicios_resolvidos/aula_10/#exercicios-da-aula-10","title":"Exerc\u00edcios da aula 10","text":""},{"location":"exercicios_resolvidos/aula_10/#exercicio-01","title":"Exerc\u00edcio 01","text":"<p>Adicione os campos <code>created_at</code> e <code>updated_at</code> na tabela <code>Todo</code>     - Eles devem ser <code>init=False</code>     - Deve usar <code>func.now()</code> para cria\u00e7\u00e3o     - O campo <code>updated_at</code> deve ter <code>onupdate</code></p>"},{"location":"exercicios_resolvidos/aula_10/#solucao","title":"Solu\u00e7\u00e3o","text":"<p>Devem ser adicionados os dois campos ao modelo <code>Todo</code>:</p> fast_zero/models.py<pre><code>@mapped_as_dataclass(table_registry)\nclass Todo:\n    __tablename__ = 'todos'\n\n    id: Mapped[int] = mapped_column(init=False, primary_key=True)\n    title: Mapped[str]\n    description: Mapped[str]\n    state: Mapped[TodoState]\n\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped[User] = relationship(init=False, back_populates='todos')\n\n    # Exerc\u00edcio 01\n    created_at: Mapped[datetime] = mapped_column(\n        init=False, server_default=func.now()\n    )\n    updated_at: Mapped[datetime] = mapped_column(\n        init=False, server_default=func.now(), onupdate=func.now()\n    )\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/#exercicio-02","title":"Exerc\u00edcio 02","text":"<p>Criar uma migra\u00e7\u00e3o para que os novos campos sejam versionados e tamb\u00e9m aplicar a migra\u00e7\u00e3o</p>"},{"location":"exercicios_resolvidos/aula_10/#solucao_1","title":"Solu\u00e7\u00e3o","text":"<p>Se executarmos a migra\u00e7\u00e3o com o primeiro exerc\u00edcio resolvido, teremos algo como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"Adicionando created_at e updated_at na tabela de todos\"\n^[[AINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.autogenerate.compare] Detected added column 'todos.created_at'\nINFO  [alembic.autogenerate.compare] Detected added column 'todos.updated_at'\nINFO  [alembic.autogenerate.compare] Detected added column 'users.updated_at'\n  Generating /home/dunossauro/git/fastapi-do-\n  zero/codigo_das_aulas/09/migrations/versions/bd7cea4a4773_adicionando_created_at_e_updated_at_na_.py ...  done\n</code></pre> sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) <p>Caso voc\u00ea receba esse erro ao aplicar a migra\u00e7\u00e3o, recomendo que veja a Live de Python #211 sobre <code>migra\u00e7\u00f5es e bancos de dados evolutivos</code> (recomendada no texto da aula 04 - \"Caso nunca tenha trabalhado com Migra\u00e7\u00f5es\").</p> <p>No minuto 1:28:33 o motivo e a solu\u00e7\u00e3o desse erro s\u00e3o abordados em mais detalhes.</p> <p>Mas, em resumo, isso \u00e9 um problema causado pelo modo como o python se comunica com o sqlite, fazendo com que cada altera\u00e7\u00e3o no banco seja aplicado linha, a linha. Para fazer todas as modifica\u00e7\u00f5es de uma vez, usamos as <code>opera\u00e7\u00f5es em batch</code>. A ideia \u00e9 abrir uma \u00fanica conex\u00e3o com o banco de dados e executar determinadas opera\u00e7\u00f5es para todas as linhas antes da conex\u00e3o ser fechada.</p> <p>Para isso ser\u00e1 preciso alterar o arquivo de migra\u00e7\u00f5es manualmente. O arquivo deve se parecer com esse:</p> /migrations/versions/bb77f9679811_exercicio_02_aula_04.py<pre><code># ...\ndef upgrade():\n    with op.batch_alter_table('users', schema=None) as batch_op:  #(1)!\n        batch_op.add_column(   #(2)!\n            sa.Column(\n                'updated_at',\n                sa.DateTime(),\n                server_default=sa.text('(CURRENT_TIMESTAMP)'),\n                nullable=False,\n            )\n        )\n\n\ndef downgrade():\n    with op.batch_alter_table('users', schema=None) as batch_op:  #(1)!\n        batch_op.drop_column('updated_at')  #(3)!\n</code></pre> <ol> <li>Entrando no contexto das opera\u00e7\u00f5es em lote</li> <li>Adiciona a coluna <code>updated_at</code> na tabela <code>users</code> com o <code>batch_op</code></li> <li>Remove a coluna <code>updated_at</code> da tabela <code>users</code> com o <code>batch_op</code></li> </ol> <p>Gerando a seguinte migra\u00e7\u00e3o:</p> <pre><code>\"\"\"Adicionando created_at e updated_at na tabela de todos\n\nRevision ID: bd7cea4a4773\nRevises: 3a79a86c9e4a\nCreate Date: 2024-10-05 01:11:38.100051\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'bd7cea4a4773'\ndown_revision: Union[str, None] = '3a79a86c9e4a'\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column('todos', sa.Column('created_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False))\n    op.add_column('todos', sa.Column('updated_at', sa.DateTime(), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False))\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_column('todos', 'updated_at')\n    op.drop_column('todos', 'created_at')\n    # ### end Alembic commands ###\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/#exercicio-03","title":"Exerc\u00edcio 03","text":"<p>Adicionar os campos <code>created_at</code> e <code>updated_at</code> no schema de sa\u00edda dos endpoints. Para que esse valores sejam retornados na API.</p>"},{"location":"exercicios_resolvidos/aula_10/#solucao_2","title":"Solu\u00e7\u00e3o","text":"<p>Para adicionar os campos \u00e9 necess\u00e1rio somente a adi\u00e7\u00e3o dos mesmos no schema:</p> fast_zero/schemas.py<pre><code>from datetime import datetime\n# ...\n\n\nclass TodoPublic(TodoSchema):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n</code></pre> <p>A adapta\u00e7\u00e3o do teste, para validar o tempo, pode usar o evento de <code>mock_db_time</code>. Como o pydantic converte o resultado para json, ele transforma a data no formato iso. Isso deve ser levado em conta na compara\u00e7\u00e3o:</p> tests/test_todos.py<pre><code>from http import HTTPStatus\n\nfrom fast_zero.models import Todo, TodoState\nfrom tests.factories import TodoFactory\n\n\ndef test_create_todo(client, token, mock_db_time):\n    with mock_db_time(model=Todo) as time:\n        response = client.post(\n            '/todos/',\n            headers={'Authorization': f'Bearer {token}'},\n            json={\n                'title': 'Test todo',\n                'description': 'Test todo description',\n                'state': 'draft',\n            },\n        )\n\n    assert response.json() == {\n        'id': 1,\n        'title': 'Test todo',\n        'description': 'Test todo description',\n        'state': 'draft',\n        'created_at': time.isoformat(),\n        'updated_at': time.isoformat()\n    }\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/#exercicio-04","title":"Exerc\u00edcio 04","text":"<p>Crie um teste para o endpoint de busca (GET) que valide todos os campos contidos no <code>Todo</code> de resposta. At\u00e9 o momento, todas as valida\u00e7\u00f5es foram feitas pelo tamanho do resultado de todos.</p>"},{"location":"exercicios_resolvidos/aula_10/#solucao_3","title":"Solu\u00e7\u00e3o","text":"<p>Esse exerc\u00edcio \u00e9 um pouco mais trabalhoso que os demais. Vamos dividir ele em etapas:</p> <ol> <li>Devemos ter o tempo determin\u00edstico (<code>mock_db_time</code>) para poder validar o json</li> <li>Devemos criar um todo com dados aleat\u00f3rios (<code>TodoFactory</code>)</li> <li>Devemos ter um token e um usu\u00e1rio criado</li> </ol> <p>No final das contas, algo parecido (n\u00e3o necessariamente id\u00eantico) a isso:</p> <pre><code>@pytest.mark.asyncio\nasync def test_list_todos_should_return_all_expected_fields__exercicio(\n    session, client, user, token, mock_db_time\n):\n    with mock_db_time(model=Todo) as time:\n        todo = TodoFactory.create(user_id=user.id)\n        session.add(todo)\n        await session.commit()\n\n    await session.refresh(todo)\n    response = client.get(\n        '/todos/',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.json()['todos'] == [{\n        'created_at': time.isoformat(),\n        'updated_at': time.isoformat(),\n        'description': todo.description,\n        'id': todo.id,\n        'state': todo.state,\n        'title': todo.title,\n    }]\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/#exercicio-05","title":"Exerc\u00edcio 05","text":"<ol> <li>Crie um teste para validar o caso do <code>Enum</code> em <code>state: Mapped[TodoState]</code> na tabela <code>TODO</code>, onde o valor esteja fora dos valores mapeados por ele. Isso for\u00e7ar\u00e1 um erro que pode ser validado com <code>pytest.raises</code></li> </ol>"},{"location":"exercicios_resolvidos/aula_10/#solucao_4","title":"Solu\u00e7\u00e3o","text":"<pre><code>@pytest.mark.asyncio\nasync def test_create_todo_error(session, user: User):\n    todo = Todo(\n        title='Test Todo',\n        description='Test Desc',\n        state='test',\n        user_id=user.id,\n    )\n\n    session.add(todo)\n    await session.commit()\n\n    with pytest.raises(LookupError):\n        await session.scalar(select(Todo))\n</code></pre>"},{"location":"exercicios_resolvidos/aula_10/#exercicio-06","title":"Exerc\u00edcio 06","text":"<p>Crie dois testes para validar a busca por <code>todos</code>.    - Um com o <code>title</code> com um texto menor do que <code>3</code> caracteres    - Um com o <code>title</code> com um texto maior do que <code>20</code> caracteres</p>"},{"location":"exercicios_resolvidos/aula_10/#solucao_5","title":"Solu\u00e7\u00e3o","text":"<p>A solu\u00e7\u00e3o desse exerc\u00edcio \u00e9 bastante simples, precisamos de uma querystring com o campo <code>title</code> e fazer uma requisi\u00e7\u00e3o com uma string menor e outra com a string maior que o que definimos no schema:</p> <pre><code>def test_list_todos_filter_min_length_exercicio_06(client, token):\n    tiny_string = 'a'\n    response = client.get(\n        f'/todos/?title={tiny_string}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY\n\n\ndef test_list_todos_filter_max_length_exercicio_06(client, token):\n    large_string = 'a' * 22\n    response = client.get(\n        f'/todos/?title={large_string}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY\n</code></pre>"},{"location":"projetos/projetos_finais/","title":"Projetos finais","text":""},{"location":"projetos/projetos_finais/#projetos-finais","title":"Projetos finais","text":"<p>O objetivo dessa p\u00e1gina \u00e9 unir todos os projetos finais de pessoas que fizeram o curso em uma tabela para que voc\u00ea possa consultar, estudar, aprender com as pessoas que tamb\u00e9m fizeram o curso e ver como elas criaram o projeto final.</p> <p>Caso seu projeto final n\u00e3o esteja aqui, o poste nessa issue</p> Link do projeto Seu @ no git Coment\u00e1rio (opcional) projeto @dunossauro Ainda n\u00e3o fiz FastZero-MADR @clcosta - madr @alfmorais - bookshelf @Tomas-Tamantini - fast_zero_projeto_final vitorTheDev \u00d3timo curso! madr elyssonmr Sensacional. Consegui fazer tudo async :) madr arturpeixoto Muitos aprendizados! madr_fast @itsGab Projeto baseado no curso, com <code>fastapi_pagination</code>. Obrigado pelo \u00f3timo curso! app_library @thigoap Docker est\u00e1 em uma branch separada (docker). madr @henriquesebastiao 201 CREATED \u2705 fastapi-madr @michelebswm Sensacional madr @taconi API <code>async</code>, com templates usando Jinja2 e httpx e 99.9% em ~portugu\u00eas~ brasileiro. madr @MuriloRohor MADR @gabitrombetta madr @danielbrito91 Baita curso \u2764\ufe0f madr-fastapi @lealre tcc_madr @guilopes15 madr @eduardoklosowski Projeto utilizando Dev Containers integrado ao Visual Studio Code, deploy no Kubernetes via Helm usando um cluster local gerenciado pelo minikube. Mais detalhes confira o hist\u00f3rico do projeto. madr @Romariolima1998 mada_sync LuizPerciliano Projeto fluindo de vento em popa, muito obrigado Edu por t\u00e3o grande aprendizado! \u2764\ufe0f fastapi-acervo-digital @heltonteixeira92 Conte\u00fado supimpa \ud83d\ude80 madr @duca_meneses Excelente curso MADR @hugocs1 Muito foda, obrigado! fastapi_zero_madr_projeto_final @devfabiopedro \ud83d\udcbb Feito! \u270c\ufe0f\ud83d\ude01 TCC_MADR @GermanoCesarSS Esse projeto seguiu a risca a documenta\u00e7\u00e3o de ajuda do dunossauro madr-api @TheCamilovisk Finalmente consegui tempo para terminar\ud83d\ude01 FastAPI-MADR mayconcorreatinti \u00d3timo curso! madr_api Samaelpicoli Projeto MADR Async Finalizado - \u00d3timo conte\u00fado Edu! madr thiagonebuloni Conclu\u00eddo, obrigado Duno! APIMader Luiznuness Curso massa dms, aprendi muito, obrigado edu \u2764\ufe0f fastapi-final-project @bruno-gabriel-muniz Excelente Curso! madr @Joao-Pedro-P-Holanda Curso muito bom!"},{"location":"projetos/repositorios/","title":"Reposit\u00f3rios do curso","text":""},{"location":"projetos/repositorios/#repositorios-do-curso","title":"Reposit\u00f3rios do curso","text":"<p>O objetivo dessa p\u00e1gina \u00e9 unir todos os reposit\u00f3rios de pessoas que fizeram o curso em uma tabela para que voc\u00ea possa consultar, estudar, aprender com as pessoas que tamb\u00e9m fizeram o curso e ver como elas resolveram os exerc\u00edcios do curso.</p> <p>Caso o seu reposit\u00f3rio n\u00e3o esteja aqui, \u00e9 por que voc\u00ea n\u00e3o resolveu os exerc\u00edcios da Primeira aula</p> Link do projeto Seu @ no git Coment\u00e1rio (opcional) fast_zero @dunossauro Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es e sem exerc\u00edcios fast_zero @morgannadev Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @rodrigosbarretos Foi bacana enfrentar os problemas instalando as coisas no Ubuntu no WLS fast_zero @azmovi Que projeto bacana dudu, muito obrigado fastapi-do-zero @aguynaldo Estudo a partir do curso de FastAPI do Dunossauro. fastapi-do-zero @gercinei Minha primeira experi\u00eancia com um framework fast_zero @ju14x Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es Fast_zero @IsisG13 Estudando com o curso de FastAPI economio @marcos-ag-nolasco Criando um app fullstack, cujo backend vai ser baseado no fast_zero fastapi-do-zero @RWallan Tentando implementar o curso com Async fastapi-do-zero @gylmonteiro Estudos inicias com fastapi crono_task_backend @mau-me App para gerenciamento de tasks, com o backend baseado no fast_zero fast_zero @navegantes Mais uma ferramenta de paito pra caixinha fast_zero @willrockoliv Projeto incr\u00edvel @dunossauro! Muito obrigado!! fastapi-training @Brunoliy Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es backend-portfolio @stherzada Implementa\u00e7\u00e3o do curso e aprimorando aprendizado no backend \u2728 fast_zero @lbmendes Usando a VM gratis da OCI para fazer o Curso fast_zero @vilmarspies Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @RogerPatriota Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast-zero @machadoah Aprendendo FastAPI \ud83d\udc0d \u2728 fast_zero @FabricioPython Curtindo FastAPI  fast_api @juniohorniche Massa demais esse conte\u00fado \ud83d\ude0d fast_zero @taconi Com hatch, <code>async</code>, podman, Woodpecker CI e hospedado no Codeberg fastapi-do-zero @joceliovieira Repo com material pessoal (notas, c\u00f3digos, etc), sem clone do repo oficial curso-fastapi-webdev @joaobugelli Parab\u00e9ns pelo conte\u00fado e material excelentes! Voc\u00ea \u00e9 demais Duno! notas-musicais-api @rochamatcomp API para o Notas musicais fast_cometa @mpdiasrosa Estudando FastAPI do zero \ud83d\udc0d fastapi_do_zero @arturfarias Projeto de estudos com poetry e fastAPI fastapi-do-zero-dunossauro @leopoldocouto Material de estudo do Curso de FastAPI do Zero do @dunossauro fast_zero @psifabiohenrique Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero 2005869 Implementa\u00e7\u00e3o do material sem altera\u00e7\u00f5es fast_zero @miguelferreiraZ Estudo a partir do curso: Fast-API do Zero fast_zero @kassoliver Aprendendo um pouco mais de FastAPI com o Dunossauro \ud83d\udc0d fast_zero @jhonatacaiob Aprendendo um pouco de FastAPI com o Dunossauro \ud83d\udc0d fast_zero @arnaldovitor Material de estudo do curso \"FastAPI do Zero\" do @dunossauro fast_zero @vcwild Acompanhando o conte\u00fado do curso s\u00edncrono fast_api @viniciusaito Curtindo as aulas do curso de fast api fast_zero @andreztz Aprendendo  FastAPI com @dunossauro  \ud83d\udc0d fast_zero @SouzaPatrick Aprendendo um pouco de FastAPI com o Dunossauro \ud83d\udc0d fastzero @AndreGM Aprendendo FastAPI com @dunossauro  fastapidozero-dunossaudo @francadev Aprendendo FastAPI com @dunossauro course_fast_api_zero @vmfrois Aprendendo FastAPI com @dunossauro fastapi-do-zero @Everton92 Aprendendo FastAPI com o mais brabo @dunossauro fastapi_zero_duno @guiribeirodev Desenvolvimento Web e FastAPI com o @dunossauro fast_zero @andrefelipemsc  Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es. Porque este \u00e9 o melhor e mais completo curso da internet. fast_zero @jlplautz  Projeto baseado no curso FastAPI com o mestre Dunossauro. fasst_zero @prpires66 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fastAPI_do_zero @BrunoPinheirofe Primeiros passos com FastAPI fastapidozero @lucaspaimrj21 Configurando o ambiente de desenvolvimento e primeiro commit fast_api_todo @joiltonrsilva Desenvolvendo aplica\u00e7\u00e3o TODO  com FastAPI nas aulas do prof. @dunossauro fast_zero @duca-meneses Aprendendo mais sobre fastAPI com o @dunossauro fast_split @thigoap FastAPI com o nome do futuro projeto. fast_sync @edisonmsj First project using fast api FastAPI_do_ZERO @GedeilsonLopes Curso foda demais\u00a0@dunossauro! fast_zero_sync @animarubr Implementa\u00e7\u00e3o do material do curso na plataforma windows dunossauro_fast_api @danielbrito91 Implementa\u00e7\u00e3o do curso fast_zero_sync @marcossa Projeto produzido durante a aula. Aprendendo Python hands-on! fast_zero @FilipeNeiva Muito bom o curso fast_zero @elyssonmr Muito bom aprender ao vivo fast_zero_sync @WilliamCutrim Muito bom fastapi-do-zero @paulinhomacedo Obrigado Edu por sua disposi\u00e7\u00e3o de ensiar. fast_zero_api @peixoto-pc  Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_do_dunossauro @hebertn88 Projeto desenvolvido durante Curso FastAPI do Zero Toad_list @victorvhs  Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @josedembo Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es curso-fastapi-dunossauro @sigaocaue Implementa\u00e7\u00e3o do material do curso de FastAPI do Dunossauro fast_zero_sync @RRFFTT Meu primeiro projeto, construindo uma API fast_zero @Alan-Gomes1 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_api @PedroP7l Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es estudos-fastapi @vizagre Upload da primeira tarefa de aula fastapi-do-zero @gleissonribeiro Projeto desenvolvido durante o curso de fastapi do @dunossauro (Eduardo Mendes) em 2024. fast_zero @cesargodoi muito obrigado pelo empenho e pelo conte\u00fado fastapi_do_zero_dunossauro @CleberNandi  fast_zero @alvie40 Excelente did\u00e1tica e estrutura do curso. Obrigado fast_zero @LisandroGuerra Obrigado por este curso excelente! Apredendo tamb\u00e9m a usar o Poetry. fastapi_todo @dubirajara Acompanhando o curso de FastApi do Zero fast_api_zero @IgorStrauss Excelente metodologia, e conceitos muito importantes para o dia a dia na carreira de Dev. fast_zero @divirjo fast_zero @sandrocarval - fast_zero @migueluff - fast_zero @gustaaragao Bem divertido ;) fast_zero @DanielDlc Muito bom, conte\u00fado feito com carinho e intelig\u00eancia. FastAPI_dunossauro @Fernanda-Prado Conte\u00fado excelente, desconhecia o taskipy e quero colocar ele em todo projeto meu to_do_list FrAnKlInSousa - fast_zero @itsGab - Fastapi @kleytonls Muito Obrigado pela dedica\u00e7\u00e3o em fazer um conte\u00fado de t\u00e3o boa qualidade dunossauro FastAPIZero @Leandro-VS Conteudo incr\u00edvel desse curso fast_zero @gabriel19913 Estava a tempos na expectativa por esse curso! T\u00f4 muito ansioso pra aprender coisas novas! fast_zero @marlonato Curso excelente, adorei ver a ideia do ruff e pytest fast_zero @joncasdam Que saudade de lidar com python fast_zero_sync @gabriellcristiann Did\u00e1tica incrivel cara Parab\u00e9ns fast_zero @GuilhermeAndre1 Baita aula boa! full_fast_api @Oseiasdfarias Bom demaizi fast_zero @rbsantosbr Projeto sensacional, aprendizado muito al\u00e9m das tecnologias! fast_zero @CarlosPetrikov Reposit\u00f3rio referente ao curso de FastAPI do Eduardo Mendes fast_zero @Samaelpicoli Aprendendo FastAPI, conte\u00fado sensacional! fast_zero @WesleyPacca Come\u00e7ando FastAPI fastapi_zero @emanoelmendes2 Aprendendo FastAPI fastapi-zero @joaobrc Reposit\u00f3rio do curso de FastAPI fast_api_curso matheuspdf Excelente curso fast_zero @Gui-mp8 Melhor Curso! fast_zero @HulitosCode Fazendo o curso de Fastapi do Zero fast_zero_sync @renatobarramansa Projeto utilizando fastApi fast_zero @renatonaper fast_zero @lidymonteiro Reposit\u00f3rio do curso de FastAPI fast_zero @dgeison Estou utilizando o Windows Subsystem for Linux (WSL) para desenvolver em FastAPI. Valeu pela explica\u00e7\u00e3o, did\u00e1tica, conte\u00fado e material. FastAPI_Lab @tallesemmanuel Por mais que saiba algo, vi que n\u00e3o sei de nada FAST-API Francisco-Libanio Iniciei o projeto estou usando pycharm fast_zero @KrisEgidio Aprendendo FastAPI seguindo o curso FastAPI do Zero! Fast_api_sync @JoaoGBC Aprendendo FastAPI seguindo o curso FastAPI do Zero! fastapi @PedroP7l Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero_sync @diogogonnelli Implementa\u00e7\u00e3o do material do curso fast_zero_sync @davidrangelrj Implementa\u00e7\u00e3o do material do curso fastapi_project @alsombra Aprendendo fastapi e webdev com a lenda Dunossauro fast_zero @alyssondaniel Implementa\u00e7\u00e3o do material do curso\u00a0COM\u00a0altera\u00e7\u00f5es fast_zero @eduardoalsilva api_master @matheusfly Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @MatheusLPolidoro Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es running_fast_api @santana98 Repo acompanhando as aulas do curso fastapi-do-zero @thiagosouzalink Excelente curso, parab\u00e9ns! fast_zero_sync @caio-io Minha primeira API fast_zero_sync @giovanezanardo0 Curso top demais fast_zero_sync @Matheus-Novoa Primeiro projeto web com python fast_api_tutorial @Tomas_Tamantini Aprendendo Fast API fast_zero @FariasMi Aprendendo Fast API (dunossauro sou sua f\u00e3) FastOpenDBBrasil @NercinoN21 Uma API Python com FastAPI para descoberta de bases de dados p\u00fablicas do Brasil por tema, ideal para pesquisa e estudos. fast_zero @MuriloRoho fast_zero @flaviacastro - fast_zero @vizagre Tive problemas com o WSL e recriei o projeto do zero no windows. Esse \u00e9 o novo repositorio fast_zero @w1zard Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es APIcultura @rmndvngrpslhr Fazendo o curso sozinho foi quando montei uma APIs pela primeira, agora t\u00e1 sendo divertido refazer tudo revendo o conte\u00fado no modo s\u00edncrono o Edu fast_zero_sync @andrescalassara fast_zero Victor Berselli Valeu Eduardo! \ud83e\udd96 festapi Santos Duuu obrigada \ud83e\udd96! my-fastapi @slottwo Implementa\u00e7\u00e3o do material do curso com pequenas altera\u00e7\u00f5es fast_zero @AmeriCodes To perdidinho kk fast_zero @NataGago \u00e9 a tropa do Dunossauro! \ud83e\udd96 fast_zero @Dxm42 Muito obrigado por criar este curso! Estou aprendendo muito. fast_zero_sync @FelipeSantiagoMenezes Estou gostando muito do curso! learning-fastapi @fernandoortolan Implementa\u00e7\u00e3o do material do curso. fast_zero @rafaael1 Aprendendo Fast API, Valeu Eduardo! \ud83e\udd96 fast_zero @felipeCaetano Fazendo o Curso de FastAPI fast_zero @thiagosp  Vamos pra cima!!! fast_zero @ssantos89 Aprendendo FastAPI com Dunossauro - First Commit fast_zero_classes @oTerra Projeto criado com base no curso FastAPI do zero do Eduardo Mendes fast_zero @Cmte-Kirk Aspas duplas \u00e9 pra quem tem as duas m\u00e3os! Gostei dessa frase! fast_zero @eduardobrennand Muito bom! \ud83d\ude80\ud83d\ude80\ud83d\ude80 fastapi-dunossauro @gillianoliveira Conte\u00fado nota 100! fast_zero @danweb80 Acompanhamento do Curso FasAPI do Dunossauro fast_api_zero @anselmotaccola fast_zero @epfolletto Curso de FastAPI - Live de Python - Eduardo Mendes fastapi-do-zero-exercicios rg3915 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es. fastapi_zero @devfabiopedro Curso de FastAPI do Dunossauro fastapi_zero @baronetogio Curso de FastAPI fast_zero @thalissonvs Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_api_project @guilherme.canfield Obrigado mestre Dunossauro! fastapi_zero @edipolferreira O curso est\u00e1 sensacional! fast_api_zero @brunopmendes Curso t\u00e1 demais (amei a integra\u00e7\u00e3o nativa com o swagger) fast_zero fabiomattes2016 Ta lindo esse curso, continue assim :) fast_zero @tuxanator fastapi, seu lindo. fast_zero @thamibetin Aprendendo mais de Python \ud83d\udc0d com o melhor! \ud83d\udcab fast_zero @washingtonnuness Parab\u00e9ns pelo conte\u00fado e material excelentes! Voc\u00ea \u00e9 demais Duno! FastAPI_Du_Zero @rodten23 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es. Muito Obrigado, Dunossauro! fast_zero @me15degrees Tardei mas n\u00e3o falhei fast_zero @wilsonritt fast_zero @pedronora Curso sensacional fast_zero @Andersonmathema Projeto maravilhoso, espero melhorar muito com esse aprendizado e compartilhar o pouco que sei com a galera fast_zero @BrunoRimbanoJunior Muito Aprendizado, s\u00f3 tenho a agradecer ao professor Eduardo. curso-fastapi-do-zero @mferreiracosta Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @ViniNardelli  Come\u00e7ando um pouco atrasado, mas aprendendo bastante fastapi_curso @juacy fast_zero @paullosergio Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero  @JordyAraujo Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero  @marfebr implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero @guilopes15 Implementa\u00e7\u00e3o do material do curso estudo_kaoz allandarus Estudos com Fast Api fast_zero @arturpeixoto Expandindo os conhecimentos de back-end com o FastAPI fast_zero @CarlosHenriquePSouza fastapi_duno_curso @LeandroDeJesus-S antes tarde do que mais tarde fastapi_zero_sync @Rafael-Inacio fast_zero @ArthurTZ Inicio do projeto fast_zero_sync @LuizPerciliano Come\u00e7ar \u00e9 importante, terminar \u00e9 melhor ainda! fastapi_learn @viniciusmilk Conhecimento sempre \u00e9 bem-vindo fastapi_curso @alves05 Curso excelente de FastAPI, o melhor que ta tendo! Vlw Eduardo! Fast_Zero_Hero @Lyarkh API desenvolvida com base no Curso de FastAPI trilha_fastAPI @vitoriarntrindade Obrigada por ser t\u00e3o bom pra comunidade Python! fast_zero @Tiago-Verde Obrigado Dunossauro fastapi_do_zero SantosTavares Este reposit\u00f3rio ser\u00e1 utilizado como base para novos projetos fast_zero_july_sync @marceloc4rdoso Esse reposit\u00f3rio \u00e9 destinado a estudos de FastAPI com @dunossauro Fast Notebook Matheus Um ambiente para anota\u00e7\u00f5es do curso. Fast_Api_Sync Braian N Ribeiro Fui descobri o curso quase no final das aulas online mas ainda vai da pra participar de umas 2 aulas valeu Duduzito Curso_FastApi regianemr Aprendendo a usar o Fast Api fast_zer0 xjhfsz Aulas s\u00edncronas fastapi_zero @sandenbergmelo Aprendendo como construir APIs em python com o FastAPI FastAPI @frbelotto Coment\u00e1rio fast_zero @Viniscorza Implementa\u00e7\u00e3o do material do curso - FastApi - Dunossauro FastAPI do Zero Hiroowtf Iniciando o Curso fast_zero @Pedro-hen Aprendendo FastAPI fast_api_zero andre-alves77 Obrigado Eduu fast_zero @williamslews Aulas sincronas fast_zero vitorTheDev Obrigado duno! curso-fastapi Tchez Parab\u00e9ns pelo curso! project_fastapi amandapolari Construindo API em Python utilizando FastAPI fast_zero vgrcontreras Implementa\u00e7\u00e3o do curso FastAPI do Zero! fast_zero @HigorTadeu  Reposit\u00f3rio utilizado para os c\u00f3digos em Python do curso com FastAPI fastapi-do-zero @rodfersou Usando Nix no lugar de Pyenv; Scripts to rule then all no lugar do taskipy fast_zero @alexrodriguesdasilva Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fastapi_ai_project @lesampaio Implementando o material do curso + aplica\u00e7\u00e3o de intelig\u00eancia artificial :shipit: fast_zero @rdgr1 Aprendendo FastAPI para Fins Educacionais :) fast_zero hsdanield Acompanhamento do curso fastapi-do-zero fast_zero_sync @amanmdest Bel\u00edssimo curso de FastAPI, me divertindo e aprendendo bastante curso_fast_zero @QuintelaCarvalho Aprendendo Sempre Mais com voc\u00ea Eduardo, Obrigado! fast_zero_sync seu @ Coment\u00e1rio fast_zero @huhero Colombiano \ud83c\udde8\ud83c\uddf4 aprendiendo FastApi fast_zero_classes @luismineo Setup inicial da aula de fastAPI fast_zero @Brugarassis :D fast_api_task @daniloheraclio \ud83c\udf89 fast_zero  @DevSchoof  Iniciando o curso fastapi-do-zero @heltonteixeira92  To infinity and beyond fast_zero seu @barscka Aprendo python com o melhor fastAPI_do_zero @viniciusCalcantara UaU! fast_zero @balaios Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fastapizero @levyvix Aprendendo FastAPI do Zero python-curso-fastapi @fabiocasadossites Aprendendo FastAPI do Zero fast_zero @henriquesebastiao Muito grato por todo o curso e pela dedica\u00e7\u00e3o Edu. Sensacional! FastAPI_Zero JuniorD-Isael Primeira aula e eu j\u00e1 aprendi um zilh\u00e3o de coisas novas fast_zero_sync_v2 LuizPerciliano Opi! Refazendo aulas em novo projeto, vamos que vamos de muito aprendizado! do_know_fastapi @LucasDatilioCarderelli Correndo para assistir as aulas e fazer os desafios fast_zero @perylemke Aprendendo FastAPI fast_zero_sync vallejoguilherme fast_zero otonielnn Explorando FastApi fast-zero icaroHenrique Aprendendo FastAPI fast_zero Nicholasnas Implemetando o projeto com algumas altera\u00e7\u00f5es task_manager_fastapi mourayago Iniciandos os estudos de FastAPI projeto_fast_api @iurimcosta Coment\u00e1rio fast_zero_sync @ThiffanyAriane Meu primeiro projeto FastAPI fast_zero RaulRory Welcome FastAPI fast_api_do_zero @joaosgotti muito obrigado por esse curso :) fast-todo brunodavi Muito obrigado pelo incr\u00edvel projeto com a comunidade fast_api_learning Giatroo Curso sensacional, obrigado pelos ensinamentos Edu! fastapiduzero Fabricio Castro Obrigado! fastapi_zero_python @danielfelix45 Iniciando estudos em Python com esse curso incr\u00edvel sobre FastAPI primeiro-projeto @Lucas-Hamada-Nuco Esse e o meu primeiro projeto, muito obrigado src_fast_zero @FtxDante Participando dos estudos tmb :D fast_api_zero yedsrjr Meu projeto FastAPI Python-FastAPI @gfauth Meu projeto FastAPI FastAPI Andrersm Categorias de base \ud83d\ude80 FastAPI Tzus Tentando aprender essa brincadeira FastAPI PedroC16 Categorias de base \ud83d\udc7b senpaisearch_api @bogeabr Aprendendo FastAPI de forma divertida fast_zero_sync thiago-laza Muito obrigado CAMARADA !!!! labpr ostuff Brabo demais! fast_zero dancbatista Excelente material! fastAPI-foods @estelaoliveiradev API adaptada Curso de FastAPI @allerasouza Amassou! course_fast_zero @Mateus2222 Come\u00e7ando no FastApi Aprendendo_fastapi Luis-lhgdf Muito bom! fast_app @Isaquelins523 https://github.com/PectylsonLinho/zero_fastapi @PectylsonLinho I'm from Angola, Minha primeira experi\u00eancia com um FWK WebPython. Obrigado Du  \ud83d\udc4c https://github.com/marythealice/fast_zero_malice @marythealice Reposit\u00f3rio de FastAPI fast_api_study @yanndrade Estava procurando por um conte\u00fado como esse para aprofundar meus conhecimentos de back-end fast_api_study @0xluc Boa did\u00e1tica fast-zero yveskleny Conte\u00fado excepcional!! fast_api SauloTracer A mente que se abre a uma nova experi\u00eancia jamais retorna ao seu tamanho original. fastapi-to-do @Milleny27 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es. fast_zero_sync @Hudsonfalcao19 Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es curso-fastapi-do-zero @taniodev Obrigado pela sua dedica\u00e7\u00e3o Edu! fast_zero_windows @GermanoCesarSS Aprendendo FastAPI  no Windows \ud83d\udc0d \u2728 fast_zero @rafael-prazeres Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es Fast_API @gustav0mirand4 Minha primeira API fast_zero @joaovitorsh Implementa\u00e7\u00e3o do material do curso utilizando Ubuntu no WSL fastapi-do-zero @LilM4Ki Conte\u00fado incr\u00edvel! todo-list @NatalNW7 Sempre tem algo novo para aprender. Muito Top o curso! fastapi_zero @alexeiev Aprendendo um pouco mais de Python com o Melhor fast_zero @thiagocidade Aprendendo um pouco mais sobre FastAPI fastapidozero @jpfsemp Aprendendo um pouco de python e FastAPI. Curso sensacional. [fast_api_zero] [@ViFernaaandes] Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero_sync @Scriptaron Implementa\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es FastAPI-Project @Potatoyz908 Aprimorando meus conhecimentos em Python e FastAPI [fastzero-curso-eduardo-mendes] @GabrielGuedesSilva Aprendendo FastAPI com o melhor! fast_zero_repo @PatrickSagio Aprendendo FastAPI. Curso show de bola! fastpy_todo @pLogicador Primeiros passos com FastAPI, at\u00e9 agora interessante! estudo_fastapi @djDhyogo fast_zero @Luiz-ROCampos Iniciando o curso, antes tarde do que nunca fastapi morgannadev Aprendendo de novo fast_zero samuel-apls Curso de FastAPI com Eduardo Mendes (dunossauro) Primeiro Projeto FASTAPI cassiogvstos Estou alguns no futuro ap\u00f3s as grava\u00e7\u00f5es do curso, mas achei muito bom, din\u00e2mica e did\u00e1tica fant\u00e1sticas, Parab\u00e9ns. fast_zero_learning costacoder Iniciando curso do FastAPI com dunossauro, conte\u00fado excelente. fastapi-do-zero Gelzieny Aprendendo de novo fastAPI_Zero @renanapcs Aprendendo FastAPI com Dunossauro fast_api_do_zero juniors719 Aprendendo FastAPI!!!! fast_zero renanclemonini Muito obrigado pelo conte\u00fado, de cora\u00e7\u00e3o curso_fast_api @JoabAnderson Aprendendo FastAPI fast_api_do_zero juniors719 Aprendendo FastAPI!!!! fast_zero renanclemonini Muito obrigado pelo conte\u00fado, de cora\u00e7\u00e3o curso_fast_api @JoabAnderson Aprendendo FastAPI ToDo-Fastapi danielReis404 Iniciando o curso FastAPI / Fast Zero  @ricardojrgrb First Coomit fast_zero_sync iamguigasousa To curtindo muito esse curso, o Edu explica muito bem Fast_zero @AndrewGRM Estou come\u00e7ando o projeto, espero aprender muito \ud83d\udcaf learning_fast_api @costamarcelo Aprendendo mais sobre APIs com FastAPI fast_zero_sync ariondjunior Implemeta\u00e7\u00e3o do material do curso sem altera\u00e7\u00f5es fast_zero DaniDMoura valeuu fast_zero @mateus-dev-me Reposit\u00f3rio de estudos do curso FastAPI do Zero do Eduardo Mendes."},{"location":"quizes/aula_01/","title":"Aula 01","text":"01 - Configurando o Ambiente de Desenvolvimento 01 - Qual a fun\u00e7\u00e3o do pipx?Criar e gerenciar ambientes virtuais para bibliotecasInstalar bibliotecas isoladamente de forma globalUma alternativa ao pipUma alternativa ao venvEnviar 02 - Qual a fun\u00e7\u00e3o do Poetry?Uma alternativa ao pipGerenciar um projeto pythonTem o mesmo prop\u00f3sito do pipxEnviar 03 - O que faz o comando \"fastapi dev\"?Cria um ambiente de desenvolvimento para o FastAPIInicia o servidor de produ\u00e7\u00e3o do FastAPIInicia o Uvicorn em modo de desenvolvimentoInstala o FastAPIEnviar 04 - Ao que se refere o endere\u00e7o \"127.0.0.1\"?Ao endere\u00e7o de rede localCaminho de loopbackEndere\u00e7o do FastAPIEnviar 05 - A flag do poetry \"--group dev\" instala os pacotesde produ\u00e7\u00e3ode desenvolvimentode testesEnviar 06 - Qual a fun\u00e7\u00e3o do taskipy?Criar \"atalhos\" para comandos mais simplesFacilitar o manuseio das opera\u00e7\u00f5es de terminalInstalar ferramentas de desenvolvimentoGerenciar o ambiente virtualEnviar 07 - O pytest \u00e9:um linterum formatador de c\u00f3digoframework de testesEnviar 08 - Qual a ordem esperada de execu\u00e7\u00e3o de um teste?arrange, act, assertact, assert, arrangearrange, assert, actEnviar 09 - Dentro do nosso teste, qual a fun\u00e7\u00e3o da chamada na linha em destaque? <pre><code>def test_root_deve_retornar_ok_e_ola_mundo():\n    client = TestClient(app)\n\n    response = client.get('/')\n\n    assert response.status_code == HTTPStatus.OK\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> assert arrange act Enviar 10 - Na cobertura de testes, o que quer dizer \"Stmts\"?Linha cobertas pelo testeLinhas n\u00e3o cobertas pelo testeLinhas de c\u00f3digoEnviar"},{"location":"quizes/aula_02/","title":"02 - Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":""},{"location":"quizes/aula_02/#02-introducao-ao-desenvolvimento-web","title":"02 - Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":"01 - Sobre o modelo cliente servidor, podemos afirmar que:O servidor \u00e9 respons\u00e1vel por servir dados aos clientesO cliente \u00e9 quem consome recursos do servidorA comunica\u00e7\u00e3o \u00e9 iniciada pelo servidorAs respostas s\u00e3o originadas pelo clienteEnviar 02 - Um servidor de aplica\u00e7\u00e3o como uvicorn:pode servir a aplica\u00e7\u00e3o em loopbackpode servir a aplica\u00e7\u00e3o em rede localdeve servir a aplica\u00e7\u00e3o somente em produ\u00e7\u00e3oEnviar 03 - O que significa URL?Uma Rota LocalRotas Locais UnidasLocalizador de Recursos LocaisLocalizador Uniforme de RecursosEnviar 04 - Qual dessas op\u00e7\u00f5es faz parte da URL:ProtocoloEndere\u00e7oHTMLCaminhoPortaVerboEnviar 05 - Qual desses campos n\u00e3o faz parte do cabe\u00e7alho HTTP?ServerContent-TypeCorpoAcceptEnviar 06 - O verbo PUT tem a fun\u00e7\u00e3o de:Solicitar um recursoDeletar um recursoAtualizar um recurso existenteTodas as anterioresEnviar 07 - Respostas com c\u00f3digos da classe 500, significamSucessoErro no servidorInformacionaisErro no clienteEnviar 08 - O c\u00f3digo 200 de resposta significa:FoundAcceptedCreatedOKEnviar 09 - O c\u00f3digo 422 de resposta significa:Not FoundOKUnprocessable EntityBad RequestForbiddenEnviar 10 - Qual a fun\u00e7\u00e3o do pydantic?Validar os dados que saem da APIValidar os dados que entram na APIDocumenta\u00e7\u00e3o autom\u00e1ticaEnviar"},{"location":"quizes/aula_03/","title":"Aula 03","text":"03 - Estruturando o Projeto e Criando Rotas CRUD 01 - O m\u00e9todo POST pode ser associado a qual letra da sigla CRUD?UDCREnviar 02 - Quando um recurso \u00e9 criado via POST, qual o Status deve ser retornado para sucesso?200201202301Enviar 03 - Quando um schema n\u00e3o \u00e9 respeitado pelo cliente, qual o status retornado?500404401422Enviar 04 - O FastAPI retorna qual status para quando o servidor n\u00e3o respeita o contrato? UNPROCESSABLE ENTITYI'M A TEAPOTINTERNAL SERVER ERRORNOT IMPLEMENTEDEnviar 05 - O que faz a seguinte fixture <pre><code>@pytest.fixture\ndef client():\n    return TestClient(app)\n</code></pre> Faz uma requisi\u00e7\u00e3o a aplica\u00e7\u00e3o Cria um cliente de teste reutiliz\u00e1vel Faz o teste automaticamente Enviar 06 - Qual c\u00f3digo de resposta deve ser enviado quando o recurso requerido n\u00e3o for encontrado?201404401500Enviar 07 - Sobre o relacionamento dos schemas, qual seria a resposta esperada pelo cliente em UserList? <pre><code>class UserPublic(BaseModel):\n    username: str\n    email: str\n\n\nclass UserList(BaseModel):\n    users: list[UserPublic]\n</code></pre> {\"users\": {\"username\": \"string\", \"email\": \"e@mail.com\"}} {\"users\": [{\"username\": \"string\", \"email\": \"e@mail.com\"}]} As duas est\u00e3o corretas Enviar 08 - HTTPException tem a fun\u00e7\u00e3o de:Criar um erro de servidorRetornar um erro ao clienteFazer uma valida\u00e7\u00e3o HTTPEnviar 09 - 'users/{user_id}' permite:Parametrizar a URLPedir por um recurso com id espec\u00edficoAumentar a flexibilidade dos endpointsEnviar 10 - Qual a fun\u00e7\u00e3o desse bloco de c\u00f3digo nos endpoints de PUT E DELETE? <pre><code>if user_id &gt; len(database) or user_id &lt; 1:\n    raise HTTPException(\n        status_code=HTTPStatus.NOT_FOUND, detail='User not found'\n    )\n</code></pre> Garantir que s\u00f3 sejam chamados id v\u00e1lidos Montar um novo schema do pydantic Criar um erro de servidor Enviar"},{"location":"quizes/aula_04/","title":"Aula 04","text":"04 - Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic 01 - Qual a fun\u00e7\u00e3o do sqlalchemy em nosso projeto?Gerenciar a conex\u00e3o com o banco de dadosRepresentar o modelo dos dados como objetosFazer busca de dados no bancoTodas as alternativasEnviar 02 - O Registry do sqlalchemy tem a fun\u00e7\u00e3o de:Criar um schema de valida\u00e7\u00e3o da APICriar um objeto que representa a tabela no banco de dadosCriar um registro no banco de dadosEnviar 03 - Qual a fun\u00e7\u00e3o do objeto Mappedexecutar a fun\u00e7\u00e3o map do python no banco de dadosCriar uma rela\u00e7\u00e3o entre o tipo de dados do python e o da tabela do bancoDizer qual o tipo de dado que ter\u00e1 no banco de dadosFazer uma convers\u00e3o para tipos do pythonEnviar 04 - O que faz a fun\u00e7\u00e3o mapped_column?Indicar valores padr\u00f5es para as colunasCriar indicadores de SQL no objetoAdiciona restri\u00e7\u00f5es referentes a coluna no banco de dadosTodas as anterioresEnviar 05 - Qual a fun\u00e7\u00e3o do mapped_column no seguinte c\u00f3digo: <pre><code>quiz: Mapped[str] = mapped_column(unique=True)\n</code></pre> O valor de quiz deve ser \u00fanico na coluna Este campo \u00e9 o \u00fanico da tabela A tabela s\u00f3 tem um campo S\u00f3 \u00e9 poss\u00edvel inserir um valor \u00fanico nesse campo Enviar 06 - O que significa init=False no mapeamento?Diz que a coluna n\u00e3o deve ser iniciada no bancoToma a responsabilidade do preenchimento do campo para o SQLAlchemyDiz que existe um valor padr\u00e3o na colunaEnviar 07 - O m\u00e9todo \"scalar\" da session tem o objetivo de: <pre><code>session.scalar(select(User).where(User.username == 'Quiz'))\n</code></pre> Executar uma query no banco de dados Retornar somente um resultado do banco Converter o resultado da query em um objeto do modelo Todas as alternativas est\u00e3o corretas Enviar 08 - A fun\u00e7\u00e3o \"select\" tem o objetivo de: <pre><code>session.scalar(select(User).where(User.username == 'Quiz'))\n</code></pre> Executar uma busca no banco de dados Selecionar objetos 'User' no projeto Montar uma query de SQL Criar um filtro de busca Enviar 09 - Qual o objetivo do arquivo .env?Isolar vari\u00e1veis do ambiente do c\u00f3digo fonteCriar vari\u00e1veis no ambiente virtualCriar vari\u00e1veis globais no projetoEnviar 10 - As migra\u00e7\u00f5es t\u00eam a fun\u00e7\u00e3o de:Refletir as tabelas do banco de dados no ORMCriar tabelas no banco de dadosRefletir as classes do ORM no banco de dadosCriar um banco de dadosEnviar"},{"location":"quizes/aula_05/","title":"Aula 05","text":"05 - Integrando Banco de Dados a API 01 - Qual a fun\u00e7\u00e3o de adicionarmos a fun\u00e7\u00e3o \"Depends\" no seguinte c\u00f3digo: <pre><code>@app.post('/users/', status_code=HTTPStatus.CREATED, response_model=UserPublic)\ndef create_user(\n    user: UserSchema,\n    session: Session = Depends(get_session)\n):\n</code></pre> Indicar que a fun\u00e7\u00e3o depende de algo Documentar no schema os dados que s\u00e3o requeridos para chamar o endpoint Executar a fun\u00e7\u00e3o 'get_session' e passar seu resultado para fun\u00e7\u00e3o Indicar que a fun\u00e7\u00e3o 'get_session' tem que ser executada antes da 'create_user' Enviar 02 - Sobre a inje\u00e7\u00e3o na fixture podemos afirmar que: <pre><code>with TestClient(app) as client:\n    app.dependency_overrides[get_session] = get_session_override\n    yield client\n\napp.dependency_overrides.clear()\n</code></pre> Ela remover\u00e1 depend\u00eancia do c\u00f3digo durante a execu\u00e7\u00e3o do teste Ser\u00e1 feita a sobreescrita de uma dependencia por outra durante o teste A depend\u00eancia 'get_session' ser\u00e1 for\u00e7ada durante o teste Enviar 03 - Essa fixture no banco de dados garante que: <pre><code>@pytest.fixture\ndef session():\n    engine = create_engine(\n        'sqlite:///:memory:',\n        connect_args={'check_same_thread': False},\n        poolclass=StaticPool,\n    )\n</code></pre> O banco de dados estar\u00e1 em mem\u00f3ria N\u00e3o ser\u00e1 executada a verifica\u00e7\u00e3o entre a thread do banco e do teste Ser\u00e1 usado um pool de tamanho fixo Criar\u00e1 uma conex\u00e3o com o banco de dados para usar nos testes todas as alternativas anteriores Enviar 04 - Para que o cliente requisite o campo \"limit\" ele deve usar a url: <pre><code>@app.get('/users/', response_model=UserList)\ndef read_users(\n    skip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\n</code></pre> /users/?limit=10 /users/limit/10 /users/limit=10? /users/&amp;limit=10 Enviar 05 - Quais os padr\u00f5es de projeto implementados pela Session?Reposit\u00f3rioUnidade de trabalhoCompositeProxyEnviar 06 - O que faz o m\u00e9todo session.commit()?Faz um commit no gitPersiste os dados no banco de dadosExecuta as transa\u00e7\u00f5es na sess\u00e3oAbre uma conex\u00e3o com o banco de dadosEnviar 07 - O que faz o m\u00e9todo session.refresh(obj)?Atualiza a conex\u00e3o com o banco de dadosAtualiza dos dados da sess\u00e3oSincroniza o objeto do ORM com o banco de dadosSincroniza a sess\u00e3o com o banco de dadosEnviar 08 - O que o \"|\" siginifica na query? <pre><code>session.scalar(\n    select(User).where(\n        (User.username == user.username) | (User.email == user.email)\n    )\n)\n</code></pre> user.username 'E' user.email user.username 'SEM' user.email user.username 'OU' user.email user.username 'COM' user.email Enviar 09 - Quando usamos o m\u00e9todo 'model_validate' de um schema do Pydantic estamos:Validando um JSON com o modeloValidando um request com o modeloConverte um objeto em um schemaCoverte um objeto em JSONEnviar 10 - Quando usamos 'model_config' em um schema do Pydantic estamos:Alterando o comportamento de 'model_validate'Adicionando mais um campo de valida\u00e7\u00e3oAlterando a estrutura do modeloEnviar"},{"location":"quizes/aula_06/","title":"Aula 06","text":"06 - Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT 01 - Qual a fun\u00e7\u00e3o da 'pwdlib' em nosso projeto?Criar um hash da senhaVerificar se o texto limpo bate com o texto sujoSalvar as senhas em texto limpoFazer valida\u00e7\u00e3o das senhasEnviar 02 - Qual a necessidade de adicionar a linha em destaque no endpoint de PUT? <pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\n# ...\n    db_user.username = user.username\n    db_user.password = get_password_hash(user.password)\n    db_user.email = user.email\n</code></pre> Validar a senha no momento do update Criar o hash da senha durante a atualiza\u00e7\u00e3o Pegar a senha antiga durante o update Salvar a senha de forma limpa no banco de dados Enviar 03 - Qual o prop\u00f3sito da autentica\u00e7\u00e3o?Fornecer um mecanismo de tokensValidar que o cliente \u00e9 quem diz serGarantir que s\u00f3 pessoas autorizadas possam executar a\u00e7\u00f5esEnviar 04 - Qual a fun\u00e7\u00e3o do endpoint '/token'?Gerenciar a autoriza\u00e7\u00e3o do clienteFazer a autentica\u00e7\u00e3o do clienteRenovar o token JWTTodas as respostas est\u00e3o corretasEnviar 05 - O 'OAuth2PasswordRequestForm' fornece:Um formul\u00e1rio de cadastroUm formul\u00e1rio de autentica\u00e7\u00e3oUm formul\u00e1rio de autoriza\u00e7\u00e3oUm formul\u00e1rio de altera\u00e7\u00e3o de registroEnviar 06 - Qual a fun\u00e7\u00e3o do token JWT?Fornecer informa\u00e7\u00f5es sobre o cliente para o servidorGerenciar o tempo de validade do tokenCarregar dados sobre autoriza\u00e7\u00e3oTodas as respostas est\u00e3o corretasEnviar 07 - Qual o objetivo da claim 'sub'?Guardar o tempo de validade do tokenIdentificar o servidor que gerou o tokenIdentificar qual cliente gerou o tokenIdentificar o email do clienteEnviar 08 - Qual a fun\u00e7\u00e3o da 'secret_key'?Usar como base para criptografar a senha do cliente com Argon2Usar como base para gera\u00e7\u00e3o do HTTPSUsar como base para assinar o Token com HS256Enviar 09 - Qual o objetivo da fun\u00e7\u00e3o 'get_current_user'?Gerenciar a autentica\u00e7\u00e3o dos clientesValidar o token JWTGerenciar a autoriza\u00e7\u00e3o dos endpointsSaber que \u00e9 o usu\u00e1rio logadoEnviar 10 - Qual o objetivo da claim 'exp'?Dizer se o token est\u00e1 autorizadoEspecificar o nome do usu\u00e1rioDefinir o tempo de cria\u00e7\u00e3o do tokenTransmitir o tempo de expira\u00e7\u00e3o do tokenEnviar"},{"location":"quizes/aula_07/","title":"Aula 07","text":"07 - Refatorando a Estrutura do Projeto 01 - Quais s\u00e3o as fun\u00e7\u00f5es do \"Router\" do FastAPICriar uma \"sub-aplica\u00e7\u00e3o\"Isolar endpoints por dom\u00ednioFacilitar a manuten\u00e7\u00e3o do c\u00f3digoMelhorando o desempenho da aplica\u00e7\u00e3oEnviar 02 - Sobre o par\u00e2metro \"prefix\" do router, podemos afirmar que:Adicionar os endpoints no roteadorFazer as chamadas unificadas do enpoint Padronizar um prefixo para N endpointsEnviar 03 - Qual a fun\u00e7\u00e3o do par\u00e2metro 'tag' nos routers?Dizer quais par\u00e2metros devem ser passados ao endpointsColocar um prefixo nos endpointsAgrupar os endpoins do mesmo dom\u00ednio na documenta\u00e7\u00e3oAdicionar cores diferentes no swaggerEnviar 04 - Qual a fun\u00e7\u00e3o do tipo \"Annotated\" no FastAPI!Reduzir o tamanho das fun\u00e7\u00f5esReutilizar anota\u00e7\u00f5es em N endpointsAtribuir metadados aos tiposTodas as alternativasEnviar 05 - O que o \"Annotated\" faz nesse c\u00f3digo? <pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef endpoint(session: Annotated[Session, Depends(get_session)])\n</code></pre> Diz que o par\u00e2metro 'session' \u00e9 do tipo 'Session' e depende de 'get_session' Diz que o par\u00e2metro 'session' \u00e9 do tipo 'Annotated' Faz a troca de 'session' por 'Session' Enviar 06 - O que o \"include_router\" faz nesse c\u00f3digo? <pre><code>app = FastAPI()\n\napp.include_router(users.router)\n</code></pre> Adiciona as rotas definidas do router 'users' Cria um novo app fastAPI para o router Substitui as rotas existentes pelas rotas de 'users' Exclui as rotas de 'users' da aplica\u00e7\u00e3o Enviar 07 - O que faz \"Annotated[FilterPage, Query()]\" no nosso endpoint?Ignora par\u00e2metros passados que n\u00e3o estejam em `FilterPage`Adiciona os campos de `FilterPage` na documenta\u00e7\u00e3oValida os tipos e valores passados via querystringTransforma os par\u00e2metros de `FilterPage` em querystringEnviar 08 - Qual o impacto das constantes movidas para a classe \"Settings\"?Excluir a necessidade um arquivo .envPode alterar configura\u00e7\u00f5es sem alterar o c\u00f3digo fontePoder alterar os valores das contantes em tempo de execu\u00e7\u00e3oSimplificar as chamadas de c\u00f3digoEnviar 09 - Por qual motivo dividimos a aplica\u00e7\u00e3o em routers?Melhorar o desempenho da aplica\u00e7\u00e3oMelhorar a organiza\u00e7\u00e3o do c\u00f3digoFacilitar a manuten\u00e7\u00e3oTodas as alternativas est\u00e3o corretasEnviar 10 - Por qual motivo \"read_root\" n\u00e3o foi migrado para nenhum router?\u00c9 s\u00f3 um exemplo de c\u00f3digoPor que ela retorna HTMLN\u00e3o pertence a nenhum dom\u00ednio dos routers em espec\u00edficoPor que n\u00e3o faz uso de SessionEnviar"},{"location":"quizes/aula_08/","title":"Aula 08","text":"08 - Tornando o projeto ass\u00edncrono 01 - Escalonamento no asyncio \u00e9 a capacidade do c\u00f3digo de:Executar tarefas simultaneamenteAlternar entre a execu\u00e7\u00e3o de fun\u00e7\u00f5esFazer com que o c\u00f3digo seja bloqueanteAlternar entre a execu\u00e7\u00e3o de corrotinasEnviar 02 - Dizemos que um c\u00f3digo \u00e9 cooperativo quando:Quando ele cede a vez para outro c\u00f3digo ser executadoQuando ele usa a palavra reservada awaitQuando ele permite ser escalonadoQuando ele usa async defEnviar 03 - Sobre o uso de await no c\u00f3digo, podemos afirmar que: <pre><code>@pytest.mark.asyncio \nasync def test_create_user(session, mock_db_time):\n    with mock_db_time(model=User) as time:\n        new_user = User(\n            username='alice', password='secret', email='teste@test'\n        )\n        session.add(new_user)\n        await session.commit() \n</code></pre> Permite escalonamento durante a comunica\u00e7\u00e3o com o banco de dados Bloqueia a execu\u00e7\u00e3o at\u00e9 que o commit seja conclu\u00eddo Cria uma nova corrotina Faz coopera\u00e7\u00e3o com o banco de dados Enviar 04 - Qual a fun\u00e7\u00e3o do loop de eventos?Gerenciar a execu\u00e7\u00e3o de corrotinas de maneira ordenadaExecutar corrotinas simultaneamenteEscalonar entre c\u00f3digo cooperativoTornar a execu\u00e7\u00e3o n\u00e3o bloqueanteEnviar 05 - Qual a necessidade de usarmos \"asyncio.run\"? <pre><code>run(corrotina())\n</code></pre> Executar tarefas n\u00e3o bloqueantes de forma n\u00e3o bloqueante Bloquear o c\u00f3digo durante execu\u00e7\u00f5es n\u00e3o bloqueantes Tonar a execu\u00e7\u00e3o de fun\u00e7\u00f5es s\u00edncronas em ass\u00edncronas Enviar 06 - Qual a fun\u00e7\u00e3o do greenlet no projeto?Permitir que o SQLAlchemy fa\u00e7a programa\u00e7\u00e3o ass\u00edncronaPermitir que o coverage cubra fun\u00e7\u00f5es asyncSubstituir o asyncioCriar loops de eventosEnviar 07 - Qual a fun\u00e7\u00e3o da flag \"-k\" no pytest?Executar todos os testes com nomes correspondentes a flagListar todos os testes que podem ser executadosMatar (kill) todos os testes que n\u00e3o funcionaremPausar a execu\u00e7\u00e3o dos testes caso um falheEnviar 08 - Qual a fun\u00e7\u00e3o de \"pytest_asyncio.fixture\" no c\u00f3digo? <pre><code>@pytest_asyncio.fixture\nasync def session():\n    # ...\n</code></pre> Cria uma fixture bloqueante Cria uma fixture que s\u00f3 pode ser usada em testes ass\u00edncronos Cria uma fixture executada pelo loop de eventos Enviar 09 - Ao que se refere \"expire_on_commit=False\" na cria\u00e7\u00e3o da sess\u00e3o? <pre><code>async def get_session():\n    async with AsyncSession(engine, expire_on_commit=False) as session: \n        yield session\n</code></pre> Expira os dados n\u00e3o commitados N\u00e3o limpa a sess\u00e3o ap\u00f3s o commit Cria uma sess\u00e3o com tempo de vida Enviar 10 - Adicionar \"async def\" ao c\u00f3digo cria:Uma fun\u00e7\u00e3o ass\u00edncronaUma corrotinaUm loop de eventosUm c\u00f3digo bloqueanteEnviar"},{"location":"quizes/aula_09/","title":"Aula 09","text":"09 - Tornando o sistema de autentica\u00e7\u00e3o robusto 01 - Sobre o Factory-boy. O que siginifica a classe Meta? <pre><code>class UserFactory(factory.Factory):\n    class Meta:\n        model = User\n</code></pre> Diz que ser\u00e1 usada uma metaclasse Explica ao Factory qual objeto ele deve se basear Extente a classe Factory com os par\u00e2metros de Meta Enviar 02 - Ainda sobre o Factory-boy. O que siginifica \"factory.Sequence\"?Criar\u00e1 uma sequ\u00eancia de MetasAdicionar\u00e1 +1 em cada objeto criadoMonta uma sequ\u00eancia de objetosCria um novo objeto do factoryEnviar 03 - Ainda sobre o Factory-boy. O que siginifica \"factory.LazyAttribute\"?Diz que o atributo ser\u00e1 criado em tempo de execu\u00e7\u00e3oDiz que o atributo usar\u00e1 outros atributos para ser inicializadoUsa outros campos para ser compostoCria um atributo independ\u00eanteEnviar 04 - O que faz o gerenciador de contexto \"freeze_time\"? <pre><code>with freeze_time('2023-07-14 12:00:00'):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n</code></pre> Pausa o tempo nas instru\u00e7\u00f5es dentro do 'with' Congela o tempo da fun\u00e7\u00e3o toda Muda a hora do computador para um bloco Enviar 05 - O que levanta o erro \"ExpiredSignatureError\"?Quando deu erro no valor de 'exp'Quando n\u00e3o deu certo avaliar a claim de 'exp'Quando a claim de 'exp' tem um tempo expiradoEnviar"},{"location":"quizes/aula_10/","title":"Aula 10","text":"10 - Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI 01 - Qual o papel da classe 'TodoState' em nosso c\u00f3digo?Fornece m\u00e9todos para gerar IDs sequenciais para tarefas.Armazena o hist\u00f3rico de altera\u00e7\u00f5es das tarefas ao longo do tempo.Permite a cria\u00e7\u00e3o de tarefas com diferentes n\u00edveis de prioridade.Tipo com valores nomeados e constantes para representar estados de tarefas.Enviar  A classe `TodoState` define estados de tarefas (rascunho, pendente, etc.) com nomes claros, facilitando o c\u00f3digo e garantindo seguran\u00e7a e agilidade na manuten\u00e7\u00e3o. 02 - Qual o significado da rela\u00e7\u00e3o `user: Mapped[User] = relationship(...)` em nosso modelo?Define conex\u00e3o entre usu\u00e1rios e tarefas (N:N) com lista inicializada e acesso bidirecional.Estabelece rela\u00e7\u00e3o entre usu\u00e1rios e tarefas (1:N) com lista n\u00e3o inicializada e acesso bidirecional.Cria v\u00ednculo entre usu\u00e1rios e tarefas (1:1) com lista n\u00e3o inicializada e acesso unidirecional.Estabelece rela\u00e7\u00e3o entre usu\u00e1rios e tarefas (1:N) com lista inicializada e acesso unidirecional.Enviar  A rela\u00e7\u00e3o `user: Mapped[User] = relationship(...)` define uma conex\u00e3o 1:N entre usu\u00e1rios e tarefas, permitindo que um usu\u00e1rio tenha v\u00e1rias tarefas e cada tarefa esteja ligada a um \u00fanico usu\u00e1rio. A lista de tarefas n\u00e3o \u00e9 inicializada automaticamente e as entidades podem se acessar mutuamente. 03 - Qual o significado do par\u00e2metro de consulta `state: str | None = None` no endpoint de busca?Permite filtrar resultados por valor de string obrigat\u00f3rio ('state'), n\u00e3o aceitando None.Filtra resultados por estado ('state'), com valor padr\u00e3o 'pendente' se n\u00e3o especificado.Habilita filtro por 'state' (string ou None), com valor padr\u00e3o None se n\u00e3o especificado.Cria um par\u00e2metro opcional 'state' que recebe floats para filtrar resultados.Enviar  O par\u00e2metro `state: str | None = None` no FastAPI permite filtrar resultados por um valor de string opcional ('state'), que pode ser None por padr\u00e3o. 04 - Qual a fun\u00e7\u00e3o do `FuzzyChoice` no Factory Boy?Gera valores aleat\u00f3rios para cada atributo de um objeto de teste, facilitando a cria\u00e7\u00e3o de testes.Cria objetos de teste com valores predefinidos a partir de um conjunto de op\u00e7\u00f5es.Gera dados de teste aleat\u00f3rios e realistas, facilitando a cria\u00e7\u00e3o de testes de unidade robustos.Permite a gera\u00e7\u00e3o de dados de teste aleat\u00f3rios e realistas para diferentes tipos de dados.Enviar  O `FuzzyChoice` do Factory Boy gera valores aleat\u00f3rios a partir de um conjunto predefinido, criando objetos de teste com dados realistas e facilitando testes de unidade robustos. 05 - Qual a fun\u00e7\u00e3o da classe `Meta` no Factory Boy?Definir um modelo base a ser usado no factoryDefinir o comportamento de como as inst\u00e2ncias de factory devem ser salvas no bancoControlar os valores padr\u00e3o para os campos do modelo durante a cria\u00e7\u00e3o dos objetosCriar inst\u00e2ncias de f\u00e1brica de forma an\u00f4nima sem vincular a um modelo espec\u00edficoEnviar 06 - Quando chamamos \"TodoFactory.create_batch\" o que estamos fazendo?Criando N inst\u00e2ncias de TodoModificando atributos espec\u00edficos de uma inst\u00e2ncia de TodoSalvando as inst\u00e2ncias de Todo diretamente no banco de dadosCriando uma \u00fanica inst\u00e2ncia de Todo de forma ass\u00edncronaEnviar 07 - Qual a fun\u00e7\u00e3o do `session.add_all` nos testes de todo?Salvar diversos objetos de uma vez no banco de dadosAdicionar objetos diretamente \u00e0 tabela do banco sem passar pela sessionInserir uma lista de objetos na sessionAtualizar objetos existentes na sessionEnviar 08 - Qual a fun\u00e7\u00e3o do `exclude_unset=True` no c\u00f3digo abaixo? <pre><code>@router.patch('/{todo_id}', response_model=TodoPublic)\ndef patch_todo(\n    todo_id: int, session: Session, user: CurrentUser, todo: TodoUpdate\n):\n    # ...\n    for key, value in todo.model_dump(exclude_unset=True).items():\n        setattr(db_todo, key, value)\n</code></pre> Exclui os valores que n\u00e3o fazem parte do schema Exclui os valores que n\u00e3o foram passados para o schema Exclui os valores que s\u00e3o None no schema Enviar 09 - No schema \"TodoUpdate\" por que todos os valores s\u00e3o opcionais? <pre><code>class TodoUpdate(BaseModel):\n    title: str | None = None\n    description: str | None = None\n    state: TodoState | None = None\n</code></pre> Porque todos os campos t\u00eam valores padr\u00e3o definidos Porque a classe \u00e9 derivada de uma classe base que permite campos opcionais Porque os tipos dos campos permitem o valor None, tornando-os opcionais Porque a classe utiliza um modelo de valida\u00e7\u00e3o ass\u00edncrona Enviar 10 - O que a querystring \"?title=Test todo 1\" quer dizer? <pre><code>response = client.get(\n    '/todos/?title=Test todo 1',\n    headers={'Authorization': f'Bearer {token}'},\n)\n</code></pre> Que o t\u00edtulo da todo ser\u00e1 atualizado para 'Test todo 1' Que a busca retornar\u00e1 todos os itens com t\u00edtulo que sejam iguais 'Test todo 1' Que a resposta ser\u00e1 um erro, pois o par\u00e2metro 'title' \u00e9 obrigat\u00f3rio Que a busca retornar\u00e1 todos os itens com t\u00edtulo que contenham 'Test todo 1' Enviar"},{"location":"quizes/aula_11/","title":"11 - Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":""},{"location":"quizes/aula_11/#11-dockerizando-a-nossa-aplicacao-e-introduzindo-o-postgresql","title":"11 - Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":"01 - Qual a fun\u00e7\u00e3o do arquivo `Dockerfile`?Definir a rede que o cont\u00eainer usar\u00e1Especificar as instru\u00e7\u00f5es necess\u00e1rias para criar uma imagem Docker personalizadaGerenciar o armazenamento de dados dentro do cont\u00eainerDefinir o nome do cont\u00eainer que ser\u00e1 criadoEnviar 02 - Por que usamos a instru\u00e7\u00e3o `FROM python:3.11-slim` no dockerfile?Para criar uma imagem baseada no sistema operacional WindowsPara definir a imagem base do Docker como uma vers\u00e3o do Python 3.11Para instalar o Python 3.11 no cont\u00eainer diretamentePara baixar a vers\u00e3o mais recente do Python no reposit\u00f3rio oficialEnviar 03 - Qual a fun\u00e7\u00e3o do arquivo `compose.yaml`?Subir a aplica\u00e7\u00e3o de forma simplesEspecificar os servi\u00e7os e como eles se relacionamSubstituir o DockerfileCriar uma container dockerEnviar 04 - Qual instru\u00e7\u00e3o do Dockerfile o `entrypoint` substitui?O comando de execu\u00e7\u00e3o (CMD)A defini\u00e7\u00e3o da imagem base (FROM)A exposi\u00e7\u00e3o das portas (EXPOSE)Enviar 05 - O que quer dizer escopo nas fixtures?Em quais testes elas v\u00e3o atuarSe um m\u00f3dulo pode usar aquela fixtureQual a dura\u00e7\u00e3o da fixtureCapturar as vari\u00e1veis de ambienteEnviar 06 - Por que usamos o escopo de \"session\" na fixture?Pra dizer que ela vai substituir a fixture de sessionCriar uma sess\u00e3o do cliente com o banco de dadosDizer que a fixture tem a dura\u00e7\u00e3o de um testeDizer que a fixture ser\u00e1 executada uma \u00fanica vez durante os testesEnviar 07 - Para que serve o volume no docker?Para armazenar as imagens geradasPara adicionar um banco de dadosPara armazenar o cache do dockerPara persistir arquivos na m\u00e1quina hostEnviar 08 - O que faz a flag `-it` no CLI do docker?Conecta o container na internetRoda o container no modo interativoConfigura a rede do dockerPassa as vari\u00e1veis de ambienteEnviar 09 - Por que precisamos usar o TestContainers no projeto?Para executar os testes dentro de containersPara testar os containers da aplica\u00e7\u00e3oPara criar imagens durante o testePara iniciar containers durante o testeEnviar 10 - Qual a raz\u00e3o de termos instalado a biblioteca `psycopg` no projeto?Para permitir a conex\u00e3o entre o banco de dados e o dockerPara permitir a conex\u00e3o com bancos de dados SQLitePara fornecer suporte a opera\u00e7\u00f5es de arquivo no sistemaPara permitir a conex\u00e3o com bancos de dados PostgreSQL no projetoEnviar"},{"location":"quizes/aula_12/","title":"12 - Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":""},{"location":"quizes/aula_12/#12-automatizando-os-testes-com-integracao-continua-ci","title":"12 - Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"01 - Qual a fun\u00e7\u00e3o da integra\u00e7\u00e3o cont\u00ednua?Proibir que c\u00f3digo que n\u00e3o funciona seja commitadoVerificar se a integra\u00e7\u00e3o das altera\u00e7\u00f5es foi bem sucedidaImpedir que pessoas de fora integrem c\u00f3digo em nosso reposit\u00f3rioIntegrar novos commits ao reposit\u00f3rioEnviar A integra\u00e7\u00e3o cont\u00ednua tem como objetivo garantir que as mudan\u00e7as feitas no c\u00f3digo sejam integradas de maneira cont\u00ednua e automatizada, verificando se n\u00e3o houve falhas nas integra\u00e7\u00f5es e garantindo a funcionalidade do c\u00f3digo no reposit\u00f3rio. 02 - O que \u00e9 o Github Actions?Uma aplica\u00e7\u00e3o que executa os testes localmenteUm test runner como o pytestForma de integrar o github com outras aplica\u00e7\u00f5esUm servi\u00e7o do github para CIEnviarO GitHub Actions \u00e9 um servi\u00e7o oferecido pelo GitHub para automatizar fluxos de trabalho de integra\u00e7\u00e3o cont\u00ednua e entrega cont\u00ednua (CI/CD) diretamente no reposit\u00f3rio do GitHub. 03 - O que \u00e9 um workflow de CI?Uma lista de passos que o CI deve executarUma automa\u00e7\u00e3o executada sempre c\u00f3digo \u00e9 adicionado ao resposit\u00f3rioUma forma de versionar software como o gitPassos que ser\u00e3o executados antes do commitEnviarUm workflow de CI \u00e9 uma sequ\u00eancia de passos autom\u00e1ticos definidos em um arquivo YAML, que s\u00e3o executados sempre que mudan\u00e7as no c\u00f3digo s\u00e3o enviadas para o reposit\u00f3rio, garantindo que o c\u00f3digo esteja sempre em funcionamento. 04 - Quando o nosso trigger de CI \u00e9 ativado?Sempre que fazemos um pushSempre que criamos um pull requestSempre que um commit \u00e9 feitoSempre que uma issue \u00e9 abertaEnviarO trigger de CI \u00e9 ativado por eventos como push e pull request, que indicam que mudan\u00e7as no c\u00f3digo foram feitas e precisam ser verificadas automaticamente. 05 - Nos steps, o que quer dizer \"uses\"?Diz que vamos usar uma action prontaDiz que vamos executar uma instru\u00e7\u00e3o de shellQue vamos fazer a instala\u00e7\u00e3o de um componente no workflowFazer checkout do c\u00f3digo do reposit\u00f3rioEnviarQuando usamos \"uses\" em um step, estamos referenciando uma action j\u00e1 pronta, geralmente fornecida pela comunidade ou pelo pr\u00f3prio GitHub, para ser executada automaticamente no workflow. 06 - Nos steps, o que quer dizer \"run\"?Que vamos usar uma action pronta do githubServe para dizer que vamos usar um passoDefinir uma vari\u00e1vel de ambienteDiz que vamos executar uma instru\u00e7\u00e3o de shellEnviarO comando \"run\" permite executar comandos ou instru\u00e7\u00f5es diretamente no sistema operacional do ambiente de CI, como comandos de shell, scripts ou outras tarefas programadas. 07 - Qual a fun\u00e7\u00e3o das \"secrets\" no arquivo yaml?Criar vari\u00e1veis de ambienteN\u00e3o expor dados sens\u00edveis no arquivo de ciSubstituir vari\u00e1veis \u200b\u200bcom valores din\u00e2micosOrganizar o c\u00f3digo YAMLEnviarAs \"secrets\" no GitHub Actions s\u00e3o usadas para armazenar informa\u00e7\u00f5es sens\u00edveis, como senhas ou chaves de API, de maneira segura, sem exp\u00f4-las diretamente no arquivo YAML. 08 - O que faz o comando \"gh secret set\"?Ele adiciona um novo reposit\u00f3rio ao GitHub.Ele define um segredo no GitHub para ser usado em GitHub Actions.Ele atualiza o reposit\u00f3rio com novas permiss\u00f5es de acesso.Ele cria um novo reposit\u00f3rio no GitHub.EnviarO comando \"gh secret set\" \u00e9 utilizado para criar e definir segredos no reposit\u00f3rio GitHub, que podem ser utilizados no GitHub Actions para a\u00e7\u00f5es que requerem dados sens\u00edveis. 09 - O que deve ser declarado na chave \"env\" do arquivo de pipeline?O nome do reposit\u00f3rio.Vari\u00e1veis de ambiente que ser\u00e3o utilizadas no pipeline.O nome dos branches no reposit\u00f3rio.Os usu\u00e1rios que t\u00eam acesso ao reposit\u00f3rio.EnviarA chave \"env\" define vari\u00e1veis de ambiente no pipeline, as quais ser\u00e3o utilizadas durante a execu\u00e7\u00e3o do workflow para armazenar valores din\u00e2micos e facilitar o processo de automa\u00e7\u00e3o. 10 - O que deve ser declarado na chave \"runs-on\" do arquivo de pipeline?O n\u00famero de jobs que ser\u00e3o executados.O sistema operacional ou ambiente onde o workflow ser\u00e1 executado.O nome do reposit\u00f3rio de onde o c\u00f3digo ser\u00e1 puxado.O nome do servi\u00e7o de CI/CD que ir\u00e1 rodar o pipeline.EnviarA chave \"runs-on\" especifica o ambiente ou sistema operacional onde o workflow ser\u00e1 executado, como Ubuntu, Windows ou macOS."},{"location":"quizes/aula_13/","title":"13 - Fazendo deploy no Fly.io","text":""},{"location":"quizes/aula_13/#13-fazendo-deploy-no-flyio","title":"13 - Fazendo deploy no Fly.io","text":"01 - O que \u00e9 fazer \"deploy\"?Colocar a aplica\u00e7\u00e3o em produ\u00e7\u00e3oExecutar os testes da aplica\u00e7\u00e3oExecutar a aplica\u00e7\u00e3o localmenteFazer o processo de integra\u00e7\u00e3o cont\u00ednuaEnviar 02 - O quer dizer \"PaaS\"?Software como servi\u00e7oUm local para subir a aplica\u00e7\u00e3oSoftwares como o githubPlataforma como servi\u00e7oEnviar 03 - O que \u00e9 o Fly.io?Uma plataforma de c\u00f3digoUma plataforma de versionamentoUma plataforma de CloudUma plataforma de integra\u00e7\u00e3o cont\u00ednuaEnviar 04 - Para que usamos o \"flyctl\"?Para fazer o login no flyPara nos comunicarmos com o fly via terminalPara fazer deploy da aplica\u00e7\u00e3oPara fazer o build do containerEnviar"}]}