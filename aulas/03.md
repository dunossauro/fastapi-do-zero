---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento bÃ¡sico sobre API, HTTP, JSON e a estrutura do projeto
---

# Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na validaÃ§Ã£o e serializaÃ§Ã£o de dados
- ImplementaÃ§Ã£o de rotas CRUD em FastAPI
- Escrita e execuÃ§Ã£o de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em vÃ­deo"
	Esse aula ainda nÃ£o estÃ¡ disponÃ­vel em formato de vÃ­deo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[CÃ³digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

Boas-vindas de volta Ã  nossa construÃ§Ã£o de uma aplicaÃ§Ã£o usando FastAPI. Na Ãºltima aula conversamos sobre alguns conceitos bÃ¡sicos do desenvolvimento WEB e terminamos de configurar nosso ambiente. Nesta aula, daremos um passo adiante ao estruturarmos os primeiros endpoints da nossa API, focando nas quatro operaÃ§Ãµes bÃ¡sicas de gerenciamento de usuÃ¡rios. Vamos abordar o **CRUD** - Criar, Ler, Atualizar e Deletar - e como essas operaÃ§Ãµes se aplicam tanto a comunicaÃ§Ã£o web, quanto com o banco de dados.

Nosso objetivo nessa aula Ã© implementar um sistema de cadastro de usuÃ¡rios para nossa aplicaÃ§Ã£o. O objetivo Ã© que possamos ao final dessa aula cadastrar, listar, alterar e deletar usuÃ¡rios da nossa aplicaÃ§Ã£o com a aplicaÃ§Ã£o de seus respectivos testes.

## CRUD e HTTP

No mundo do desenvolvimento de APIs, existem algumas operaÃ§Ãµes bÃ¡sicas que gostarÃ­amos de fazer com os dados. Essas operaÃ§Ãµes se relacionam com a base de dados e a aplicaÃ§Ã£o web. Vamos nos focar nesse primeiro momento nas relaÃ§Ãµes entre os dados.

CRUD Ã© um acrÃ´nimo que representa as quatro operaÃ§Ãµes bÃ¡sicas que vocÃª pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): adicionar novos registros ao banco de dados.
- **R**ead (Ler): recuperar registros existentes do banco de dados. 
- **U**pdate (Atualizar): modificar registros existentes no banco de dados.
- **D**elete (Excluir): remover registros existentes do banco de dados.

Com essa operaÃ§Ãµes podemos realizar qualquer tipo de comportamento dentro de uma base dados. Podemos criar um registro, em seguida altera-lo, quem sabe depois disso tudo deleta-lo.

Quando falamos de APIs servido dados, todas essa operaÃ§Ãµes tem alguma forma similar dentro do protocolo HTTP. O protocolo tem verbos para indicar essas mesmas aÃ§Ãµes que queremos representar no banco de dados.

- **POST**: Ã© usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.
- **GET**: Ã© usado para quando o cliente deseja requisitar uma informaÃ§Ã£o do servidor.
- **PUT**: Ã© usando no momento em que o cliente deseja informar alguma alteraÃ§Ã£o nos dados para o servidor.
- **DELETE**: usado para para dizer ao servidor que delete determinado recurso.

Dessa forma podemos criar associaÃ§Ãµes entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, nÃ³s como clientes devemos comunicar essa intenÃ§Ã£o ao servidor usando o mÃ©todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de *create* na base de dados.

### Respostas da API

A forma de responder o cliente como as operaÃ§Ãµes do CRUD se sucederam no servidor Ã© via cÃ³digos de status. Por isso vamos investir mais algum momento aqui.

Os cÃ³digos que devemos prestar atenÃ§Ã£o para responder de forma correta as requisiÃ§Ãµes. Os casos de sucesso incluem:

- **200 OK**: Para quando a requisiÃ§Ã£o obteve sucesso.
    - **GET**: Quando pedidos um dado e ele Ã© retornado com sucesso
	- **PUT**: Quando os dados sÃ£o alterados com sucesso
- **201 CREATED**: O pedido foi atendido, resultando na criaÃ§Ã£o de um novo recurso.
	- **POST**: Quando enviamos um dado e ele Ã© criado com sucesso
	- **PUT**: Quando enviamos na alteraÃ§Ã£o, mas ele nÃ£o existia e foi criado
- **204 NO CONTENT**: Retorno do servidor sem conteÃºdo na mensagem
	- **PUT**: Se a alteraÃ§Ã£o no banco nÃ£o retornar nada
	- **DELETE**: Se o ato de deletar nÃ£o retornar nada

Os cÃ³digos de erro mais comuns que temos que conhecer para lidar com possÃ­veis erros na aplicaÃ§Ã£o, sÃ£o:

- **404 NOT FOUND**: O recurso solicitado nÃ£o pÃ´de ser encontrado.
- **422 UNPROCESSABLE ENTITY**: o pedido foi bem formado (ou seja, sintaticamente correto), mas nÃ£o pÃ´de ser processado.
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro genÃ©rica, dada quando uma condiÃ§Ã£o inesperada foi encontrada. Geralmente ocorre quando nossa aplicaÃ§Ã£o apresenta um erro.

Agora que temos uma ideia melhor do que vamos receber e cada aÃ§Ã£o que isso implicarÃ¡. Podemos iniciar a escrita de alguns endpoints e aplicar todo esses conceitos na prÃ¡tica.

## Implementado endpoints

Acredito que para simplificar o aprendizado, podemos dividir a criaÃ§Ã£o de qualquer novo endpoint em trÃªs partes:

1. Sua relaÃ§Ã£o com o HTTP: qual verbo esperamos receber e quais cÃ³digos de resposta iremos retornar em caso de sucesso e erro.
2. Seus modelos de dados: qual o formato do JSON que esperamos receber? Quais os campos e quais seus tipos. TambÃ©m Ã© importante pensar no modelo de resposta. O que serÃ¡ retornado e qual situaÃ§Ã£o. Qual o modelo de sucesso e qual o modelo de erro.
3. ImplementaÃ§Ã£o do corpo: o que vamos fazer com os dados recebidos, qual tipo de processamento serÃ¡ aplicado a ele.

As partes 1 e 2 me ajudam a definir a interface de comunicaÃ§Ã£o e como isso ficarÃ¡ disponÃ­vel na documentaÃ§Ã£o. JÃ¡ a terceira Ã© uma escolha mais particular de como implementar, como chamaremos o banco de dados, existem mais validaÃ§Ãµes a fazer? O que exatamente define o sucesso ou o erro nessa requisiÃ§Ã£o?

Esses pequenos passos podem nos ajudar a nÃ£o esquecer nada na hora da implementaÃ§Ã£o do endpoint como um todo.


## Implementando a Rota POST

Como queremos fazer um cadastro de usuÃ¡rios nessa aula, a parte mais importante Ã© que tenhamos uma forma de criar um novo usuÃ¡rio na base de dados.

O Verbo POST Ã© comumente utilizado para informar o serviÃ§o que queremos enviar um dado. Nesse ponto todos os conceitos comumente se cruzam. Temos que ter um endpoint que aceite o verbo `POST` com dados (um JSON), que responda o status `201` como sucesso se o recurso for criado. Vamos iniciar por esse caminho e depois contemplaremos o que pode dar errado.

### ImplementaÃ§Ã£o do endpoint

Com o modelo definido podemos partir para criaÃ§Ã£o do nosso endpoint. para que o endpoint receba requisiÃ§Ãµes do verbo POST, podemos usar o mesmo formato do decorador do FastAPI, como `#!python @app.post()`.

Como o objetivo desse endpoint Ã© criar usuÃ¡rios na base de dados, vamos iniciar sua URL com `#!python '/users/'`. Pois Ã© onde receberemos dados para criÃ¡-los.

```python title="fast_zero/app.py" linenums="13"
@app.post('/users/')
def create_user():
	...
```

#### Status code de resposta

Temos que informar que quando nosso usuÃ¡rio for cadastrado com sucesso, retornarÃ¡ o cÃ³digo de resposta `201`. Para isso podemos passar o parÃ¢metro `status_code` para o decorador:

```python title="fast_zero/app.py" linenums="13" hl_lines="1"
@app.post('/users/', status_code=201)
def create_user():
    ...
```

> Conversaremos em breve sobre o cÃ³digo de resposta em [TODO: tÃ³pico do pydantic]

### Modelo de dados

Para que os dados sejam enviados para nossa aplicaÃ§Ã£o, devemos documentar o formato dos dados que esperamos receber. Para que quem use nossa aplicaÃ§Ã£o saiba quais os campos e os dados que devem ser enviados. Da mesma forma em que Ã© importante pensar e documentar no modelo de dados que serÃ¡ retornado ao cliente.

#### Modelo de entrada de dados

Vamos nos basear nesse modelo simples, onde precisamos de um nome de usuÃ¡rio `username`, o email no campo `email` e a senha no campo `password`. Isso serÃ¡ o suficiente para que um usuÃ¡rio se cadastre na nossa aplicaÃ§Ã£o. Algo como:

```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para que a aplicaÃ§Ã£o consiga expor esse modelo na documentaÃ§Ã£o, devemos criar uma classe do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`):

```python title="fast_zero/schemas.py" linenums="8"
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```

Agora que temos o status code configurado, temos que associar o modelo esperado na requisiÃ§Ã£o com o endpoint. Para fazer isso basta que o endpoint receba um parÃ¢metro e esse parÃ¢metro esteja associado a um modelo via anotaÃ§Ã£o de parÃ¢metros:

```python title="fast_zero/app.py" hl_lines="6"
from fast_zero.schemas import Message, UserSchema

# CÃ³digo do olÃ¡ mundo homitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    ...
```

Dessa forma o modelo de entrada, o que o endpoint espera receber jÃ¡ estÃ¡ documentado e aparecerÃ¡ no swagger UI.

Para visualizar, temos que iniciar o servidor:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task run
```

E acessar a pÃ¡gina [http://127.0.01:8000/docs](http://localhost:8000/docs). Isso nos mostrarÃ¡ as definiÃ§Ãµes do nosso endpoint usando o Swagger.

![descriÃ§Ã£o](assets/03/swagger_exibindo_o_schema_de_entrada_de_create_user.png){: .center }

#### Modelo de saÃ­da de dados
...

---

Com esse endpoint criado, podemos executar a nossa aplicaÃ§Ã£o:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task run
```

E acessar a pÃ¡gina [http://localhost:8000/docs](http://localhost:8000/docs). Isso nos mostrarÃ¡ as definiÃ§Ãµes do nosso endpoint usando o Swagger.

![descriÃ§Ã£o](assets/03/swagger.png){: .center }

Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.

![descriÃ§Ã£o](assets/03/swagger_com_request.png){: .center }

Entretanto, precisamos prestar atenÃ§Ã£o a um detalhe: nosso modelo retorna a senha do usuÃ¡rio, o que Ã© uma pÃ©ssima prÃ¡tica de seguranÃ§a.

![descriÃ§Ã£o](assets/03/respsota_do_swagger.png){: .center }

Para evitar isso, podemos criar um novo modelo que serÃ¡ usado somente para resposta. Dessa forma, nÃ£o expomos os dados que nÃ£o queremos na API:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Precisamos tambÃ©m dizer ao FastAPI que esse serÃ¡ o modelo de resposta, e converter nosso `user` em `UserPublic`:


```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# cÃ³digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Note que somente adicionando o `response_model`, o FastAPI jÃ¡ faz a conversÃ£o de `UserSchema` em `UserPublic`

Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.

![descriÃ§Ã£o](assets/03/swagger_sem_senha.png){: .center }

### Criando um banco de dados falso

Finalmente, para brincar com essas rotas, podemos criar uma lista provisÃ³ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provisÃ³ria para o "banco" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import UserSchema, UserPublic, UserDB

# cÃ³digo omitido

database = []  # provisÃ³rio para estudo!


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)

    database.append(user_with_id)

    return user_with_id
```

Se queremos uma simulaÃ§Ã£o de banco de dados, precisamos ter um `ID` para cada usuÃ¡rio registrado no nosso "banco". Sendo assim, alteraremos nosso modelo de resposta pÃºblica (`UserPublic`) para que ele forneÃ§a o ID de criaÃ§Ã£o do usuÃ¡rio. TambÃ©m criaremos um novo modelo que represente o usuÃ¡rio com sua senha e identificador, que chamaremos de `UserDB`:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Dessa forma, nada muda. No entanto, podemos prosseguir com a construÃ§Ã£o dos outros endpoints. E lembre-se, Ã© importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.


### Implementando o teste da rota POST

Antes de criar o teste de fato, executaremos a task de teste para ver como anda a nossa cobertura:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descriÃ§Ã£o](assets/03/cobertura_get_sem_testes.png){: .center }

EntÃ£o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a criaÃ§Ã£o de um novo usuÃ¡rio funciona corretamente. Enviamos uma solicitaÃ§Ã£o POST com um novo usuÃ¡rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta contÃ©m o novo usuÃ¡rio criado.

```python title="tests/test_app.py"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### NÃ£o se repita (DRY)

VocÃª deve ter notado que a linha `client = TestClient(app)` estÃ¡ repetida na primeira linha dos dois testes que fizemos. Repetir cÃ³digo pode tornar o gerenciamento de testes mais complexo Ã  medida que cresce, e Ã© aqui que o princÃ­pio de "NÃ£o se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a reduÃ§Ã£o da repetiÃ§Ã£o, criando um cÃ³digo mais limpo e manutenÃ­vel.

Para solucionar essa repetiÃ§Ã£o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture Ã© como uma funÃ§Ã£o que prepara dados ou estado necessÃ¡rios para o teste. Pode ser pensada como uma forma de nÃ£o repetir a fase de Arrange de um teste, simplificando a chamada e nÃ£o repetindo cÃ³digo.

??? info "Se fixtures sÃ£o uma novidade para vocÃª"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` Ã© um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes mÃ³dulos de teste em um projeto. Ã‰ uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app

@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a criaÃ§Ã£o do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py"
# ...

def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')
	# ...

def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    # ...
```

Com essa simples mudanÃ§a, conseguimos tornar nosso cÃ³digo mais limpo e fÃ¡cil de manter, seguindo o princÃ­pio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST estÃ¡ implementada, seguiremos para a prÃ³xima operaÃ§Ã£o CRUD: Read.

## Implementando a Rota GET

A rota GET Ã© usada para recuperar informaÃ§Ãµes de um ou mais usuÃ¡rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET estÃ¡ associado Ã  operaÃ§Ã£o "Read". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representarÃ¡ uma lista de usuÃ¡rios e contÃ©m apenas um campo chamado `users`, que Ã© uma lista de `UserPublic`. Isso nos permite retornar mÃºltiplos usuÃ¡rios de uma vez.

```python title="fast_zero/schemas.py" linenums="20"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornarÃ¡ uma instÃ¢ncia de `UserList`, que por sua vez contÃ©m uma lista de `UserPublic`. Cada `UserPublic` Ã© criado a partir dos dados de um usuÃ¡rio em nosso banco de dados fictÃ­cio.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList

# cÃ³digo omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementaÃ§Ã£o, nossa API agora pode retornar uma lista de usuÃ¡rios. No entanto, nosso trabalho ainda nÃ£o acabou. A prÃ³xima etapa Ã© escrever testes para garantir que nossa rota GET estÃ¡ funcionando corretamente. Isso nos ajudarÃ¡ a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementaÃ§Ã£o de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recuperaÃ§Ã£o dos usuÃ¡rios estÃ¡ funcionando corretamente. Enviamos uma solicitaÃ§Ã£o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m a lista de usuÃ¡rios.

```python title="tests/test_app.py" linenums="30"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usuÃ¡rios. Implementaremos a prÃ³xima operaÃ§Ã£o CRUD: Update.

## Implementando a Rota PUT

A rota PUT Ã© usada para atualizar as informaÃ§Ãµes de um usuÃ¡rio existente. No contexto do CRUD, o verbo HTTP PUT estÃ¡ associado Ã  operaÃ§Ã£o "Update". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

```python title="fast_zero/app.py"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id

    return user_with_id
```

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualizaÃ§Ã£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o PUT com as novas informaÃ§Ãµes do usuÃ¡rio para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m o usuÃ¡rio atualizado.

```python title="tests/test_app.py"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usuÃ¡rios. A Ãºltima operaÃ§Ã£o CRUD que precisamos implementar Ã© Delete.

## Implementando a Rota DELETE

A rota DELETE Ã© usada para excluir um usuÃ¡rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE estÃ¡ associado Ã  operaÃ§Ã£o "Delete". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

[TODO: Texto foi removido daqui, confirmar a continuidade]

Agora podemos criar nosso endpoint DELETE. Este endpoint receberÃ¡ o ID do usuÃ¡rio que queremos excluir. Note que, estamos lanÃ§ando uma exceÃ§Ã£o HTTP quando o ID do usuÃ¡rio estÃ¡ fora do range da nossa lista (simulaÃ§Ã£o do nosso banco de dados). Quando conseguimos excluir o usuÃ¡rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message

# ...

@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'detail': 'User deleted'}
```

Com a implementaÃ§Ã£o da rota DELETE concluÃ­da, Ã© fundamental garantirmos que essa rota estÃ¡ funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclusÃ£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m uma mensagem informando que o usuÃ¡rio foi excluÃ­do.

```python title="tests/test_app.py"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'detail': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, Ã© uma boa prÃ¡tica checarmos todo o cÃ³digo, e podemos fazer isso com as aÃ§Ãµes que criamos com o taskipy.

```shell title="$ ExecuÃ§Ã£o no terminal!"
$ task lint
All done! âœ¨ ğŸ° âœ¨
5 files would be left unchanged.

$ task format
All done! âœ¨ ğŸ° âœ¨
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

ApÃ³s toda essa jornada de aprendizado, construÃ§Ã£o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares Ã© uma boa prÃ¡tica, pois mantÃ©m um histÃ³rico detalhado das alteraÃ§Ãµes e facilita a volta a uma versÃ£o anterior do cÃ³digo, se necessÃ¡rio.

Primeiramente, verificaremos as alteraÃ§Ãµes feitas no projeto com o comando `git status`. Este comando nos mostrarÃ¡ todos os arquivos modificados que ainda nÃ£o foram incluÃ­dos em um commit.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git status
```

Em seguida, adicionaremos todas as alteraÃ§Ãµes para o prÃ³ximo commit. O comando `git add .` adiciona todas as alteraÃ§Ãµes feitas em todos os arquivos do projeto.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no histÃ³rico do nosso projeto. Ã‰ importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou nÃ³s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ ExecuÃ§Ã£o no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas alteraÃ§Ãµes para o repositÃ³rio remoto com `git push`. Se vocÃª tiver vÃ¡rias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git push
```

E pronto! As alteraÃ§Ãµes estÃ£o seguras no histÃ³rico do git, e podemos continuar com o prÃ³ximo passo do projeto.

## ConclusÃ£o

Com a implementaÃ§Ã£o bem-sucedida das rotas CRUD, demos um passo significativo na construÃ§Ã£o de uma API robusta e funcional com FastAPI. Agora podemos manipular usuÃ¡rios - criar, ler, atualizar e excluir - o que Ã© fundamental para muitos sistemas de informaÃ§Ã£o.

O papel dos testes em cada etapa nÃ£o pode ser subestimado. Testes nÃ£o apenas nos ajudam a assegurar que nosso cÃ³digo estÃ¡ funcionando como esperado, mas tambÃ©m nos permitem refinar nossas soluÃ§Ãµes e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a importÃ¢ncia de executar seus testes sempre que fizer uma alteraÃ§Ã£o em seu cÃ³digo!

AtÃ© aqui, no entanto, trabalhamos com um "banco de dados" provisÃ³rio, na forma de uma lista Python, que Ã© volÃ¡til e nÃ£o persiste os dados de uma execuÃ§Ã£o do aplicativo para outra. Para nosso aplicativo ser Ãºtil em um cenÃ¡rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. Ã‰ aÃ­ que os bancos de dados entram.

No prÃ³ximo tÃ³pico, exploraremos uma das partes mais crÃ­ticas de qualquer aplicativo - a conexÃ£o e interaÃ§Ã£o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persistÃªncia de nossos dados de usuÃ¡rio entre as sessÃµes do aplicativo.
