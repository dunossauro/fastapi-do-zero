---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento b√°sico sobre API, HTTP, JSON e a estrutura do projeto
---

# [WIP] Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na valida√ß√£o e serializa√ß√£o de dados
- Implementa√ß√£o de rotas CRUD em FastAPI
- Escrita e execu√ß√£o de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em v√≠deo"
	Esse aula ainda n√£o est√° dispon√≠vel em formato de v√≠deo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[C√≥digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

Boas-vindas de volta √† nossa s√©rie de aulas sobre a constru√ß√£o de uma aplica√ß√£o utilizando FastAPI. Na √∫ltima aula, abordamos conceitos b√°sicos do desenvolvimento web e finalizamos a configura√ß√£o do nosso ambiente. Hoje, avan√ßaremos na estrutura√ß√£o dos primeiros endpoints da nossa API, concentrando-nos nas quatro opera√ß√µes fundamentais de **CRUD** - Criar, Ler, Atualizar e Deletar. Exploraremos como estas opera√ß√µes se aplicam tanto √† comunica√ß√£o web quanto √† intera√ß√£o com o banco de dados.

O objetivo desta aula √© implementar um sistema de cadastro de usu√°rios na nossa aplica√ß√£o. Ao final, voc√™ conseguir√° cadastrar, listar, alterar e deletar usu√°rios, al√©m de realizar testes para validar estas funcionalidades.

## CRUD e HTTP

No mundo do desenvolvimento de APIs, existem algumas opera√ß√µes b√°sicas que gostar√≠amos de fazer com os dados. Essas opera√ß√µes se relacionam com a base de dados e a aplica√ß√£o web. Vamos nos focar nesse primeiro momento nas rela√ß√µes entre os dados.

CRUD √© um acr√¥nimo que representa as quatro opera√ß√µes b√°sicas que voc√™ pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): adicionar novos registros ao banco de dados.
- **R**ead (Ler): recuperar registros existentes do banco de dados. 
- **U**pdate (Atualizar): modificar registros existentes no banco de dados.
- **D**elete (Excluir): remover registros existentes do banco de dados.

Com essas opera√ß√µes podemos realizar qualquer tipo de comportamento em uma base dados. Podemos criar um registro, em seguida alter√°-lo, quem sabe depois disso tudo delet√°-lo.

Quando falamos de APIs servindo dados, todas essas opera√ß√µes t√™m alguma forma similar no protocolo HTTP. O protocolo tem verbos para indicar essas mesmas a√ß√µes que queremos representar no banco de dados.

- **POST**: √© usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.
- **GET**: √© usado para quando o cliente deseja requisitar uma informa√ß√£o do servidor.
- **PUT**: √© usando no momento em que o cliente deseja informar alguma altera√ß√£o nos dados para o servidor.
- **DELETE**: usado para dizer ao servidor que delete determinado recurso.

Dessa forma podemos criar associa√ß√µes entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, n√≥s como clientes devemos comunicar essa inten√ß√£o ao servidor usando o m√©todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de *create* na base de dados.

### Respostas da API

A forma de responder o cliente como as opera√ß√µes do CRUD se sucederam no servidor √© via c√≥digos de status. Por isso vamos investir mais algum momento aqui.

Os c√≥digos que devemos prestar aten√ß√£o para responder de forma correta as requisi√ß√µes. Os casos de sucesso incluem:

- **200 OK**: Indica sucesso na requisi√ß√£o.
    - **GET**: Quando um dado √© solicitado e retornado com sucesso.
	- **PUT**: Quando dados s√£o alterados com sucesso.
- **201 CREATED**: Significa que a solicita√ß√£o resultou na cria√ß√£o de um novo recurso.
	- **POST**: Aplic√°vel quando um dado √© enviado e criado com sucesso.
	- **PUT**: Usado quando uma altera√ß√£o resulta na cria√ß√£o de um novo recurso.
- **204 NO CONTENT**: Retorno do servidor sem conte√∫do na mensagem.
	- **PUT**: Aplic√°vel se a altera√ß√£o n√£o gerar um retorno.
	- **DELETE**: Usado quando a a√ß√£o de deletar n√£o gera um retorno.

Os c√≥digos de erro mais comuns que temos que conhecer para lidar com poss√≠veis erros na aplica√ß√£o, s√£o:

- **404 NOT FOUND**: O recurso solicitado n√£o p√¥de ser encontrado.
- **422 UNPROCESSABLE ENTITY**: o pedido foi bem formado (ou seja, sintaticamente correto), mas n√£o p√¥de ser processado.
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro gen√©rica, dada quando uma condi√ß√£o inesperada foi encontrada. Geralmente ocorre quando nossa aplica√ß√£o apresenta um erro.

Compreendendo esses c√≥digos, estamos prontos para iniciar a implementa√ß√£o de alguns endpoints e colocar esses conceitos em pr√°tica.

## Implementado endpoints

Para facilitar o aprendizado, sugiro dividir a cria√ß√£o de novos endpoints em tr√™s etapas:

1. Rela√ß√£o com o HTTP: Determinar o verbo HTTP esperado e os c√≥digos de resposta para situa√ß√µes de sucesso e erro.
2. Modelos de Dados: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de resposta para situa√ß√µes de sucesso e erro.
3. Implementa√ß√£o do Corpo: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado.

As duas primeiras etapas nos ajudam a definir a interface de comunica√ß√£o e como ela ser√° documentada. A terceira etapa √© mais espec√≠fica e envolve decis√µes sobre a intera√ß√£o com o banco de dados, valida√ß√µes adicionais e a defini√ß√£o do que constitui sucesso ou erro na requisi√ß√£o.

Essas etapas nos orientam na implementa√ß√£o completa do endpoint, garantindo que nada seja esquecido.

## Iniciando a implementa√ß√£o da rota POST

Nesta aula, nosso foco principal ser√° desenvolver um sistema de cadastro de usu√°rios. Para isso, a implementa√ß√£o de uma forma eficiente para criar novos usu√°rios na base de dados √© essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao servi√ßo a nossa inten√ß√£o de enviar novos dados, como no cadastro de usu√°rios..

### Implementa√ß√£o do endpoint

Para iniciar, criaremos um endpoint que aceita o verbo `POST` com dados em formato JSON. Esse endpoint responder√° com o status `201` em caso de sucesso na cria√ß√£o do recurso. Com isso, estabelecemos a base para a nossa funcionalidade de cadastro.

Usaremos o decorador `#!python @app.post()` do FastAPI para definir nosso endpoint, que come√ßar√° com a URL `/users/`, indicando onde receberemos os dados para criar novos usu√°rios:

```python title="fast_zero/app.py" linenums="13"
@app.post('/users/')
def create_user():
	...
```

#### Status code de resposta

√â crucial definir que, ao cadastrar um usu√°rio com sucesso, o sistema deve retornar o c√≥digo de resposta `#!python 201`, indicando a cria√ß√£o bem-sucedida do recurso. Para isso, adicionamos o par√¢metro `status_code` ao decorador:

```python title="fast_zero/app.py" linenums="13" hl_lines="1"
@app.post('/users/', status_code=201)
def create_user():
    ...
```

> Conversaremos em breve sobre os c√≥digos de resposta no t√≥pico do [pydantic](#validacao-e-pydantic){:target="_blank"}

### Modelo de dados

O modelo de dados √© uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que ser√£o retornados a ele. Esta abordagem assegura uma comunica√ß√£o eficaz e clara.

#### Modelo de entrada de dados

Para os dados de entrada, como estamos pensando em um cadastro de usu√°rio na aplica√ß√£o, √© importante que tenhamos insumos para identific√°-lo como o `email`, uma senha (`password`) para que ele consiga fazer o login no futuro e seu nome de usu√°rio (`username`). Dessa forma, podemos imaginar um modelo de entrada desta forma:


```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para a aplica√ß√£o conseguir expor esse modelo na documenta√ß√£o, devemos criar uma classe do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) que represente esse schema:

```python title="fast_zero/schemas.py" linenums="8"
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```

Como j√° temos o endpoint definido, precisamos fazer a associa√ß√£o do modelo com ele. Para fazer isso basta que o endpoint receba um par√¢metro e esse par√¢metro esteja associado a um modelo via anota√ß√£o de par√¢metros:

```python title="fast_zero/app.py" hl_lines="6"
from fast_zero.schemas import Message, UserSchema

# C√≥digo do ol√° mundo homitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    ...
```

Dessa forma, o modelo de entrada, o que o endpoint espera receber j√° est√° documentado e aparecer√° no swagger UI.

Para visualizar, temos que iniciar o servidor:

```shell title="$ Execu√ß√£o no terminal!"
task run
```

E acessar a p√°gina [http://127.0.01:8000/docs](http://localhost:8000/docs){:target="_blank"}. Isso nos mostrar√° as defini√ß√µes do nosso endpoint usando o o modelo no swagger:

![Captura de tela do swagger UI exibindo o modelo do pydantic descrito acima](assets/03/swagger_exibindo_o_schema_de_entrada_de_create_user.png){: .center width="400" }

#### Modelo de sa√≠da de dados

O modelo de sa√≠da explica ao cliente quais dados ser√£o retornados quando a chamada a esse endpoint for feita. Para a API ter um uso flu√≠do, temos que especificar o retorno corretamente na documenta√ß√£o.

Se dermos uma olhada no estado atual de resposta da nossa API, podemos ver que a resposta no swagger √© `#!python "string"` para o c√≥digo de resposta `#!python 201`:

![descri√ß√£o](assets/03/swagger_sem_modelo_de_resposta.png){: .center .shadow }

Quando fazemos uma chamada com o m√©todo POST o esperado √© que os dados criados sejam retornados ao cliente. Poder√≠amos usar o mesmo modelo de antes o `UserSchema`, por√©m, por uma quest√£o de seguran√ßa, seria ideal n√£o retornar a senha do usu√°rio. Quanto menos ela trafegar na rede, melhor.

Desta forma, podemos pensar no mesmo schema, por√©m, sem a senha. Algo como:

```json
{
    "username": "joao123",
    "email": "joao123@email.com"
}
```

Transcrevendo isso em um modelo do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) temos isso:

```python title="fast_zero/schemas.py" linenums="14"
class UserPublic(BaseModel):
    username: str
    email: str
```

Para aplicar um modelo a resposta do endpoint, temos que passar o modelo ao par√¢metro `response_model`, como fizemos na [aula passada](02.md#integrando-o-pydantic-com-o-fastapi){:target="_blank"}:

```py title="aula_00.py" linenums="1" hl_lines="1 5"
from fast_zero.schemas import Message, UserSchema, UserPublic

# C√≥digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    ...
```

Tendo um modelo descritivo de resposta para o cliente na documenta√ß√£o:

![descri√ß√£o](assets/03/modelo_de_resposta_do_swagger.png){: .center .shadow }


## Valida√ß√£o e pydantic

Uma caracter√≠stica importante do Pydantic e que deve ser considerada √© o fato de ele validar os schemas em tempo de execu√ß√£o. Fazendo com que caso o cliente envie um dado que n√£o corresponde com o schema definido, seja levantado um erro `#!python 422`. E caso a nossa resposta como servidor tamb√©m n√£o siga o schema, ser√° levantado um erro `#!python 500`. Fazendo com que ele seja uma garantia de duas vias que nossa API segue a especifica√ß√£o da documenta√ß√£o.

Quando relacionamos um modelo a resposta do enpoint, o Pydantic de forma autom√°tica cria um schema chamado `HTTPValidationError`:

![descri√ß√£o](assets/03/422_no_swagger.png){: .center .shadow }

Esse modelo √© usado para quando o JSON enviado na requisi√ß√£o n√£o cumprir os requisitos do schema.

Por exemplo, se fizermos uma requisi√ß√£o que foge dos padr√µes definidos no schema:

![descri√ß√£o](assets/03/chamada_com_schema_errado_no_swagger.png){: .center .shadow width=500}

Essa requisi√ß√£o foge dos padr√µes pois n√£o envia o campo `password` e envia tipo de dado errado para `email`.

Com isso, receberemos um erro `422 UNPROCESSABLE ENTITY`, dizendo que nosso schema foi violado e a resposta cont√©m os detalhes dos campos faltantes ou mal formatados:

![descri√ß√£o](assets/03/resposta_do_422_no_swagger.png){: .center .shadow width=500}

A mensagem completa de retorno do servidor mostra de forma detalhada os erros de valida√ß√£o encontrados em cada campo individualmente no campo `details`:

```python
{
  "detail": [
    {
      "type": "string_type", # (1)!
      "loc": [
        "body",
        "email" # (2)!
      ],
      "msg": "Input should be a valid string", #(3)!
      "input": 1,
      "url": "https://errors.pydantic.dev/2.5/v/string_type"
    },
    {
      "type": "missing", #(4)!
      "loc": [
        "body",
        "password" #(5)!
      ],
      "msg": "Field required", #(6)!
      "input": {
        "username": "string",
        "email": 1
      },
      "url": "https://errors.pydantic.dev/2.5/v/missing"
    }
  ]
}
```

1. Tipo de erro no campo: Era esperado que o valor fosse string (*string_type*)
2. Campo notificado
3. Mensagem que acompanha o erro
4. Tipo de erro no campo: Era esperado que o valor fosse enviado (*missing*)
5. Campo notificado
6. Mensagem que acompanha o erro

Podemos ver que o pydantic desempenha um papel bastante importante no funcionamento da API. Pois ele tem a capacidade de "barrar" o request antes dele ser exposto a nossa fun√ß√£o de endpoint. Evitando que diversos casos estranhos sejam cobertos de forma transparente. Tanto em rela√ß√£o aos tipos dos campos, quanto em rela√ß√£o aos campos que deveriam ser enviados, mas n√£o foram.

### Estendendo a valida√ß√£o com e-mail

Um outro ponto que deve ser levado em considera√ß√£o √© a capacidade de estender os campos usados pelo pydantic nas anota√ß√µes de tipo.

Imagine que quis√©ssemos melhorar a valida√ß√£o do campo `email`, para garantir que al√©m de uma `#!python str`, fosse uma string que corresponde as caracter√≠sticas de um e-mail. Como ter `@`, um sufixo com `.com`.

Para isso, o pydantic tem um tipo de dado espec√≠fico, o [`EmailStr`](https://docs.pydantic.dev/latest/api/networks/#pydantic.networks.EmailStr){:target="_blank"}. Que garante que o valor que ser√° recebido pelo schema, seja de fato um e-mail em formato v√°lido. Podemos adicion√°-lo ao campo `email` nos modelos `UserSchema` e `UserPublic`:


```python
from pydantic import BaseModel, EmailStr

# C√≥digo omitido

class UserSchema(BaseModel):
    username: str
    email: EmailStr
    password: str
	
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Embora essa seja um defini√ß√£o valida do schema, o pydantic depende que a extens√£o de emails seja instalada em nosso ambiente. Ao executar o servidor, podemos ver que o erro √© bastante descritivo:

```python
File "<...>/.venv/<...>/pydantic/networks.py", line 354, in import_email_validator
  raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e
ImportError: email-validator is not installed, run `pip install pydantic[email]`
```

Traduzindo de forma literal, ter√≠amos algo como: `#!python ImportError: email-validator n√£o est√° instalado, rode 'pip install pydantic[email]'`.

Como estamos usando o poetry como gerenciador de pacotes, podemos executar dessa forma:

```shell title="$ Execu√ß√£o no terminal!"
poetry add "pydantic[email]"
```

Com isso, o pydantic ir√° oferecer um exemplo de email no swagger `"user@example.com"` e acerta os schemas para fazer essas valida√ß√µes:

![descri√ß√£o](assets/03/schema_com_email_no_swagger.png){: .center .shadow }

Dessa forma, o campo esperar√° n√£o somente uma string como antes, mas um endere√ßo de email v√°lido.

### [WIP] Valida√ß√£o da resposta

> TODO: por conta do endpoint n√£o responder nada

```python title="fast_zero/app.py" hl_lines="3" linenums="13"
@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    ...
```

![descri√ß√£o](assets/03/request_correto_para_post_com_resposta_incorreta.png){: .center .shadow }

> TODO: Fazer uma requisi√ß√£o correta e mostrar o erro 500

![descri√ß√£o](assets/03/erro_500_do_servidor.png){: .center .shadow }

Vamos usar o endpoint em seu estado atual, sem nenhuma resposta e ver o que acontecer√° com a nossa requisi√ß√£o.


## De volta ao POST

---

> Texto Antigo!!!

Com esse endpoint criado, podemos executar a nossa aplica√ß√£o:

```shell title="$ Execu√ß√£o no terminal!"
task run
```

E acessar a p√°gina [http://localhost:8000/docs](http://localhost:8000/docs). Isso nos mostrar√° as defini√ß√µes do nosso endpoint usando o Swagger.

![descri√ß√£o](assets/03/swagger.png){: .center }

Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.

![descri√ß√£o](assets/03/swagger_com_request.png){: .center }

Entretanto, precisamos prestar aten√ß√£o a um detalhe: nosso modelo retorna a senha do usu√°rio, o que √© uma p√©ssima pr√°tica de seguran√ßa.

![descri√ß√£o](assets/03/respsota_do_swagger.png){: .center }

Para evitar isso, podemos criar um novo modelo que ser√° usado somente para resposta. Dessa forma, n√£o expomos os dados que n√£o queremos na API:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Precisamos tamb√©m dizer ao FastAPI que esse ser√° o modelo de resposta, e converter nosso `user` em `UserPublic`:


```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# c√≥digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Note que somente adicionando o `response_model`, o FastAPI j√° faz a convers√£o de `UserSchema` em `UserPublic`

Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.

![descri√ß√£o](assets/03/swagger_sem_senha.png){: .center }

### Criando um banco de dados falso

Finalmente, para brincar com essas rotas, podemos criar uma lista provis√≥ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provis√≥ria para o "banco" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import UserSchema, UserPublic, UserDB

# c√≥digo omitido

database = []  # provis√≥rio para estudo!


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)

    database.append(user_with_id)

    return user_with_id
```

Se queremos uma simula√ß√£o de banco de dados, precisamos ter um `ID` para cada usu√°rio registrado no nosso "banco". Sendo assim, alteraremos nosso modelo de resposta p√∫blica (`UserPublic`) para que ele forne√ßa o ID de cria√ß√£o do usu√°rio. Tamb√©m criaremos um novo modelo que represente o usu√°rio com sua senha e identificador, que chamaremos de `UserDB`:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Dessa forma, nada muda. No entanto, podemos prosseguir com a constru√ß√£o dos outros endpoints. E lembre-se, √© importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.


### Implementando o teste da rota POST

Antes de criar o teste de fato, executaremos a task de teste para ver como anda a nossa cobertura:

```shell title="$ Execu√ß√£o no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descri√ß√£o](assets/03/cobertura_get_sem_testes.png){: .center }

Ent√£o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria√ß√£o de um novo usu√°rio funciona corretamente. Enviamos uma solicita√ß√£o POST com um novo usu√°rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont√©m o novo usu√°rio criado.

```python title="tests/test_app.py"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ Execu√ß√£o no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### N√£o se repita (DRY)

Voc√™ deve ter notado que a linha `client = TestClient(app)` est√° repetida na primeira linha dos dois testes que fizemos. Repetir c√≥digo pode tornar o gerenciamento de testes mais complexo √† medida que cresce, e √© aqui que o princ√≠pio de "N√£o se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a redu√ß√£o da repeti√ß√£o, criando um c√≥digo mais limpo e manuten√≠vel.

Para solucionar essa repeti√ß√£o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture √© como uma fun√ß√£o que prepara dados ou estado necess√°rios para o teste. Pode ser pensada como uma forma de n√£o repetir a fase de Arrange de um teste, simplificando a chamada e n√£o repetindo c√≥digo.

??? info "Se fixtures s√£o uma novidade para voc√™"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` √© um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes m√≥dulos de teste em um projeto. √â uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app

@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a cria√ß√£o do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py"
# ...

def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')
	# ...

def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    # ...
```

Com essa simples mudan√ßa, conseguimos tornar nosso c√≥digo mais limpo e f√°cil de manter, seguindo o princ√≠pio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST est√° implementada, seguiremos para a pr√≥xima opera√ß√£o CRUD: Read.

## Implementando a Rota GET

A rota GET √© usada para recuperar informa√ß√µes de um ou mais usu√°rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est√° associado √† opera√ß√£o "Read". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representar√° uma lista de usu√°rios e cont√©m apenas um campo chamado `users`, que √© uma lista de `UserPublic`. Isso nos permite retornar m√∫ltiplos usu√°rios de uma vez.

```python title="fast_zero/schemas.py" linenums="20"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar√° uma inst√¢ncia de `UserList`, que por sua vez cont√©m uma lista de `UserPublic`. Cada `UserPublic` √© criado a partir dos dados de um usu√°rio em nosso banco de dados fict√≠cio.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList

# c√≥digo omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementa√ß√£o, nossa API agora pode retornar uma lista de usu√°rios. No entanto, nosso trabalho ainda n√£o acabou. A pr√≥xima etapa √© escrever testes para garantir que nossa rota GET est√° funcionando corretamente. Isso nos ajudar√° a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa√ß√£o de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recupera√ß√£o dos usu√°rios est√° funcionando corretamente. Enviamos uma solicita√ß√£o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m a lista de usu√°rios.

```python title="tests/test_app.py" linenums="30"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu√°rios. Implementaremos a pr√≥xima opera√ß√£o CRUD: Update.

## Implementando a Rota PUT

A rota PUT √© usada para atualizar as informa√ß√µes de um usu√°rio existente. No contexto do CRUD, o verbo HTTP PUT est√° associado √† opera√ß√£o "Update". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu√°rio solicitado n√£o for encontrado, dever√≠amos retornar o status HTTP 404 (N√£o Encontrado).

```python title="fast_zero/app.py"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id

    return user_with_id
```

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualiza√ß√£o de um usu√°rio existente funciona corretamente. Enviamos uma solicita√ß√£o PUT com as novas informa√ß√µes do usu√°rio para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m o usu√°rio atualizado.

```python title="tests/test_app.py"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu√°rios. A √∫ltima opera√ß√£o CRUD que precisamos implementar √© Delete.

## Implementando a Rota DELETE

A rota DELETE √© usada para excluir um usu√°rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est√° associado √† opera√ß√£o "Delete". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu√°rio solicitado n√£o for encontrado, dever√≠amos retornar o status HTTP 404 (N√£o Encontrado).

[TODO: Texto foi removido daqui, confirmar a continuidade]

Agora podemos criar nosso endpoint DELETE. Este endpoint receber√° o ID do usu√°rio que queremos excluir. Note que, estamos lan√ßando uma exce√ß√£o HTTP quando o ID do usu√°rio est√° fora do range da nossa lista (simula√ß√£o do nosso banco de dados). Quando conseguimos excluir o usu√°rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message

# ...

@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'detail': 'User deleted'}
```

Com a implementa√ß√£o da rota DELETE conclu√≠da, √© fundamental garantirmos que essa rota est√° funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclus√£o de um usu√°rio existente funciona corretamente. Enviamos uma solicita√ß√£o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m uma mensagem informando que o usu√°rio foi exclu√≠do.

```python title="tests/test_app.py"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'detail': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, √© uma boa pr√°tica checarmos todo o c√≥digo, e podemos fazer isso com as a√ß√µes que criamos com o taskipy.

```shell title="$ Execu√ß√£o no terminal!"
$ task lint
All done! ‚ú® üç∞ ‚ú®
5 files would be left unchanged.

$ task format
All done! ‚ú® üç∞ ‚ú®
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

Ap√≥s toda essa jornada de aprendizado, constru√ß√£o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares √© uma boa pr√°tica, pois mant√©m um hist√≥rico detalhado das altera√ß√µes e facilita a volta a uma vers√£o anterior do c√≥digo, se necess√°rio.

Primeiramente, verificaremos as altera√ß√µes feitas no projeto com o comando `git status`. Este comando nos mostrar√° todos os arquivos modificados que ainda n√£o foram inclu√≠dos em um commit.

```shell title="$ Execu√ß√£o no terminal!"
git status
```

Em seguida, adicionaremos todas as altera√ß√µes para o pr√≥ximo commit. O comando `git add .` adiciona todas as altera√ß√µes feitas em todos os arquivos do projeto.

```shell title="$ Execu√ß√£o no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no hist√≥rico do nosso projeto. √â importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou n√≥s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ Execu√ß√£o no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas altera√ß√µes para o reposit√≥rio remoto com `git push`. Se voc√™ tiver v√°rias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ Execu√ß√£o no terminal!"
git push
```

E pronto! As altera√ß√µes est√£o seguras no hist√≥rico do git, e podemos continuar com o pr√≥ximo passo do projeto.

## Conclus√£o

Com a implementa√ß√£o bem-sucedida das rotas CRUD, demos um passo significativo na constru√ß√£o de uma API robusta e funcional com FastAPI. Agora podemos manipular usu√°rios - criar, ler, atualizar e excluir - o que √© fundamental para muitos sistemas de informa√ß√£o.

O papel dos testes em cada etapa n√£o pode ser subestimado. Testes n√£o apenas nos ajudam a assegurar que nosso c√≥digo est√° funcionando como esperado, mas tamb√©m nos permitem refinar nossas solu√ß√µes e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import√¢ncia de executar seus testes sempre que fizer uma altera√ß√£o em seu c√≥digo!

At√© aqui, no entanto, trabalhamos com um "banco de dados" provis√≥rio, na forma de uma lista Python, que √© vol√°til e n√£o persiste os dados de uma execu√ß√£o do aplicativo para outra. Para nosso aplicativo ser √∫til em um cen√°rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. √â a√≠ que os bancos de dados entram.

No pr√≥ximo t√≥pico, exploraremos uma das partes mais cr√≠ticas de qualquer aplicativo - a conex√£o e intera√ß√£o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist√™ncia de nossos dados de usu√°rio entre as sess√µes do aplicativo.
