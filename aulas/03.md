---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento b√°sico sobre API, HTTP, JSON e a estrutura do projeto
---

# Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na valida√ß√£o e serializa√ß√£o de dados
- Implementa√ß√£o de rotas CRUD em FastAPI
- Escrita e execu√ß√£o de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em v√≠deo"
	Esse aula ainda n√£o est√° dispon√≠vel em formato de v√≠deo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[C√≥digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

Boas-vindas de volta √† nossa s√©rie de aulas sobre a constru√ß√£o de uma aplica√ß√£o utilizando FastAPI. Na √∫ltima aula, abordamos conceitos b√°sicos do desenvolvimento web e finalizamos a configura√ß√£o do nosso ambiente. Hoje, avan√ßaremos na estrutura√ß√£o dos primeiros endpoints da nossa API, concentrando-nos nas quatro opera√ß√µes fundamentais de **CRUD** - Criar, Ler, Atualizar e Deletar. Exploraremos como estas opera√ß√µes se aplicam tanto √† comunica√ß√£o web quanto √† intera√ß√£o com o banco de dados.

O objetivo desta aula √© implementar um sistema de cadastro de usu√°rios na nossa aplica√ß√£o. Ao final, voc√™ conseguir√° cadastrar, listar, alterar e deletar usu√°rios, al√©m de realizar testes para validar estas funcionalidades.

## CRUD e HTTP

No desenvolvimento de APIs, existem quatro a√ß√µes principais que fazemos com os dados: criar, ler, atualizar e excluir. Essas a√ß√µes ajudam a gerenciar os dados no banco de dados e na aplica√ß√£o web. Vamos nos focar nesse primeiro momento nas rela√ß√µes entre os dados.

CRUD √© um acr√¥nimo que representa as quatro opera√ß√µes b√°sicas que voc√™ pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): adicionar novos registros ao banco de dados.
- **R**ead (Ler): recuperar registros existentes do banco de dados. 
- **U**pdate (Atualizar): modificar registros existentes no banco de dados.
- **D**elete (Excluir): remover registros existentes do banco de dados.

Com essas opera√ß√µes podemos realizar qualquer tipo de comportamento em uma base dados. Podemos criar um registro, em seguida alter√°-lo, quem sabe depois disso tudo delet√°-lo.

Quando falamos de APIs servindo dados, todas essas opera√ß√µes t√™m alguma forma similar no protocolo HTTP. O protocolo tem verbos para indicar essas mesmas a√ß√µes que queremos representar no banco de dados.

- **POST**: √© usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.
- **GET**: √© usado para quando o cliente deseja requisitar uma informa√ß√£o do servidor.
- **PUT**: √© usando no momento em que o cliente deseja informar alguma altera√ß√£o nos dados para o servidor.
- **DELETE**: usado para dizer ao servidor que delete determinado recurso.

Dessa forma podemos criar associa√ß√µes entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, n√≥s como clientes devemos comunicar essa inten√ß√£o ao servidor usando o m√©todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de *create* na base de dados.

### Respostas da API

Usamos c√≥digos de status para informar ao cliente o resultado das opera√ß√µes no servidor, como se um dado foi criado, encontrado, atualizado ou exclu√≠do com sucesso. Por isso investiremos mais algum momento aqui.

Os c√≥digos que devemos prestar aten√ß√£o para responder de corretamente as requisi√ß√µes. Os casos de sucesso incluem:

- **200 OK**: Indica sucesso na requisi√ß√£o.
	- **GET**: Quando um dado √© solicitado e retornado com sucesso.
	- **PUT**: Quando dados s√£o alterados com sucesso.
- **201 CREATED**: Significa que a solicita√ß√£o resultou na cria√ß√£o de um novo recurso.
	- **POST**: Aplic√°vel quando um dado √© enviado e criado com sucesso.
	- **PUT**: Usado quando uma altera√ß√£o resulta na cria√ß√£o de um novo recurso.
- **204 NO CONTENT**: Retorno do servidor sem conte√∫do na mensagem.
	- **PUT**: Aplic√°vel se a altera√ß√£o n√£o gerar um retorno.
	- **DELETE**: Usado quando a a√ß√£o de deletar n√£o gera um retorno.

Os c√≥digos de erro mais comuns que temos que conhecer para lidar com poss√≠veis erros na aplica√ß√£o, s√£o:

- **404 NOT FOUND**: O recurso solicitado n√£o p√¥de ser encontrado.
- **422 UNPROCESSABLE ENTITY**: o pedido foi bem formado (ou seja, sintaticamente correto), mas n√£o p√¥de ser processado.
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro gen√©rica, dada quando uma condi√ß√£o inesperada foi encontrada. Geralmente ocorre quando nossa aplica√ß√£o apresenta um erro.

Compreendendo esses c√≥digos, estamos prontos para iniciar a implementa√ß√£o de alguns endpoints e colocar esses conceitos em pr√°tica.

## Implementado endpoints

Para facilitar o aprendizado, sugiro dividir a cria√ß√£o de novos endpoints em tr√™s etapas:

1. Rela√ß√£o com o HTTP: Determinar o verbo HTTP esperado e os c√≥digos de resposta para situa√ß√µes de sucesso e erro.
2. Modelos de Dados: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de resposta para situa√ß√µes de sucesso e erro.
3. Implementa√ß√£o do Corpo: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado.

As duas primeiras etapas nos ajudam a definir a interface de comunica√ß√£o e como ela ser√° documentada. A terceira etapa √© mais espec√≠fica e envolve decis√µes sobre a intera√ß√£o com o banco de dados, valida√ß√µes adicionais e a defini√ß√£o do que constitui sucesso ou erro na requisi√ß√£o.

Essas etapas nos orientam na implementa√ß√£o completa do endpoint, garantindo que nada seja esquecido.

## Iniciando a implementa√ß√£o da rota POST

Nesta aula, nosso foco principal ser√° desenvolver um sistema de cadastro de usu√°rios. Para isso, a implementa√ß√£o de uma forma eficiente para criar novos usu√°rios na base de dados √© essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao servi√ßo a nossa inten√ß√£o de enviar novos dados, como no cadastro de usu√°rios.

### Implementa√ß√£o do endpoint

Para iniciar, criaremos um endpoint que aceita o verbo `POST` com dados em formato JSON. Esse endpoint responder√° com o status `201` em caso de sucesso na cria√ß√£o do recurso. Com isso, estabelecemos a base para a nossa funcionalidade de cadastro.

Usaremos o decorador `#!python @app.post()` do FastAPI para definir nosso endpoint, que come√ßar√° com a URL `/users/`, indicando onde receberemos os dados para criar novos usu√°rios:

```python title="fast_zero/app.py" linenums="13"
@app.post('/users/')
def create_user():
	...
```

#### Status code de resposta

√â crucial definir que, ao cadastrar um usu√°rio com sucesso, o sistema deve retornar o c√≥digo de resposta `#!python 201`, indicando a cria√ß√£o bem-sucedida do recurso. Para isso, adicionamos o par√¢metro `status_code` ao decorador:

```python title="fast_zero/app.py" linenums="13" hl_lines="1"
@app.post('/users/', status_code=201)
def create_user():
    ...
```

> Conversaremos em breve sobre os c√≥digos de resposta no t√≥pico do [pydantic](#validacao-e-pydantic){:target="_blank"}

### Modelo de dados

O modelo de dados √© uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que ser√£o retornados a ele. Esta abordagem assegura uma comunica√ß√£o eficaz e clara.

#### Modelo de entrada de dados

Para os dados de entrada, como estamos pensando em um cadastro de usu√°rio na aplica√ß√£o, √© importante que tenhamos insumos para identific√°-lo como o `email`, uma senha (`password`) para que ele consiga fazer o login no futuro e seu nome de usu√°rio (`username`). Dessa forma, podemos imaginar um modelo de entrada desta forma:


```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para a aplica√ß√£o conseguir expor esse modelo na documenta√ß√£o, devemos criar uma classe do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) que represente esse schema:

```python title="fast_zero/schemas.py" linenums="8"
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```

Como j√° temos o endpoint definido, precisamos fazer a associa√ß√£o do modelo com ele. Para fazer isso basta que o endpoint receba um par√¢metro e esse par√¢metro esteja associado a um modelo via anota√ß√£o de par√¢metros:

```python title="fast_zero/app.py" hl_lines="6"
from fast_zero.schemas import Message, UserSchema

# C√≥digo do ol√° mundo homitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    ...
```

Dessa forma, o modelo de entrada, o que o endpoint espera receber j√° est√° documentado e aparecer√° no swagger UI.

Para visualizar, temos que iniciar o servidor:

```shell title="$ Execu√ß√£o no terminal!"
task run
```

E acessar a p√°gina [http://127.0.01:8000/docs](http://localhost:8000/docs){:target="_blank"}. Isso nos mostrar√° as defini√ß√µes do nosso endpoint usando o modelo no swagger:

![Captura de tela do swagger UI exibindo o modelo do pydantic descrito acima](assets/03/swagger_exibindo_o_schema_de_entrada_de_create_user.png){: .center width="400" }

#### Modelo de sa√≠da de dados

O modelo de sa√≠da explica ao cliente quais dados ser√£o retornados quando a chamada a esse endpoint for feita. Para a API ter um uso flu√≠do, temos que especificar o retorno corretamente na documenta√ß√£o.

Se dermos uma olhada no estado atual de resposta da nossa API, podemos ver que a resposta no swagger √© `#!python "string"` para o c√≥digo de resposta `#!python 201`:

![descri√ß√£o](assets/03/swagger_sem_modelo_de_resposta.png){: .center .shadow }

Quando fazemos uma chamada com o m√©todo POST o esperado √© que os dados criados sejam retornados ao cliente. Poder√≠amos usar o mesmo modelo de antes o `UserSchema`, por√©m, por uma quest√£o de seguran√ßa, seria ideal n√£o retornar a senha do usu√°rio. Quanto menos ela trafegar na rede, melhor.

Desta forma, podemos pensar no mesmo schema, por√©m, sem a senha. Algo como:

```json
{
    "username": "joao123",
    "email": "joao123@email.com"
}
```

Transcrevendo isso em um modelo do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) temos isso:

```python title="fast_zero/schemas.py" linenums="14"
class UserPublic(BaseModel):
    username: str
    email: str
```

Para aplicar um modelo a resposta do endpoint, temos que passar o modelo ao par√¢metro `response_model`, como fizemos na [aula passada](02.md#integrando-o-pydantic-com-o-fastapi){:target="_blank"}:

```py title="aula_00.py" hl_lines="1 5"
from fast_zero.schemas import Message, UserSchema, UserPublic

# C√≥digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    ...
```

Tendo um modelo descritivo de resposta para o cliente na documenta√ß√£o:

![descri√ß√£o](assets/03/modelo_de_resposta_do_swagger.png){: .center .shadow }


## Valida√ß√£o e pydantic

Um ponto crucial do Pydantic √© sua habilidade de checar se os dados est√£o corretos enquanto o programa est√° rodando, garantindo que tudo esteja conforme esperado. Fazendo com que, caso o cliente envie um dado que n√£o corresponde com o schema definido, seja levantado um erro `#!python 422`. E caso a nossa resposta como servidor tamb√©m n√£o siga o schema, ser√° levantado um erro `#!python 500`. Fazendo com que ele seja uma garantia de duas vias, nossa API segue a especifica√ß√£o da documenta√ß√£o.

Quando relacionamos um modelo √† resposta do enpoint, o Pydantic de forma autom√°tica, cria um schema chamado `HTTPValidationError`:

![descri√ß√£o](assets/03/422_no_swagger.png){: .center .shadow }

Esse modelo √© usado para quando o JSON enviado na requisi√ß√£o n√£o cumprir os requisitos do schema.

Por exemplo, se fizermos uma requisi√ß√£o que foge dos padr√µes definidos no schema:

![descri√ß√£o](assets/03/chamada_com_schema_errado_no_swagger.png){: .center .shadow width=500}

Essa requisi√ß√£o foge dos padr√µes, pois n√£o envia o campo `password` e envia tipo de dado errado para `email`.

Com isso, receberemos um erro `422 UNPROCESSABLE ENTITY`, dizendo que nosso schema foi violado e a resposta cont√©m os detalhes dos campos faltantes ou mal formatados:

![descri√ß√£o](assets/03/resposta_do_422_no_swagger.png){: .center .shadow width=500}

A mensagem completa de retorno do servidor mostra de forma detalhada os erros de valida√ß√£o encontrados em cada campo, individualmente no campo `details`:

```python
{
  "detail": [
    {
      "type": "string_type", # (1)!
      "loc": [
        "body",
        "email" # (2)!
      ],
      "msg": "Input should be a valid string", #(3)!
      "input": 1,
      "url": "https://errors.pydantic.dev/2.5/v/string_type"
    },
    {
      "type": "missing", #(4)!
      "loc": [
        "body",
        "password" #(5)!
      ],
      "msg": "Field required", #(6)!
      "input": {
        "username": "string",
        "email": 1
      },
      "url": "https://errors.pydantic.dev/2.5/v/missing"
    }
  ]
}
```

1. Tipo de erro no campo: Era esperado que o valor fosse string (*string_type*)
2. Campo notificado
3. Mensagem que acompanha o erro
4. Tipo de erro no campo: Era esperado que o valor fosse enviado (*missing*)
5. Campo notificado
6. Mensagem que acompanha o erro

Vemos que o pydantic desempenha um papel bastante importante no funcionamento da API. Pois ele consegue de "barrar" o request antes dele ser exposto √† nossa fun√ß√£o de endpoint. Evitando que diversos casos estranhos sejam cobertos de forma transparente. Tanto em rela√ß√£o aos tipos dos campos, quanto em rela√ß√£o aos campos que deveriam ser enviados, mas n√£o foram.

### Estendendo a valida√ß√£o com e-mail

Outro ponto que deve ser considerado √© a capacidade de estender os campos usados pelo pydantic nas anota√ß√µes de tipo.

Para garantir que o campo `email` realmente contenha um e-mail v√°lido, podemos usar uma ferramenta especial do Pydantic que verifica se o e-mail tem o formato correto, como a presen√ßa de `@` e um dom√≠nio v√°lido.

Para isso, o pydantic tem um tipo de dado espec√≠fico, o [`EmailStr`](https://docs.pydantic.dev/latest/api/networks/#pydantic.networks.EmailStr){:target="_blank"}. Que garante que o valor que ser√° recebido pelo schema, seja de fato um e-mail em formato v√°lido. Podemos adicion√°-lo ao campo `email` nos modelos `UserSchema` e `UserPublic`:


```python
from pydantic import BaseModel, EmailStr

# C√≥digo omitido

class UserSchema(BaseModel):
    username: str
    email: EmailStr
    password: str

class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Embora essa seja um defini√ß√£o valida do schema, o pydantic depende que a extens√£o de emails seja instalada em nosso ambiente. Ao executar o servidor, podemos ver que o erro √© bastante descritivo:

```python
File "<...>/.venv/<...>/pydantic/networks.py", line 354, in import_email_validator
  raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e
ImportError: email-validator is not installed, run `pip install pydantic[email]`
```

Traduzindo de forma literal, ter√≠amos algo como: `#!python ImportError: email-validator n√£o est√° instalado, rode 'pip install pydantic[email]'`.

Como estamos usando o poetry como gerenciador de pacotes, podemos executar dessa forma:

```shell title="$ Execu√ß√£o no terminal!"
poetry add "pydantic[email]"
```

Com isso, o pydantic ir√° oferecer um exemplo de email no swagger `"user@example.com"` e acerta os schemas para fazer essas valida√ß√µes:

![descri√ß√£o](assets/03/schema_com_email_no_swagger.png){: .center .shadow }

Dessa forma, o campo esperar√° n√£o somente uma string como antes, mas um endere√ßo de email v√°lido.

### Valida√ß√£o da resposta

Ap√≥s aperfei√ßoarmos nossos modelos do Pydantic para garantir que os dados de entrada e sa√≠da estejam corretamente validados, chegamos a um ponto crucial: a implementa√ß√£o do corpo do nosso endpoint. At√© agora, nosso endpoint est√° definido, mas sem uma l√≥gica de processamento real, conforme mostrado abaixo:

```python title="fast_zero/app.py" hl_lines="3" linenums="13"
@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    ...
```

Este √© o momento perfeito para realizar um request e observar diretamente a atua√ß√£o do Pydantic na valida√ß√£o da resposta. Ao tentarmos executar um request v√°lido, sem a implementa√ß√£o adequada do endpoint, nos deparamos com uma situa√ß√£o interessante: o Pydantic tenta validar a resposta que o nosso endpoint deveria fornecer, mas, como ainda n√£o implementamos essa l√≥gica, o resultado n√£o atende ao schema definido.

![Captura de tela do swagger com o schema correto sendo enviado](assets/03/request_correto_para_post_com_resposta_incorreta.png){: .center .shadow }

A tentativa resulta em uma mensagem de erro exibida diretamente no Swagger, indicando um erro de servidor interno (HTTP 500). Esse tipo de erro sugere que algo deu errado no lado do servidor, mas n√£o oferece detalhes espec√≠ficos sobre a natureza do problema para o cliente. O erro 500 √© uma resposta gen√©rica para indicar falhas no servidor.

![captura de tela do swagger respondendo o erro 500](assets/03/erro_500_do_servidor.png){: .center .shadow }

Para investigar a causa exata do erro 500, √© necess√°rio consultar o console ou os logs de nossa aplica√ß√£o, onde os detalhes do erro s√£o registrados. Neste caso, o erro apresentado nos logs √© o seguinte:

```python
raise ResponseValidationError( # (1)!
fastapi.exceptions.ResponseValidationError: 1 validation errors:
{
  "type":"model_attributes_type",
  "loc": ("response"),
  "msg":"Input should be a valid dictionary or object to extract fields from",#(2)!
  "input":"None", #(3)!
  "url":"https://errors.pydantic.dev/2.6/v/model_attributes_type"
}
```

1. O json dessa mensagem de erro aparece em uma √∫nica linha. Eu fiz a quebra para que ficasse mais f√°cil de lermos a resposta.
2. A mensagem de erro diz que o input passado ao modelo do pydantic deveria ser um dicion√°rio v√°lido ou um objeto onde os campos do poderiam ser extra√≠dos.
3. O objeto enviado ao modelo

Essencialmente, o erro nos informa que o modelo esperava receber um objeto v√°lido para processamento, mas, em vez disso, recebeu `None`. Isso ocorre porque ainda n√£o implementamos a l√≥gica para processar o input recebido e retornar uma resposta adequada que corresponda ao modelo `UserPublic`.

Agora, tendo identificado a capacidade do Pydantic em validar as respostas e encontrarmos um erro devido √† falta de implementa√ß√£o, podemos proceder com uma solu√ß√£o simples. Para come√ßar, podemos utilizar diretamente os dados recebidos em `user` e retorn√°-los. Esta a√ß√£o simples j√° √© suficiente para satisfazer o schema, pois o objeto `user` cont√©m os atributos `email` e `username`, esperados pelo modelo `UserPublic`:

```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# c√≥digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Este retorno simples do objeto `user` garante que o schema seja cumprido. Agora, ao realizarmos novamente a chamada no Swagger, o objeto que enviamos √© retornado conforme esperado, mas sem expor a senha, alinhado ao modelo `UserPublic` e emitindo uma resposta com o c√≥digo 201:

![Captura de tela do swagger exibindo o modelo de resposta `UserPublic` corretamente com o c√≥digo 201](assets/03/swagger_sem_senha.png){: .center }

Essa abordagem nos permite fechar o ciclo de valida√ß√£o, demonstrando a efic√°cia do Pydantic na garantia de que os dados de resposta estejam corretos. Com essa implementa√ß√£o simples, estabelecemos a base para o desenvolvimento real do c√≥digo do endpoint POST, preparando o terreno para uma l√≥gica mais complexa que envolver√° a cria√ß√£o e o manejo de usu√°rios dentro de nossa aplica√ß√£o.

## De volta ao POST

Agora que j√° dominamos a defini√ß√£o dos modelos, podemos prosseguir com a aula e a implementa√ß√£o dos endpoints. Vamos retomar a implementa√ß√£o do POST, adicionando um banco de dados falso/simulado em mem√≥ria. Isso nos permitir√° explorar as opera√ß√µes do CRUD sem a complexidade da implementa√ß√£o de um banco de dados real, facilitando a assimila√ß√£o dos muitos conceitos discutidos nesta aula.

### Criando um banco de dados falso

Para interagir com essas rotas de maneira pr√°tica, vamos criar uma lista provis√≥ria que simular√° um banco de dados. Isso nos permitir√° adicionar dados e entender o funcionamento do FastAPI. Portanto, introduzimos uma lista provis√≥ria para atuar como nosso "banco" e modificamos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import Message, UserSchema, UserPublic, UserDB

# c√≥digo omitido

database = []  # Lista provis√≥ria para fins de estudo


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1) #(1)!

    database.append(user_with_id)

    return user_with_id
```

1. `.model_dump()` √© um m√©todo de modelos do pydantic que converte o objeto em dicion√°rio. Por exemplo, `user.model_dump()` faria a convers√£o em `#!python {'username': 'nome do usu√°rio', 'password': 'senha do usu√°rio', 'email': 'email do usu√°rio'}`. Os `**` querem dizer que o dicion√°rio ser√° desempacotado em par√¢metros. Fazendo com que a chamada seja equivalente a `#!python UserDB(username='nome do usu√°rio', password='senha do usu√°rio', email='email do usu√°rio',  id=len(database) + 1)`

Para simular um banco de dados de forma mais realista, √© essencial que cada usu√°rio tenha um ID √∫nico. Portanto, ajustamos nosso modelo de resposta p√∫blica (`UserPublic`) para incluir o ID do usu√°rio. Tamb√©m introduzimos um novo modelo, `UserDB`, que inclui tanto a senha do usu√°rio quanto seu identificador √∫nico:

```python title="fast_zero/schemas.py" linenums="14"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Essa abordagem simples nos permite avan√ßar na constru√ß√£o dos outros endpoints. √â crucial testar esse endpoint para assegurar seu correto funcionamento.


### Implementando o teste da rota POST

Antes de prosseguir, vamos verificar a cobertura de nossos testes:

```shell title="$ Execu√ß√£o no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descri√ß√£o](assets/03/cobertura_get_sem_testes.png){: .center }

Ent√£o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria√ß√£o de um novo usu√°rio funciona corretamente. Enviamos uma solicita√ß√£o POST com um novo usu√°rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont√©m o novo usu√°rio criado.

```python title="tests/test_app.py" linenums="15"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ Execu√ß√£o no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### N√£o se repita (DRY)

Voc√™ deve ter notado que a linha `client = TestClient(app)` est√° repetida na primeira linha dos dois testes que fizemos. Repetir c√≥digo pode tornar o gerenciamento de testes mais complexo √† medida que cresce, e √© aqui que o princ√≠pio de "N√£o se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a redu√ß√£o da repeti√ß√£o, criando um c√≥digo mais limpo e manuten√≠vel.

Para solucionar essa repeti√ß√£o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture √© como uma fun√ß√£o que prepara dados ou estado necess√°rios para o teste. Pode ser pensada como uma forma de n√£o repetir a fase de Arrange de um teste, simplificando a chamada e n√£o repetindo c√≥digo.

??? info "Se fixtures s√£o uma novidade para voc√™"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` √© um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes m√≥dulos de teste em um projeto. √â uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py" linenums="1"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app


@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a cria√ß√£o do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py" linenums="1" hl_lines="1 8"
def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')

    assert response.status_code == 200
    assert response.json() == {'message': 'Ol√° Mundo!'}


def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Com essa simples mudan√ßa, conseguimos tornar nosso c√≥digo mais limpo e f√°cil de manter, seguindo o princ√≠pio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST est√° implementada, seguiremos para a pr√≥xima opera√ß√£o CRUD: Read.

## Implementando a Rota GET

A rota GET √© usada para recuperar informa√ß√µes de um ou mais usu√°rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est√° associado √† opera√ß√£o "Read". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representar√° uma lista de usu√°rios e cont√©m apenas um campo chamado `users`, que √© uma lista de `UserPublic`. Isso nos permite retornar m√∫ltiplos usu√°rios de uma vez.

```python title="fast_zero/schemas.py" linenums="24"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar√° uma inst√¢ncia de `UserList`, que por sua vez cont√©m uma lista de `UserPublic`. Cada `UserPublic` √© criado a partir dos dados de um usu√°rio em nosso banco de dados fict√≠cio.

```python title="fast_zero/app.py"
from fast_zero.schemas import Message, UserDB, UserList, UserPublic, UserSchema

# c√≥digo omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementa√ß√£o, nossa API agora pode retornar uma lista de usu√°rios. No entanto, nosso trabalho ainda n√£o acabou. A pr√≥xima etapa √© escrever testes para garantir que nossa rota GET est√° funcionando corretamente. Isso nos ajudar√° a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa√ß√£o de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recupera√ß√£o dos usu√°rios est√° funcionando corretamente. Enviamos uma solicita√ß√£o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m a lista de usu√°rios.

```python title="tests/test_app.py" linenums="25"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu√°rios. Implementaremos a pr√≥xima opera√ß√£o CRUD: Update.

## Implementando a Rota PUT

A rota PUT √© usada para atualizar as informa√ß√µes de um usu√°rio existente. No contexto do CRUD, o verbo HTTP PUT est√° associado √† opera√ß√£o "Update". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu√°rio solicitado n√£o for encontrado, dever√≠amos retornar o status HTTP 404 (N√£o Encontrado).

Uma caracter√≠stica importante do verbo PUT √© que ele √© direcionado a um recurso em espec√≠fico. Nesse caso, estamos direcionando a altera√ß√£o a um `user` em espec√≠fico na base de dados. O identificador de `user` √© o campo `id` que estamos usando nos modelos do Pydantic. Nesse caso, nosso endpoint deve receber o identificador de quem ser√° alterado.

Para fazer essa identifica√ß√£o do recurso na [URL](02.md/#url){:target="_blank"} usamos a seguinte combina√ß√£o `/caminho/recurso`. Mas, como o recurso √© din√¢mico, ele deve ser enviado pelo cliente. Fazendo com que ele valor tenha que ser uma vari√°vel. Dentro do FastAPI, as vari√°veis de recursos s√£o descritas dentro de {}, como `{user_id}`. Fazendo com que o caminho completo do nosso endpoint seja `#!python '/users/{user_id}'`. Da seguinte forma:

```python title="fast_zero/app.py" hl_lines="5 6"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1: #(1)!
        raise HTTPException(status_code=404, detail='User not found') #(2)!

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id #(3)!

    return user_with_id
```

1. Aqui fazemos uma valida√ß√£o simples, verificamos se o id n√£o √© maior que o tamanho da lista `#!python user_id > len(database)` e o n√∫mero enviado para o `user)id` √© um valor positivo `#!python user_id < 1`.
2. Levantamos um erro do tipo `HTTPException` para dizer que o usu√°rio n√£o existe na base de dados. Esse modelo j√° est√° presente no swagger com `HTTPValidationError`.
3. Nessa linha estamos substituindo a posi√ß√£o (`user_id - 1`) na lista pelo novo objeto.

Para que essa vari√°vel definida na URL seja transferida para nosso endpoint, devemos adicionar um par√¢metro na fun√ß√£o com o mesmo nome da vari√°vel definida. Como `#!python def update_user(user_id: int)` na linha em destaque.

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualiza√ß√£o de um usu√°rio existente funciona corretamente. Enviamos uma solicita√ß√£o PUT com as novas informa√ß√µes do usu√°rio para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m o usu√°rio atualizado.

```python title="tests/test_app.py" linenums="39"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu√°rios. A √∫ltima opera√ß√£o CRUD que precisamos implementar √© Delete.

## Implementando a Rota DELETE

A rota DELETE √© usada para excluir um usu√°rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est√° associado √† opera√ß√£o "Delete". Se a solicita√ß√£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu√°rio solicitado n√£o for encontrado, dever√≠amos retornar o status HTTP 404 (N√£o Encontrado).

Este endpoint receber√° o ID do usu√°rio que queremos excluir. Note que, estamos lan√ßando uma exce√ß√£o HTTP quando o ID do usu√°rio est√° fora do range da nossa lista (simula√ß√£o do nosso banco de dados). Quando conseguimos excluir o usu√°rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py" linenums="41"
@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'message': 'User deleted'}
```

Com a implementa√ß√£o da rota DELETE conclu√≠da, √© fundamental garantirmos que essa rota est√° funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclus√£o de um usu√°rio existente funciona corretamente. Enviamos uma solicita√ß√£o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont√©m uma mensagem informando que o usu√°rio foi exclu√≠do.

```python title="tests/test_app.py" linenums="56"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'message': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, √© uma boa pr√°tica checarmos todo o c√≥digo, e podemos fazer isso com as a√ß√µes que criamos com o taskipy.

```shell title="$ Execu√ß√£o no terminal!"
$ task lint
All done! ‚ú® üç∞ ‚ú®
5 files would be left unchanged.

$ task format
All done! ‚ú® üç∞ ‚ú®
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

Ap√≥s toda essa jornada de aprendizado, constru√ß√£o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares √© uma boa pr√°tica, pois mant√©m um hist√≥rico detalhado das altera√ß√µes e facilita a volta a uma vers√£o anterior do c√≥digo, se necess√°rio.

Primeiramente, verificaremos as altera√ß√µes feitas no projeto com o comando `git status`. Este comando nos mostrar√° todos os arquivos modificados que ainda n√£o foram inclu√≠dos em um commit.

```shell title="$ Execu√ß√£o no terminal!"
git status
```

Em seguida, adicionaremos todas as altera√ß√µes para o pr√≥ximo commit. O comando `git add .` adiciona todas as altera√ß√µes feitas em todos os arquivos do projeto.

```shell title="$ Execu√ß√£o no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no hist√≥rico do nosso projeto. √â importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou n√≥s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ Execu√ß√£o no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas altera√ß√µes para o reposit√≥rio remoto com `git push`. Se voc√™ tiver v√°rias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ Execu√ß√£o no terminal!"
git push
```

E pronto! As altera√ß√µes est√£o seguras no hist√≥rico do git, e podemos continuar com o pr√≥ximo passo do projeto.

## Exerc√≠cios

1. Escrever um teste para o erro de `#!python 404` para o endpoint de PUT;
2. Escrever um teste para o erro de `#!python 404` para o endpoint de DELETE;
3. Criar um enpoint de GET para pegar um √∫nico recurso como `users/{id}` e fazer seus testes.

## Conclus√£o

Com a implementa√ß√£o bem-sucedida das rotas CRUD, demos um passo significativo na constru√ß√£o de uma API robusta e funcional com FastAPI. Agora podemos manipular usu√°rios - criar, ler, atualizar e excluir - o que √© fundamental para muitos sistemas de informa√ß√£o.

O papel dos testes em cada etapa n√£o pode ser subestimado. Testes n√£o apenas nos ajudam a assegurar que nosso c√≥digo est√° funcionando como esperado, mas tamb√©m nos permitem refinar nossas solu√ß√µes e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import√¢ncia de executar seus testes sempre que fizer uma altera√ß√£o em seu c√≥digo!

At√© aqui, no entanto, trabalhamos com um "banco de dados" provis√≥rio, na forma de uma lista Python, que √© vol√°til e n√£o persiste os dados de uma execu√ß√£o do aplicativo para outra. Para nosso aplicativo ser √∫til em um cen√°rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. √â a√≠ que os bancos de dados entram.

No pr√≥ximo t√≥pico, exploraremos uma das partes mais cr√≠ticas de qualquer aplicativo - a conex√£o e intera√ß√£o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist√™ncia de nossos dados de usu√°rio entre as sess√µes do aplicativo.
