---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento bÃ¡sico sobre API, HTTP, JSON e a estrutura do projeto
---

# Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Entendimento dos verbos HTTP, JSON e cÃ³digos de resposta
- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprender sobre a biblioteca Pydantic e sua utilidade na validaÃ§Ã£o e serializaÃ§Ã£o de dados
- ImplementaÃ§Ã£o de rotas CRUD em FastAPI
- Escrita e execuÃ§Ã£o de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em vÃ­deo"
	Esse aula ainda nÃ£o estÃ¡ disponÃ­vel em formato de vÃ­deo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[CÃ³digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

[TODO: Reescrever a instroduÃ§Ã£o]

Boas-vindas de volta Ã  nossa construÃ§Ã£o de uma aplicaÃ§Ã£o usando FastAPI. Na Ãºltima aula, configuramos todo o ambiente necessÃ¡rio para comeÃ§armos a desenvolver nosso aplicativo. Nesta aula, daremos um passo adiante ao estruturarmos os primeiros endpoints da nossa API, focando nas quatro operaÃ§Ãµes bÃ¡sicas de gerenciamento de usuÃ¡rios. Vamos abordar o **CRUD** - Criar, Ler, Atualizar e Deletar - e como essas operaÃ§Ãµes se aplicam aos dados da nossa base de dados.

Antes de prosseguirmos com os cÃ³digos, temos que conversar sobre alguns conceitos que serÃ£o bastante importantes para quem estÃ¡ desenvolvendo sua primeira aplicaÃ§Ã£o web.


[TODO: Mudar esse tÃ³pico de lugar]

## Pydantic e a validaÃ§Ã£o de dados

Antes de mergulharmos no cÃ³digo, vamos entender alguns conceitos importantes.

??? tip "Caso esse seja seu primeiro contato com Pydantic"
	Temos uma live de python exclusiva sobre esse assunto

	![type:video](https://www.youtube.com/embed/UdfLu1G47BU)

	[:fontawesome-brands-youtube: Link direto](https://www.youtube.com/watch?v=UdfLu1G47BU){ .md-button }

O Pydantic Ã© uma biblioteca Python que oferece validaÃ§Ã£o de dados e configuraÃ§Ãµes usando anotaÃ§Ãµes de tipos Python. Ela Ã© utilizada extensivamente com o FastAPI para lidar com a validaÃ§Ã£o e serializaÃ§Ã£o/desserializaÃ§Ã£o de dados. O Pydantic tem um papel crucial ao trabalhar com JSON, permitindo a validaÃ§Ã£o dos dados recebidos neste formato, assim como sua conversÃ£o para formatos nativos do Python e vice-versa.

O uso do Pydantic nos permite definir modelos de dados, ou "esquemas", com campos anotados com tipos de dados. O Pydantic garante que as instÃ¢ncias desses modelos sempre estejam conforme o esquema definido.

**Esquemas**: No contexto da programaÃ§Ã£o, um esquema Ã© uma representaÃ§Ã£o estrutural de um objeto ou entidade. Por exemplo, no nosso caso, um usuÃ¡rio pode ser representado por um esquema que contÃ©m campos para nome de usuÃ¡rio, e-mail e senha. Esquemas sÃ£o Ãºteis porque permitem definir a estrutura de um objeto de uma maneira clara e reutilizÃ¡vel.

**ValidaÃ§Ã£o de dados**: Este Ã© o processo de verificar se os dados recebidos estÃ£o conforme as regras e restriÃ§Ãµes definidas. Por exemplo, se esperamos que o campo "email" contenha um endereÃ§o de e-mail vÃ¡lido, a validaÃ§Ã£o de dados garantirÃ¡ que os dados inseridos nesse campo de fato correspondam a um formato de e-mail vÃ¡lido.

Considere um exemplo onde recebemos o seguinte objeto JSON, representando um novo usuÃ¡rio que quer se registrar em nosso serviÃ§o:

```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para lidar com esta entrada de dados, devemos definir um esquema Pydantic que corresponda Ã  estrutura deste objeto JSON. Usamos anotaÃ§Ãµes de tipos Python para definir o tipo de dado de cada campo:

```python
from pydantic import BaseModel, EmailStr


class UserSchema(BaseModel):
    username: str
    email: EmailStr
    password: str
```

Neste exemplo, o campo `username` Ã© esperado como uma string, o campo `email` como uma string que valida o formato de um endereÃ§o de email (graÃ§as Ã  anotaÃ§Ã£o `EmailStr` do Pydantic), e o campo `password` tambÃ©m Ã© esperado como uma string.

Ao usar este esquema, qualquer tentativa de criar um usuÃ¡rio com dados que nÃ£o correspondam a este formato (por exemplo, um email que nÃ£o Ã© vÃ¡lido, ou um campo de nome de usuÃ¡rio que nÃ£o Ã© uma string) resultarÃ¡ em um erro de validaÃ§Ã£o.

### Suporte a emails

Para que o Pydantic suporte a validaÃ§Ã£o de emails, Ã© necessÃ¡rio instalar o `pydantic[email]`

```shell title="$ ExecuÃ§Ã£o no terminal!"
poetry add "pydantic[email]"
```

Ademais, se tentarmos criar um usuÃ¡rio com um email invÃ¡lido, o Pydantic irÃ¡ automaticamente validar o campo e retornar um erro Ãºtil. Isso nos poupa muito trabalho de validaÃ§Ã£o manual e ajuda a manter nossa API robusta e confiÃ¡vel.


## Implementando as Rotas CRUD

CRUD Ã© um acrÃ´nimo que representa as quatro operaÃ§Ãµes bÃ¡sicas que vocÃª pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): Adicionar novos registros ao banco de dados. No HTTP, essa aÃ§Ã£o Ã© geralmente associada ao verbo POST.
- **R**ead (Ler): Recuperar registros existentes do banco de dados. No HTTP, essa aÃ§Ã£o Ã© geralmente associada ao verbo GET.
- **U**pdate (Atualizar): Modificar registros existentes no banco de dados. No HTTP, essa aÃ§Ã£o Ã© geralmente associada ao verbo PUT ou PATCH.
- **D**elete (Excluir): Remover registros existentes do banco de dados. No HTTP, essa aÃ§Ã£o Ã© geralmente associada ao verbo DELETE.

Os cÃ³digos de status HTTP sÃ£o usados para indicar o resultado de cada operaÃ§Ã£o CRUD. Por exemplo, uma solicitaÃ§Ã£o POST bem-sucedida (create) retorna o status HTTP 201 (Criado), enquanto uma solicitaÃ§Ã£o GET bem-sucedida (read) retorna o status HTTP 200 (OK).

Ã‰ importante notar que, ao trabalhar com FastAPI e Pydantic, nossos esquemas desempenham um papel vital na operaÃ§Ã£o de "Create" (criar). Ao usar a operaÃ§Ã£o POST para adicionar um novo registro ao nosso banco de dados, aproveitaremos a validaÃ§Ã£o de dados do Pydantic para garantir que o novo registro esteja conforme o esquema do nosso modelo de dados. Se os dados enviados na solicitaÃ§Ã£o POST nÃ£o passarem na validaÃ§Ã£o do Pydantic, nossa API retornarÃ¡ um cÃ³digo de status HTTP 422 (Unprocessable Entity), indicando que os dados fornecidos sÃ£o invÃ¡lidos ou incompletos.

Agora que temos uma compreensÃ£o clara do que Ã© o CRUD, como se relaciona com os verbos HTTP, os cÃ³digos de status e a validaÃ§Ã£o do Pydantic, podemos passar para a implementaÃ§Ã£o dessas operaÃ§Ãµes em nossa API FastAPI.

Na nossa API, criaremos rotas correspondentes para cada uma das operaÃ§Ãµes do CRUD, comeÃ§ando com a operaÃ§Ã£o "create" (criar), que serÃ¡ implementada pela rota POST.

### Implementando a Rota POST

A rota POST Ã© usada para criar um novo usuÃ¡rio em nosso sistema. Lembrando, o verbo HTTP POST estÃ¡ relacionado Ã  operaÃ§Ã£o "Create" do CRUD. Se tudo ocorrer como esperado e um novo usuÃ¡rio for criado com sucesso, a rota deve retornar o status HTTP 201 (Criado).

Para a criaÃ§Ã£o dessa rota, usaremos de base o JSON que criamos anteriormente. Para que a pessoa se cadastre na nossa plataforma, ela precisa enviar os dados de nome de usuÃ¡rio, email e senha:

```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para isso, criaremos um esquema Pydantic equivalente em um arquivo de esquemas: `fast_zero/schemas.py`:

```python title="fast_zero/schemas.py" linenums="1"
from pydantic import BaseModel, EmailStr


class UserSchema(BaseModel):
    username: str
    email: EmailStr
    password: str
```

Agora criaremos nosso endpoint que esperarÃ¡ receber esse esquema Pydantic e retornarÃ¡ 201, caso o JSON enviado seja vÃ¡lido:

```python title="fast_zero/app.py"
from fastapi import FastAPI
from fast_zero.schemas import UserSchema

# CÃ³digo da nossa rota de olÃ¡ mundo omitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    return user
```

Com esse endpoint criado, podemos executar a nossa aplicaÃ§Ã£o:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task run
```

E acessar a pÃ¡gina [http://localhost:8000/docs](http://localhost:8000/docs). Isso nos mostrarÃ¡ as definiÃ§Ãµes do nosso endpoint usando o Swagger.

![descriÃ§Ã£o](assets/02_swagger.png){: .center }

Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.

![descriÃ§Ã£o](assets/02_swagger_com_request.png){: .center }

Entretanto, precisamos prestar atenÃ§Ã£o a um detalhe: nosso modelo retorna a senha do usuÃ¡rio, o que Ã© uma pÃ©ssima prÃ¡tica de seguranÃ§a.

![descriÃ§Ã£o](assets/02_respsota_do_swagger.png){: .center }

Para evitar isso, podemos criar um novo modelo que serÃ¡ usado somente para resposta. Dessa forma, nÃ£o expomos os dados que nÃ£o queremos na API:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Precisamos tambÃ©m dizer ao FastAPI que esse serÃ¡ o modelo de resposta, e converter nosso `user` em `UserPublic`:


```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# cÃ³digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Note que somente adicionando o `response_model`, o FastAPI jÃ¡ faz a conversÃ£o de `UserSchema` em `UserPublic`

Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.

![descriÃ§Ã£o](assets/02_swagger_sem_senha.png){: .center }

[TODO: Mudar isso para aula 02]

??? tip "Caso nunca tenha usado o Swagger"
	Temos uma live focada em OpenAPI, que sÃ£o as especificaÃ§Ãµes do Swagger
	![type:video](https://www.youtube.com/embed/TfGHNBaK9a0)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/TfGHNBaK9a0){ .md-button }

#### Criando um banco de dados falso

Finalmente, para brincar com essas rotas, podemos criar uma lista provisÃ³ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provisÃ³ria para o "banco" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import UserSchema, UserPublic, UserDB

# cÃ³digo omitido

database = []  # provisÃ³rio para estudo!


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)

    database.append(user_with_id)

    return user_with_id
```

Se queremos uma simulaÃ§Ã£o de banco de dados, precisamos ter um `ID` para cada usuÃ¡rio registrado no nosso "banco". Sendo assim, alteraremos nosso modelo de resposta pÃºblica (`UserPublic`) para que ele forneÃ§a o ID de criaÃ§Ã£o do usuÃ¡rio. TambÃ©m criaremos um novo modelo que represente o usuÃ¡rio com sua senha e identificador, que chamaremos de `UserDB`:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Dessa forma, nada muda. No entanto, podemos prosseguir com a construÃ§Ã£o dos outros endpoints. E lembre-se, Ã© importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.


#### Implementando o teste da rota POST

Antes de criar o teste de fato, executaremos a task de teste para ver como anda a nossa cobertura:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descriÃ§Ã£o](assets/02_cobertura_get_sem_testes.png){: .center }

EntÃ£o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a criaÃ§Ã£o de um novo usuÃ¡rio funciona corretamente. Enviamos uma solicitaÃ§Ã£o POST com um novo usuÃ¡rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta contÃ©m o novo usuÃ¡rio criado.

```python title="tests/test_app.py"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### NÃ£o se repita (DRY)

VocÃª deve ter notado que a linha `client = TestClient(app)` estÃ¡ repetida na primeira linha dos dois testes que fizemos. Repetir cÃ³digo pode tornar o gerenciamento de testes mais complexo Ã  medida que cresce, e Ã© aqui que o princÃ­pio de "NÃ£o se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a reduÃ§Ã£o da repetiÃ§Ã£o, criando um cÃ³digo mais limpo e manutenÃ­vel.

Para solucionar essa repetiÃ§Ã£o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture Ã© como uma funÃ§Ã£o que prepara dados ou estado necessÃ¡rios para o teste. Pode ser pensada como uma forma de nÃ£o repetir a fase de Arrange de um teste, simplificando a chamada e nÃ£o repetindo cÃ³digo.

??? info "Se fixtures sÃ£o uma novidade para vocÃª"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` Ã© um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes mÃ³dulos de teste em um projeto. Ã‰ uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app

@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a criaÃ§Ã£o do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py"
# ...

def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')
	# ...

def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    # ...
```

Com essa simples mudanÃ§a, conseguimos tornar nosso cÃ³digo mais limpo e fÃ¡cil de manter, seguindo o princÃ­pio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST estÃ¡ implementada, seguiremos para a prÃ³xima operaÃ§Ã£o CRUD: Read.

### Implementando a Rota GET

A rota GET Ã© usada para recuperar informaÃ§Ãµes de um ou mais usuÃ¡rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET estÃ¡ associado Ã  operaÃ§Ã£o "Read". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representarÃ¡ uma lista de usuÃ¡rios e contÃ©m apenas um campo chamado `users`, que Ã© uma lista de `UserPublic`. Isso nos permite retornar mÃºltiplos usuÃ¡rios de uma vez.

```python title="fast_zero/schemas.py" linenums="20"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornarÃ¡ uma instÃ¢ncia de `UserList`, que por sua vez contÃ©m uma lista de `UserPublic`. Cada `UserPublic` Ã© criado a partir dos dados de um usuÃ¡rio em nosso banco de dados fictÃ­cio.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList

# cÃ³digo omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementaÃ§Ã£o, nossa API agora pode retornar uma lista de usuÃ¡rios. No entanto, nosso trabalho ainda nÃ£o acabou. A prÃ³xima etapa Ã© escrever testes para garantir que nossa rota GET estÃ¡ funcionando corretamente. Isso nos ajudarÃ¡ a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementaÃ§Ã£o de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recuperaÃ§Ã£o dos usuÃ¡rios estÃ¡ funcionando corretamente. Enviamos uma solicitaÃ§Ã£o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m a lista de usuÃ¡rios.

```python title="tests/test_app.py" linenums="30"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usuÃ¡rios. Implementaremos a prÃ³xima operaÃ§Ã£o CRUD: Update.

### Implementando a Rota PUT

A rota PUT Ã© usada para atualizar as informaÃ§Ãµes de um usuÃ¡rio existente. No contexto do CRUD, o verbo HTTP PUT estÃ¡ associado Ã  operaÃ§Ã£o "Update". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

```python title="fast_zero/app.py"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id

    return user_with_id
```

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualizaÃ§Ã£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o PUT com as novas informaÃ§Ãµes do usuÃ¡rio para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m o usuÃ¡rio atualizado.

```python title="tests/test_app.py"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usuÃ¡rios. A Ãºltima operaÃ§Ã£o CRUD que precisamos implementar Ã© Delete.

### Implementando a Rota DELETE

A rota DELETE Ã© usada para excluir um usuÃ¡rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE estÃ¡ associado Ã  operaÃ§Ã£o "Delete". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

[TODO: Esse tÃ³pico foi coberto na aula anterior]

Para transmitir uma mensagem de sucesso ou falha na operaÃ§Ã£o de exclusÃ£o, podemos criar um modelo chamado `Message`. Esse modelo serÃ¡ responsÃ¡vel por embalar uma mensagem que serÃ¡ retornada na nossa API.

```python title="fast_zero/schemas.py" linenums="20"
class Message(BaseModel):
    detail: str
```

Agora podemos criar nosso endpoint DELETE. Este endpoint receberÃ¡ o ID do usuÃ¡rio que queremos excluir. Note que, estamos lanÃ§ando uma exceÃ§Ã£o HTTP quando o ID do usuÃ¡rio estÃ¡ fora do range da nossa lista (simulaÃ§Ã£o do nosso banco de dados). Quando conseguimos excluir o usuÃ¡rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message

# ...

@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'detail': 'User deleted'}
```

Com a implementaÃ§Ã£o da rota DELETE concluÃ­da, Ã© fundamental garantirmos que essa rota estÃ¡ funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclusÃ£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m uma mensagem informando que o usuÃ¡rio foi excluÃ­do.

```python title="tests/test_app.py"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'detail': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, Ã© uma boa prÃ¡tica checarmos todo o cÃ³digo, e podemos fazer isso com as aÃ§Ãµes que criamos com o taskipy.

```shell title="$ ExecuÃ§Ã£o no terminal!"
$ task lint
All done! âœ¨ ğŸ° âœ¨
5 files would be left unchanged.

$ task format
All done! âœ¨ ğŸ° âœ¨
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

ApÃ³s toda essa jornada de aprendizado, construÃ§Ã£o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares Ã© uma boa prÃ¡tica, pois mantÃ©m um histÃ³rico detalhado das alteraÃ§Ãµes e facilita a volta a uma versÃ£o anterior do cÃ³digo, se necessÃ¡rio.

Primeiramente, verificaremos as alteraÃ§Ãµes feitas no projeto com o comando `git status`. Este comando nos mostrarÃ¡ todos os arquivos modificados que ainda nÃ£o foram incluÃ­dos em um commit.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git status
```

Em seguida, adicionaremos todas as alteraÃ§Ãµes para o prÃ³ximo commit. O comando `git add .` adiciona todas as alteraÃ§Ãµes feitas em todos os arquivos do projeto.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no histÃ³rico do nosso projeto. Ã‰ importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou nÃ³s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ ExecuÃ§Ã£o no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas alteraÃ§Ãµes para o repositÃ³rio remoto com `git push`. Se vocÃª tiver vÃ¡rias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git push
```

E pronto! As alteraÃ§Ãµes estÃ£o seguras no histÃ³rico do git, e podemos continuar com o prÃ³ximo passo do projeto.

## ConclusÃ£o

Com a implementaÃ§Ã£o bem-sucedida das rotas CRUD, demos um passo significativo na construÃ§Ã£o de uma API robusta e funcional com FastAPI. Agora podemos manipular usuÃ¡rios - criar, ler, atualizar e excluir - o que Ã© fundamental para muitos sistemas de informaÃ§Ã£o.

O papel dos testes em cada etapa nÃ£o pode ser subestimado. Testes nÃ£o apenas nos ajudam a assegurar que nosso cÃ³digo estÃ¡ funcionando como esperado, mas tambÃ©m nos permitem refinar nossas soluÃ§Ãµes e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a importÃ¢ncia de executar seus testes sempre que fizer uma alteraÃ§Ã£o em seu cÃ³digo!

AtÃ© aqui, no entanto, trabalhamos com um "banco de dados" provisÃ³rio, na forma de uma lista Python, que Ã© volÃ¡til e nÃ£o persiste os dados de uma execuÃ§Ã£o do aplicativo para outra. Para nosso aplicativo ser Ãºtil em um cenÃ¡rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. Ã‰ aÃ­ que os bancos de dados entram.

No prÃ³ximo tÃ³pico, exploraremos uma das partes mais crÃ­ticas de qualquer aplicativo - a conexÃ£o e interaÃ§Ã£o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persistÃªncia de nossos dados de usuÃ¡rio entre as sessÃµes do aplicativo.
