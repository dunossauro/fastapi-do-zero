---
title: Estruturando o Projeto e Criando Rotas CRUD
description: Entendimento bÃ¡sico sobre API, HTTP, JSON e a estrutura do projeto
---

# [WIP] Estruturando o Projeto e Criando Rotas CRUD

---

Objetivos dessa aula:

- Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na validaÃ§Ã£o e serializaÃ§Ã£o de dados
- ImplementaÃ§Ã£o de rotas CRUD em FastAPI
- Escrita e execuÃ§Ã£o de testes para validar o comportamento das rotas

??? tip "Caso prefira ver a aula em vÃ­deo"
	Esse aula ainda nÃ£o estÃ¡ disponÃ­vel em formato de vÃ­deo, somente em texto!

	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_03.pdf){ .md-button }
[CÃ³digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/03){ .md-button }

---

Boas-vindas de volta Ã  nossa sÃ©rie de aulas sobre a construÃ§Ã£o de uma aplicaÃ§Ã£o utilizando FastAPI. Na Ãºltima aula, abordamos conceitos bÃ¡sicos do desenvolvimento web e finalizamos a configuraÃ§Ã£o do nosso ambiente. Hoje, avanÃ§aremos na estruturaÃ§Ã£o dos primeiros endpoints da nossa API, concentrando-nos nas quatro operaÃ§Ãµes fundamentais de **CRUD** - Criar, Ler, Atualizar e Deletar. Exploraremos como estas operaÃ§Ãµes se aplicam tanto Ã  comunicaÃ§Ã£o web quanto Ã  interaÃ§Ã£o com o banco de dados.

O objetivo desta aula Ã© implementar um sistema de cadastro de usuÃ¡rios na nossa aplicaÃ§Ã£o. Ao final, vocÃª conseguirÃ¡ cadastrar, listar, alterar e deletar usuÃ¡rios, alÃ©m de realizar testes para validar estas funcionalidades.

## CRUD e HTTP

No mundo do desenvolvimento de APIs, existem algumas operaÃ§Ãµes bÃ¡sicas que gostarÃ­amos de fazer com os dados. Essas operaÃ§Ãµes se relacionam com a base de dados e a aplicaÃ§Ã£o web. Vamos nos focar nesse primeiro momento nas relaÃ§Ãµes entre os dados.

CRUD Ã© um acrÃ´nimo que representa as quatro operaÃ§Ãµes bÃ¡sicas que vocÃª pode realizar em qualquer banco de dados persistente:

- **C**reate (Criar): adicionar novos registros ao banco de dados.
- **R**ead (Ler): recuperar registros existentes do banco de dados. 
- **U**pdate (Atualizar): modificar registros existentes no banco de dados.
- **D**elete (Excluir): remover registros existentes do banco de dados.

Com essas operaÃ§Ãµes podemos realizar qualquer tipo de comportamento em uma base dados. Podemos criar um registro, em seguida alterÃ¡-lo, quem sabe depois disso tudo deletÃ¡-lo.

Quando falamos de APIs servindo dados, todas essas operaÃ§Ãµes tÃªm alguma forma similar no protocolo HTTP. O protocolo tem verbos para indicar essas mesmas aÃ§Ãµes que queremos representar no banco de dados.

- **POST**: Ã© usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.
- **GET**: Ã© usado para quando o cliente deseja requisitar uma informaÃ§Ã£o do servidor.
- **PUT**: Ã© usando no momento em que o cliente deseja informar alguma alteraÃ§Ã£o nos dados para o servidor.
- **DELETE**: usado para dizer ao servidor que delete determinado recurso.

Dessa forma podemos criar associaÃ§Ãµes entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, nÃ³s como clientes devemos comunicar essa intenÃ§Ã£o ao servidor usando o mÃ©todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de *create* na base de dados.

### Respostas da API

A forma de responder o cliente como as operaÃ§Ãµes do CRUD se sucederam no servidor Ã© via cÃ³digos de status. Por isso vamos investir mais algum momento aqui.

Os cÃ³digos que devemos prestar atenÃ§Ã£o para responder de forma correta as requisiÃ§Ãµes. Os casos de sucesso incluem:

- **200 OK**: Indica sucesso na requisiÃ§Ã£o.
    - **GET**: Quando um dado Ã© solicitado e retornado com sucesso.
	- **PUT**: Quando dados sÃ£o alterados com sucesso.
- **201 CREATED**: Significa que a solicitaÃ§Ã£o resultou na criaÃ§Ã£o de um novo recurso.
	- **POST**: AplicÃ¡vel quando um dado Ã© enviado e criado com sucesso.
	- **PUT**: Usado quando uma alteraÃ§Ã£o resulta na criaÃ§Ã£o de um novo recurso.
- **204 NO CONTENT**: Retorno do servidor sem conteÃºdo na mensagem.
	- **PUT**: AplicÃ¡vel se a alteraÃ§Ã£o nÃ£o gerar um retorno.
	- **DELETE**: Usado quando a aÃ§Ã£o de deletar nÃ£o gera um retorno.

Os cÃ³digos de erro mais comuns que temos que conhecer para lidar com possÃ­veis erros na aplicaÃ§Ã£o, sÃ£o:

- **404 NOT FOUND**: O recurso solicitado nÃ£o pÃ´de ser encontrado.
- **422 UNPROCESSABLE ENTITY**: o pedido foi bem formado (ou seja, sintaticamente correto), mas nÃ£o pÃ´de ser processado.
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro genÃ©rica, dada quando uma condiÃ§Ã£o inesperada foi encontrada. Geralmente ocorre quando nossa aplicaÃ§Ã£o apresenta um erro.

Compreendendo esses cÃ³digos, estamos prontos para iniciar a implementaÃ§Ã£o de alguns endpoints e colocar esses conceitos em prÃ¡tica.

## Implementado endpoints

Para facilitar o aprendizado, sugiro dividir a criaÃ§Ã£o de novos endpoints em trÃªs etapas:

1. RelaÃ§Ã£o com o HTTP: Determinar o verbo HTTP esperado e os cÃ³digos de resposta para situaÃ§Ãµes de sucesso e erro.
2. Modelos de Dados: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de resposta para situaÃ§Ãµes de sucesso e erro.
3. ImplementaÃ§Ã£o do Corpo: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado.

As duas primeiras etapas nos ajudam a definir a interface de comunicaÃ§Ã£o e como ela serÃ¡ documentada. A terceira etapa Ã© mais especÃ­fica e envolve decisÃµes sobre a interaÃ§Ã£o com o banco de dados, validaÃ§Ãµes adicionais e a definiÃ§Ã£o do que constitui sucesso ou erro na requisiÃ§Ã£o.

Essas etapas nos orientam na implementaÃ§Ã£o completa do endpoint, garantindo que nada seja esquecido.

## Iniciando a implementaÃ§Ã£o da rota POST

Nesta aula, nosso foco principal serÃ¡ desenvolver um sistema de cadastro de usuÃ¡rios. Para isso, a implementaÃ§Ã£o de uma forma eficiente para criar novos usuÃ¡rios na base de dados Ã© essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao serviÃ§o a nossa intenÃ§Ã£o de enviar novos dados, como no cadastro de usuÃ¡rios..

### ImplementaÃ§Ã£o do endpoint

Para iniciar, criaremos um endpoint que aceita o verbo `POST` com dados em formato JSON. Esse endpoint responderÃ¡ com o status `201` em caso de sucesso na criaÃ§Ã£o do recurso. Com isso, estabelecemos a base para a nossa funcionalidade de cadastro.

Usaremos o decorador `#!python @app.post()` do FastAPI para definir nosso endpoint, que comeÃ§arÃ¡ com a URL `/users/`, indicando onde receberemos os dados para criar novos usuÃ¡rios:

```python title="fast_zero/app.py" linenums="13"
@app.post('/users/')
def create_user():
	...
```

#### Status code de resposta

Ã‰ crucial definir que, ao cadastrar um usuÃ¡rio com sucesso, o sistema deve retornar o cÃ³digo de resposta `#!python 201`, indicando a criaÃ§Ã£o bem-sucedida do recurso. Para isso, adicionamos o parÃ¢metro `status_code` ao decorador:

```python title="fast_zero/app.py" linenums="13" hl_lines="1"
@app.post('/users/', status_code=201)
def create_user():
    ...
```

> Conversaremos em breve sobre o cÃ³digo de resposta em [TODO: tÃ³pico do pydantic]

### [WIP] Modelo de dados

O modelo de dados Ã© uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que serÃ£o retornados a ele. Esta abordagem assegura uma comunicaÃ§Ã£o eficaz e clara.

#### Modelo de entrada de dados

Para os dados de entrada, como estamos pensando em um cadastro de usuÃ¡rio na aplicaÃ§Ã£o, Ã© importante que tenhamos insumos para identificÃ¡-lo como o `email`, uma senha (`password`) para que ele consiga fazer o login no futuro e seu nome de usuÃ¡rio (`username`). Dessa forma, podemos imaginar um modelo de entrada desta forma:


```json
{
    "username": "joao123",
    "email": "joao123@email.com",
    "password": "segredo123"
}
```

Para a aplicaÃ§Ã£o conseguir expor esse modelo na documentaÃ§Ã£o, devemos criar uma classe do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) que represente esse schema:

```python title="fast_zero/schemas.py" linenums="8"
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```

Como jÃ¡ temos o endpoint definido, precisamos fazer a associaÃ§Ã£o do modelo com ele. Para fazer isso basta que o endpoint receba um parÃ¢metro e esse parÃ¢metro esteja associado a um modelo via anotaÃ§Ã£o de parÃ¢metros:

```python title="fast_zero/app.py" hl_lines="6"
from fast_zero.schemas import Message, UserSchema

# CÃ³digo do olÃ¡ mundo homitido

@app.post('/users/', status_code=201)
def create_user(user: UserSchema):
    ...
```

Dessa forma, o modelo de entrada, o que o endpoint espera receber jÃ¡ estÃ¡ documentado e aparecerÃ¡ no swagger UI.

Para visualizar, temos que iniciar o servidor:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task run
```

E acessar a pÃ¡gina [http://127.0.01:8000/docs](http://localhost:8000/docs){:target="_blank"}. Isso nos mostrarÃ¡ as definiÃ§Ãµes do nosso endpoint usando o o modelo no swagger:

![Captura de tela do swagger UI exibindo o modelo do pydantic descrito acima](assets/03/swagger_exibindo_o_schema_de_entrada_de_create_user.png){: .center width="600" }

#### Modelo de saÃ­da de dados

O modelo de saÃ­da explica ao cliente quais dados serÃ£o retornados quando a chamada a esse endpoint for feita. Para a API ter um uso fluÃ­do, temos que especificar o retorno corretamente na documentaÃ§Ã£o.

Se dermos uma olhada no estado atual de resposta da nossa API, podemos ver que a resposta no swagger Ã© `#!python "string"` para o cÃ³digo de resposta `#!python 201`:

![descriÃ§Ã£o](assets/03/swagger_sem_modelo_de_resposta.png){: .center .shadow }

Quando fazemos uma chamada com o mÃ©todo POST o esperado Ã© que os dados criados sejam retornados ao cliente. PoderÃ­amos usar o mesmo modelo de antes o `UserSchema`, porÃ©m, por uma questÃ£o de seguranÃ§a, seria ideal nÃ£o retornar a senha do usuÃ¡rio. Quanto menos ela trafegar na rede, melhor.

Desta forma, podemos pensar no mesmo schema, porÃ©m, sem a senha. Algo como:

```json
{
    "username": "joao123",
    "email": "joao123@email.com"
}
```

Transcrevendo isso em um modelo do pydantic em nosso arquivo de schemas (`fast_zero/schemas.py`) temos isso:

```python title="fast_zero/schemas.py" linenums="14"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Para aplicar um modelo a resposta do endpoint, temos que passar o modelo ao parÃ¢metro `response_model`, como fizemos na [aula passada](02/#integrando-o-pydantic-com-o-fastapi){:target="_blank"}:

```py title="aula_00.py" linenums="1" hl_lines="1 5"
from fast_zero.schemas import Message, UserSchema, UserPublic

# CÃ³digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    ...
```

Tendo um modelo descritivo de resposta para o cliente na documentaÃ§Ã£o:

![descriÃ§Ã£o](assets/03/modelo_de_resposta_do_swagger.png){: .center .shadow }


## ValidaÃ§Ã£o e pydantic

Uma caracterÃ­stica importante do Pydantic e que deve ser considerada Ã© o fato de ele validar os schemas em tempo de execuÃ§Ã£o. Fazendo com que caso o cliente envie um dado que nÃ£o corresponde com o schema definido, seja levantado um erro `#!python 422`. E caso a nossa resposta como servidor tambÃ©m nÃ£o siga o schema, serÃ¡ levantado um erro `#!python 500`. Fazendo com que ele seja uma garantia de duas vias que nossa API segue a especificaÃ§Ã£o da documentaÃ§Ã£o.

> TODO: Mostrar o erro 422 no swagger

> TODO: Fazer uma requisiÃ§Ã£o que nÃ£o siga o schema

> TODO: Ver a resposta do 422

> TODO: Conversar sobre a implementaÃ§Ã£o do nosso endpoint e ver que ela nÃ£o retorna nada.

> TODO: Fazer uma requisiÃ§Ã£o correta e mostrar o erro 500

Vamos usar o endpoint em seu estado atual, sem nenhuma resposta e ver o que acontecerÃ¡ com a nossa requisiÃ§Ã£o.

## De volta ao POST

---

> Texto Antigo!!!

Com esse endpoint criado, podemos executar a nossa aplicaÃ§Ã£o:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task run
```

E acessar a pÃ¡gina [http://localhost:8000/docs](http://localhost:8000/docs). Isso nos mostrarÃ¡ as definiÃ§Ãµes do nosso endpoint usando o Swagger.

![descriÃ§Ã£o](assets/03/swagger.png){: .center }

Dessa forma, podemos testar de forma simplificada a nossa API, enviando o JSON e realizando alguns testes.

![descriÃ§Ã£o](assets/03/swagger_com_request.png){: .center }

Entretanto, precisamos prestar atenÃ§Ã£o a um detalhe: nosso modelo retorna a senha do usuÃ¡rio, o que Ã© uma pÃ©ssima prÃ¡tica de seguranÃ§a.

![descriÃ§Ã£o](assets/03/respsota_do_swagger.png){: .center }

Para evitar isso, podemos criar um novo modelo que serÃ¡ usado somente para resposta. Dessa forma, nÃ£o expomos os dados que nÃ£o queremos na API:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    username: str
    email: EmailStr
```

Precisamos tambÃ©m dizer ao FastAPI que esse serÃ¡ o modelo de resposta, e converter nosso `user` em `UserPublic`:


```python title="fast_zero/app.py" hl_lines="5"
from fast_zero.schemas import UserSchema, UserPublic

# cÃ³digo omitido

@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    return user
```

Note que somente adicionando o `response_model`, o FastAPI jÃ¡ faz a conversÃ£o de `UserSchema` em `UserPublic`

Agora, se fizermos de novo a chamada no Swagger, receberemos o mesmo objeto, mas sem expor a senha.

![descriÃ§Ã£o](assets/03/swagger_sem_senha.png){: .center }

### Criando um banco de dados falso

Finalmente, para brincar com essas rotas, podemos criar uma lista provisÃ³ria para simular um banco de dados. Assim, podemos adicionar nossos dados e entender como o FastAPI funciona. Para isso, adicionamos uma lista provisÃ³ria para o "banco" e alteramos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:


```python title="fast_zero/app.py" hl_lines="5 10-14"
from fast_zero.schemas import UserSchema, UserPublic, UserDB

# cÃ³digo omitido

database = []  # provisÃ³rio para estudo!


@app.post('/users/', status_code=201, response_model=UserPublic)
def create_user(user: UserSchema):
    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)

    database.append(user_with_id)

    return user_with_id
```

Se queremos uma simulaÃ§Ã£o de banco de dados, precisamos ter um `ID` para cada usuÃ¡rio registrado no nosso "banco". Sendo assim, alteraremos nosso modelo de resposta pÃºblica (`UserPublic`) para que ele forneÃ§a o ID de criaÃ§Ã£o do usuÃ¡rio. TambÃ©m criaremos um novo modelo que represente o usuÃ¡rio com sua senha e identificador, que chamaremos de `UserDB`:

```python title="fast_zero/schemas.py" linenums="10"
class UserPublic(BaseModel):
    id: int
    username: str
    email: EmailStr


class UserDB(UserSchema):
    id: int
```

Dessa forma, nada muda. No entanto, podemos prosseguir com a construÃ§Ã£o dos outros endpoints. E lembre-se, Ã© importante testar esse endpoint para garantir que tudo esteja funcionando corretamente.


### Implementando o teste da rota POST

Antes de criar o teste de fato, executaremos a task de teste para ver como anda a nossa cobertura:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      3    75%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      3    87%

# parte da resposta foi omitida
```

Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.

![descriÃ§Ã£o](assets/03/cobertura_get_sem_testes.png){: .center }

EntÃ£o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a criaÃ§Ã£o de um novo usuÃ¡rio funciona corretamente. Enviamos uma solicitaÃ§Ã£o POST com um novo usuÃ¡rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta contÃ©m o novo usuÃ¡rio criado.

```python title="tests/test_app.py"
def test_create_user():
    client = TestClient(app)

    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    assert response.status_code == 201
    assert response.json() == {
        'username': 'alice',
        'email': 'alice@example.com',
        'id': 1,
    }
```

Ao executar o teste:

```shell title="$ ExecuÃ§Ã£o no terminal!"
task test

# parte da resposta foi omitida

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py           12      0   100%
fast_zero/schemas.py       11      0   100%
-------------------------------------------
TOTAL                      23      0   100%

# parte da resposta foi omitida
```

#### NÃ£o se repita (DRY)

VocÃª deve ter notado que a linha `client = TestClient(app)` estÃ¡ repetida na primeira linha dos dois testes que fizemos. Repetir cÃ³digo pode tornar o gerenciamento de testes mais complexo Ã  medida que cresce, e Ã© aqui que o princÃ­pio de "NÃ£o se repita" ([DRY](https://pt.wikipedia.org/wiki/Don't_repeat_yourself){:target="_blank"}) entra em jogo. DRY incentiva a reduÃ§Ã£o da repetiÃ§Ã£o, criando um cÃ³digo mais limpo e manutenÃ­vel.

Para solucionar essa repetiÃ§Ã£o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture Ã© como uma funÃ§Ã£o que prepara dados ou estado necessÃ¡rios para o teste. Pode ser pensada como uma forma de nÃ£o repetir a fase de Arrange de um teste, simplificando a chamada e nÃ£o repetindo cÃ³digo.

??? info "Se fixtures sÃ£o uma novidade para vocÃª"
	Existe uma live de Python onde discutimos especificamente sobre fixtures
	![type:video](https://www.youtube.com/embed/sidi9Z_IkLU)

	[:fontawesome-brands-youtube: Link direto ](https://youtu.be/sidi9Z_IkLU){ .md-button }


Neste caso, criaremos uma fixture que retorna nosso `client`. Para fazer isso, precisamos criar o arquivo `tests/conftest.py`. O arquivo `conftest.py` Ã© um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes mÃ³dulos de teste em um projeto. Ã‰ uma forma de centralizar recursos comuns de teste.


```python title="tests/conftest.py"
import pytest
from fastapi.testclient import TestClient
from fast_zero.app import app

@pytest.fixture
def client():
    return TestClient(app)
```

Agora, em vez de repetir a criaÃ§Ã£o do `client` em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:

```python title="tests/test_app.py"
# ...

def test_root_deve_retornar_200_e_ola_mundo(client):
    response = client.get('/')
	# ...

def test_create_user(client):
    response = client.post(
        '/users/',
        json={
            'username': 'alice',
            'email': 'alice@example.com',
            'password': 'secret',
        },
    )
    # ...
```

Com essa simples mudanÃ§a, conseguimos tornar nosso cÃ³digo mais limpo e fÃ¡cil de manter, seguindo o princÃ­pio DRY.

---

Vemos que estamos no caminho certo. Agora que a rota POST estÃ¡ implementada, seguiremos para a prÃ³xima operaÃ§Ã£o CRUD: Read.

## Implementando a Rota GET

A rota GET Ã© usada para recuperar informaÃ§Ãµes de um ou mais usuÃ¡rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET estÃ¡ associado Ã  operaÃ§Ã£o "Read". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).

Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado `UserList`. Este modelo representarÃ¡ uma lista de usuÃ¡rios e contÃ©m apenas um campo chamado `users`, que Ã© uma lista de `UserPublic`. Isso nos permite retornar mÃºltiplos usuÃ¡rios de uma vez.

```python title="fast_zero/schemas.py" linenums="20"
class UserList(BaseModel):
    users: list[UserPublic]
```

Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornarÃ¡ uma instÃ¢ncia de `UserList`, que por sua vez contÃ©m uma lista de `UserPublic`. Cada `UserPublic` Ã© criado a partir dos dados de um usuÃ¡rio em nosso banco de dados fictÃ­cio.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList

# cÃ³digo omitido

@app.get('/users/', response_model=UserList)
def read_users():
    return {'users': database}
```

Com essa implementaÃ§Ã£o, nossa API agora pode retornar uma lista de usuÃ¡rios. No entanto, nosso trabalho ainda nÃ£o acabou. A prÃ³xima etapa Ã© escrever testes para garantir que nossa rota GET estÃ¡ funcionando corretamente. Isso nos ajudarÃ¡ a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementaÃ§Ã£o de outras rotas.

#### Implementando o teste da rota de GET

Nosso teste da rota GET tem que verificar se a recuperaÃ§Ã£o dos usuÃ¡rios estÃ¡ funcionando corretamente. Enviamos uma solicitaÃ§Ã£o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m a lista de usuÃ¡rios.

```python title="tests/test_app.py" linenums="30"
def test_read_users(client):
    response = client.get('/users/')
    assert response.status_code == 200
    assert response.json() == {
        'users': [
            {
                'username': 'alice',
                'email': 'alice@example.com',
                'id': 1,
            }
        ]
    }
```

Com as rotas POST e GET implementadas, agora podemos criar e recuperar usuÃ¡rios. Implementaremos a prÃ³xima operaÃ§Ã£o CRUD: Update.

## Implementando a Rota PUT

A rota PUT Ã© usada para atualizar as informaÃ§Ãµes de um usuÃ¡rio existente. No contexto do CRUD, o verbo HTTP PUT estÃ¡ associado Ã  operaÃ§Ã£o "Update". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

```python title="fast_zero/app.py"
from fastapi import FastAPI, HTTPException

# ...

@app.put('/users/{user_id}', response_model=UserPublic)
def update_user(user_id: int, user: UserSchema):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    user_with_id = UserDB(**user.model_dump(), id=user_id)
    database[user_id - 1] = user_with_id

    return user_with_id
```

#### Implementando o teste da rota de PUT

Nosso teste da rota PUT precisa verificar se a atualizaÃ§Ã£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o PUT com as novas informaÃ§Ãµes do usuÃ¡rio para a rota `/users/{user_id}`. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m o usuÃ¡rio atualizado.

```python title="tests/test_app.py"
def test_update_user(client):
    response = client.put(
        '/users/1',
        json={
            'username': 'bob',
            'email': 'bob@example.com',
            'password': 'mynewpassword',
        },
    )
    assert response.status_code == 200
    assert response.json() == {
        'username': 'bob',
        'email': 'bob@example.com',
        'id': 1,
    }
```

Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usuÃ¡rios. A Ãºltima operaÃ§Ã£o CRUD que precisamos implementar Ã© Delete.

## Implementando a Rota DELETE

A rota DELETE Ã© usada para excluir um usuÃ¡rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE estÃ¡ associado Ã  operaÃ§Ã£o "Delete". Se a solicitaÃ§Ã£o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usuÃ¡rio solicitado nÃ£o for encontrado, deverÃ­amos retornar o status HTTP 404 (NÃ£o Encontrado).

[TODO: Texto foi removido daqui, confirmar a continuidade]

Agora podemos criar nosso endpoint DELETE. Este endpoint receberÃ¡ o ID do usuÃ¡rio que queremos excluir. Note que, estamos lanÃ§ando uma exceÃ§Ã£o HTTP quando o ID do usuÃ¡rio estÃ¡ fora do range da nossa lista (simulaÃ§Ã£o do nosso banco de dados). Quando conseguimos excluir o usuÃ¡rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo `Message`.

```python title="fast_zero/app.py"
from fast_zero.schemas import UserSchema, UserPublic, UserDB, UserList, Message

# ...

@app.delete('/users/{user_id}', response_model=Message)
def delete_user(user_id: int):
    if user_id > len(database) or user_id < 1:
        raise HTTPException(status_code=404, detail='User not found')

    del database[user_id - 1]

    return {'detail': 'User deleted'}
```

Com a implementaÃ§Ã£o da rota DELETE concluÃ­da, Ã© fundamental garantirmos que essa rota estÃ¡ funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.

#### Implementando o teste da rota de DELETE

Nosso teste da rota DELETE precisa verificar se a exclusÃ£o de um usuÃ¡rio existente funciona corretamente. Enviamos uma solicitaÃ§Ã£o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta contÃ©m uma mensagem informando que o usuÃ¡rio foi excluÃ­do.

```python title="tests/test_app.py"
def test_delete_user(client):
    response = client.delete('/users/1')

    assert response.status_code == 200
    assert response.json() == {'detail': 'User deleted'}
```

#### Checando tudo antes do commit

Antes de fazermos o commit, Ã© uma boa prÃ¡tica checarmos todo o cÃ³digo, e podemos fazer isso com as aÃ§Ãµes que criamos com o taskipy.

```shell title="$ ExecuÃ§Ã£o no terminal!"
$ task lint
All done! âœ¨ ğŸ° âœ¨
5 files would be left unchanged.

$ task format
All done! âœ¨ ğŸ° âœ¨
5 files left unchanged.
Skipped 1 files

$ task test
...
tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
tests/test_app.py::test_create_user PASSED
tests/test_app.py::test_read_users PASSED
tests/test_app.py::test_update_user PASSED
tests/test_app.py::test_delete_user PASSED

---------- coverage: platform linux, python 3.11.4-final-0 -----------
Name                   Stmts   Miss  Cover
------------------------------------------
fastzero/__init__.py       0      0   100%
fastzero/app.py           28      2    93%
fastzero/schemas.py       15      0   100%
------------------------------------------
TOTAL                     43      2    95%


============================================ 5 passed in 1.48s =============================================
Wrote HTML report to htmlcov/index.html

```

## Commit

ApÃ³s toda essa jornada de aprendizado, construÃ§Ã£o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares Ã© uma boa prÃ¡tica, pois mantÃ©m um histÃ³rico detalhado das alteraÃ§Ãµes e facilita a volta a uma versÃ£o anterior do cÃ³digo, se necessÃ¡rio.

Primeiramente, verificaremos as alteraÃ§Ãµes feitas no projeto com o comando `git status`. Este comando nos mostrarÃ¡ todos os arquivos modificados que ainda nÃ£o foram incluÃ­dos em um commit.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git status
```

Em seguida, adicionaremos todas as alteraÃ§Ãµes para o prÃ³ximo commit. O comando `git add .` adiciona todas as alteraÃ§Ãµes feitas em todos os arquivos do projeto.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git add .
```

Agora, estamos prontos para fazer o commit. Com o comando `git commit`, criamos uma nova entrada no histÃ³rico do nosso projeto. Ã‰ importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou nÃ³s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser "Implementando rotas CRUD".

```shell title="$ ExecuÃ§Ã£o no terminal!"
git commit -m "Implementando rotas CRUD"
```

Por fim, enviamos nossas alteraÃ§Ãµes para o repositÃ³rio remoto com `git push`. Se vocÃª tiver vÃ¡rias branches, certifique-se de estar na branch correta antes de executar este comando.

```shell title="$ ExecuÃ§Ã£o no terminal!"
git push
```

E pronto! As alteraÃ§Ãµes estÃ£o seguras no histÃ³rico do git, e podemos continuar com o prÃ³ximo passo do projeto.

## ConclusÃ£o

Com a implementaÃ§Ã£o bem-sucedida das rotas CRUD, demos um passo significativo na construÃ§Ã£o de uma API robusta e funcional com FastAPI. Agora podemos manipular usuÃ¡rios - criar, ler, atualizar e excluir - o que Ã© fundamental para muitos sistemas de informaÃ§Ã£o.

O papel dos testes em cada etapa nÃ£o pode ser subestimado. Testes nÃ£o apenas nos ajudam a assegurar que nosso cÃ³digo estÃ¡ funcionando como esperado, mas tambÃ©m nos permitem refinar nossas soluÃ§Ãµes e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a importÃ¢ncia de executar seus testes sempre que fizer uma alteraÃ§Ã£o em seu cÃ³digo!

AtÃ© aqui, no entanto, trabalhamos com um "banco de dados" provisÃ³rio, na forma de uma lista Python, que Ã© volÃ¡til e nÃ£o persiste os dados de uma execuÃ§Ã£o do aplicativo para outra. Para nosso aplicativo ser Ãºtil em um cenÃ¡rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. Ã‰ aÃ­ que os bancos de dados entram.

No prÃ³ximo tÃ³pico, exploraremos uma das partes mais crÃ­ticas de qualquer aplicativo - a conexÃ£o e interaÃ§Ã£o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persistÃªncia de nossos dados de usuÃ¡rio entre as sessÃµes do aplicativo.
