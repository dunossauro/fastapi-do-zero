# [OK] Configurando o Ambiente de Desenvolvimento

---
Objetivos dessa aula:

- Introdu√ß√£o ao ambiente de desenvolvimento (terminal, ferramentas, etc.)
- Instala√ß√£o do FastAPI e suas depend√™ncias
- Configura√ß√£o das ferramentas de desenvolvimento
- Execu√ß√£o do primeiro "Hello, World!" com FastAPI com testes!

??? tip "Caso prefira ver a aula em v√≠deo"
	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](#){ .md-button }
[C√≥digo :fontawesome-solid-code:](https://github.com/dunossauro/fastapi-do-zero/tree/main/codigo_das_aulas/01/){ .md-button }

---

Nesta aula pr√°tica, vamos come√ßar nossa jornada na constru√ß√£o de uma API com FastAPI. Esse √© um moderno e r√°pido (altamente perform√°tico) framework web para constru√ß√£o de APIs com Python 3.7+ baseado em Python type hints.

Partiremos do b√°sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala√ß√£o da vers√£o correta do Python at√© a instala√ß√£o e configura√ß√£o do Poetry, um gerenciador de pacotes e depend√™ncias para Python. Al√©m disso, instalaremos e configuraremos uma s√©rie de ferramentas de desenvolvimento √∫teis, como Ruff, Blue, Isort, pytest e Taskipy.

Depois de configurado o nosso ambiente, criaremos nosso primeiro programa "Hello, World!" com FastAPI. Isso nos permitir√° confirmar que tudo est√° funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.


## Ambiente de Desenvolvimento

Para iniciar essa aula voc√™ vai precisar de algumas ferramentas.

1. Um editor de texto a sua escolha (Eu vou usar o GNU/Emacs)
2. Um terminal a sua escolha (Usarei o Terminator)
3. A vers√£o 3.11 do Python instalada.
	- Caso n√£o tenha essa vers√£o voc√™ pode baixar do site oficial
	- Ou instalar via [pyenv](https://github.com/pyenv/pyenv){:target="_blank"}
4. O [Poetry](https://python-poetry.org/){:target="_blank"} para gerenciar os pacotes e seu ambiente virtual
5. **OPCIONAL**: O [pipx](https://github.com/pypa/pipx){:target="_blank"} pode te ajudar bastante nesses momentos
6. Docker

## Instala√ß√£o do Python 3.11

Se voc√™ precisar reconstruir o ambiente usado nesse curso, √© recomendado que voc√™ use o [pyenv](https://github.com/pyenv/pyenv){:target="_blank"}.

Caso tenha problemas durante a instala√ß√£o. O pyenv conta com dois assistentes simplificados para sua configura√ß√£o. Para windows, use o [pyenv-windows](https://pyenv-win.github.io/pyenv-win/){:target="_blank"}. Para GNU/Linux e MacOS, use o [pyenv-installer](https://github.com/pyenv/pyenv-installer){:target="_blank"}.

Navegue at√© o diret√≥rio onde far√° os exerc√≠cios e executar√° os c√≥digos de exemplo no seu terminal e digite os seguintes comandos:

```shell title="$ Execu√ß√£o no terminal!"
pyenv update
pyenv install 3.11:latest
pyenv local 3.11.3  # Essa era a maior vers√£o do 3.11 quando escrevi
```

Certifique que o python rodando no seu ambiente √© mesmo o 3.11:


```shell title="$ Execu√ß√£o no terminal!"
python --version
```

A resposta esperada √© `Python 3.11.3`.

## Gerenciamento de Depend√™ncias com Poetry

Ap√≥s instalar o Python, o pr√≥ximo passo √© instalar o Poetry, um gerenciador de pacotes e depend√™ncias para Python. O Poetry facilita a cria√ß√£o, o gerenciamento e a distribui√ß√£o de pacotes Python.

Para instalar o Poetry, voc√™ pode seguir as instru√ß√µes presentes na documenta√ß√£o oficial do Poetry para o seu sistema operacional. Alternativamente, se voc√™ optou por usar o pipx, pode instalar o Poetry com o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
pipx install poetry
```

## Cria√ß√£o do Projeto FastAPI e Instala√ß√£o das Depend√™ncias

Agora que temos o Python e o Poetry prontos, podemos come√ßar a criar nosso projeto FastAPI.

Vamos inicialmente criar um novo diret√≥rio para nosso projeto e navegar para ele:

```shell title="$ Execu√ß√£o no terminal!"
poetry new fast_zero
cd fast_zero
```

Ele criar√° uma estrutura como essa:

```
.
‚îú‚îÄ‚îÄ fast_zero
‚îÇ  ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ poetry.lock
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tests
   ‚îî‚îÄ‚îÄ __init__.py
```

Em seguida, inicializaremos um novo projeto Python com Poetry e instalaremos as depend√™ncias necess√°rias - FastAPI e Uvicorn:

```shell title="$ Execu√ß√£o no terminal!"
poetry install
poetry add fastapi uvicorn
```

## Primeira Execu√ß√£o de um "Hello, World!"

Para garantir que tudo est√° configurado corretamente, vamos criar um pequeno programa "Hello, World!" com FastAPI. Em um novo arquivo chamado `app.py` no diret√≥rio `fast_zero` adicione o seguinte c√≥digo:


```python title="fast_zero/app.py" linenums="1"
from fastapi import FastAPI

app = FastAPI()

@app.get('/')
def read_root():
    return {'message': 'Ol√° Mundo!'}
```

Agora, podemos iniciar nosso servidor FastAPI com o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
poetry shell  # Para ativar o ambiente virtual
uvicorn fast_zero.app:app --reload
```

Acesse http://localhost:8000 no seu navegador, e voc√™ deve ver a mensagem "Hello, World!" em formato JSON.

![descri√ß√£o](assets/02_nagevador_com_localhost.png){: .center .shadow }

## Instalando as ferramentas de desenvolvimento

As ferramentas de desenvolvimento escolhidas podem variar de acordo com a prefer√™ncia pessoal. Nesta aula, utilizaremos algumas que s√£o particularmente √∫teis para demonstrar certos conceitos:

- taskipy: Ferramenta para automatizar alguns comandos e simplificar o fluxo
- ruff: Um linter, para dizer se n√£o estamos fazendo nada esquisito no c√≥digo
- blue: Um formatador de c√≥digo bastante amig√°vel
- isort: Uma ferramenta para ordenar os imports em ordem alfab√©tica
- pytest: Ferramenta para executar testes

Para instalar as depend√™ncias, podemos usar um grupo do poetry focado nelas, para n√£o serem usadas em produ√ß√£o:

```shell title="$ Execu√ß√£o no terminal!"
poetry add --group dev pytest pytest-cov taskipy blue ruff httpx
```

> O `HTTPX` foi inclu√≠do, pois ele √© uma depend√™ncia do cliente de testes do FastAPI.

## Configurando as ferramentas de desenvolvimento

Ap√≥s a instala√ß√£o das depend√™ncias, vamos precisar configurar todas as ferramentas de desenvolvimento no arquivo `pyproject.toml`.

### Ruff

Vamos usar o ruff na configura√ß√£o padr√£o. As √∫nicas altera√ß√µes que faremos ser√£o para que ele siga a PEP-8, usando 80 caracteres por linha e ignorando o ambiente virtual e pasta de migra√ß√µes do banco de dados:

```toml title="pyproject.toml" linenums="23"
[tool.ruff]
line-length = 79
exclude = ['.venv', 'migrations']
```

### isort

Vamos configurar o isort para o formato do Black, que coloca uma instru√ß√£o `import` por linha para evitar conflitos no git e tamb√©m usar a base da PEP-8 para 80 caracteres:

```toml title="pyproject.toml" linenums="27"
[tool.isort]
profile = "black"
line_length = 79
```

### pytest

Configuraremos o pytest para reconhecer o caminho base para execu√ß√£o dos testes na raiz do projeto `.`:

```toml title="pyproject.toml" linenums="31"
[tool.pytest.ini_options]
pythonpath = "."
```

### blue

Configuraremos o blue para excluir o caminho das migra√ß√µes quando essas forem utilizadas:

```toml title="pyproject.toml" linenums="34"
[tool.blue]
extend-exclude = '(migrations/)'
```

### Taskipy

Para simplificar a execu√ß√£o de certos comandos, vamos criar algumas tarefas com o Taskipy.

```toml title="pyproject.toml" linenums="37"
[tool.taskipy.tasks]
lint = 'ruff . && blue --check . --diff'
format = 'blue .  && isort .'
run = 'uvicorn fast_zero.app:app --reload'
pre_test = 'task lint'
test = 'pytest -s -x --cov=fast_zero -vv'
post_test = 'coverage html'
```

Os comandos definidos fazem o seguinte:

- lint: executa o ruff para ver se n√£o temos nenhum problema com o c√≥digo e checa se estamos de acordo com a PEP-8
- format: formata o c√≥digo usando blue e isort
- run: executa o servidor de desenvolvimento do FastAPI
- pre_test: executa a camada de lint antes de executar os teste
- test: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c√≥digo como base de cobertura
- post_test: gera um report de cobertura ap√≥s os testes


Para executar um comando, √© bem mais simples, precisando somente passar a palavra `task <comando>`.

??? warning "Caso precise ver o arquivo todo"

	O meu est√° exatamente assim:

	```toml title="pyproject.toml" linenums="1"
	[tool.poetry]
	name = "fast-zero"
	version = "0.1.0"
	description = ""
	authors = ["dunossauro <mendesxeduardo@gmail.com>"]
	readme = "README.md"
	packages = [{include = "fast_zero"}]

	[tool.poetry.dependencies]
	python = "^3.11"
	fastapi = "^0.100.0"
	uvicorn = "^0.22.0"


	[tool.poetry.group.dev.dependencies]
	pytest = "^7.4.0"
	pytest-cov = "^4.1.0"
	taskipy = "^1.11.0"
	blue = "^0.9.1"
	ruff = "^0.0.278"
	httpx = "^0.24.1"

	[tool.ruff]
	line-length = 79
	exclude = ['.venv', 'migrations']

	[tool.isort]
	profile = "black"
	line_length = 79

	[tool.pytest.ini_options]
	pythonpath = "."

	[tool.blue]
	extend-exclude = '(migrations/)'

	[tool.taskipy.tasks]
	lint = 'ruff . && blue --check . --diff'
	format = 'blue .  && isort .'
	run = 'uvicorn fast_zero.app:app --reload'
	pre_test = 'task lint'
	test = 'pytest -s -x --cov=fast_zero -vv'
	post_test = 'coverage html'

	[build-system]
	requires = ["poetry-core"]
	build-backend = "poetry.core.masonry.api"
	```


## Os efeitos dessas configura√ß√µes de desenvolvimento

Caso voc√™ tenha copiado o c√≥digo que usamos para definir `fast_zero/app.py`, pode testar os comandos que criamos para o `taskipy`:

```shell title="$ Execu√ß√£o no terminal!"
task lint
```

Dessa forma, veremos que cometemos algumas infra√ß√µes na formata√ß√£o da PEP-8. O blue nos informar√° que dever√≠amos ter adicionado duas linhas antes de uma defini√ß√£o de fun√ß√£o:


```diff
task lint
--- fast_zero/app.py    2023-07-12 21:40:14.590616 +0000
+++ fast_zero/app.py    2023-07-12 21:48:17.017190 +0000
@@ -1,7 +1,8 @@
 from fastapi import FastAPI
 
 app = FastAPI()
 
+
 @app.get('/')
 def read_root():
     return {'message': 'Ol√° Mundo!'}
would reformat fast_zero/app.py

Oh no! üí• üíî üí•
1 file would be reformatted, 2 files would be left unchanged.
```

Para corrigir isso, podemos usar o nosso comando de formata√ß√£o de c√≥digo:

=== "Comando"

	```shell title="$ Execu√ß√£o no terminal!"
	task format
	reformatted fast_zero/app.py

	All done! ‚ú® üç∞ ‚ú®
	1 file reformatted, 2 files left unchanged.
	Skipped 2 files
	```

=== "Resultado"
	```py title="fast_zero/app.py" linenums="1" hl_lines="5"
	from fastapi import FastAPI

	app = FastAPI()


	@app.get('/')
	def read_root():
		return {'message': 'Ol√° Mundo!'}
	```

## Introdu√ß√£o ao Pytest: Testando o "Hello, World!"

Antes de entendermos a din√¢mica dos testes, precisamos entender o efeito que eles t√™m no nosso c√≥digo. Um bom lugar para come√ßar isso √© analisando a cobertura. Vamos executar os testes.

```shell title="$ Execu√ß√£o no terminal!"
task test
```

Teremos uma resposta como essa:

```shell title="$ Execu√ß√£o no terminal!"
All done! ‚ú® üç∞ ‚ú®
3 files would be left unchanged.
=========================== test session starts ===========================
platform linux -- Python 3.11.3, pytest-7.4.0, pluggy-1.2.
cachedir: .pytest_cache
rootdir: /home/dunossauro/git/fast_zero
configfile: pyproject.toml
plugins: cov-4.1.0, anyio-3.7.1
collected 0 items

/<path>/site-packages/coverage/control.py:860:
  CoverageWarning: No data was collected. (no-data-collected)
    self._warn("No data was collected.", slug="no-data-collected")

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      5     0%
-------------------------------------------
TOTAL                       5      5     0%
```

As primeiras duas linhas s√£o referentes ao comando do `taskipy` `pre_test` que executa o `blue` e o `ruff` antes de cada teste. As linhas seguintes s√£o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.

A parte importante dessa Mensagem est√° na tabela gerada pelo `coverage`. Que diz que temos 5 linhas de c√≥digo (Stmts) no arquivo `fast_zero/app.py` e nenhuma delas est√° coberta pelos nossos testes. Como podemos ver na coluna `Miss`.

Por n√£o ter encontrado nenhum teste, o pytest retornou um "erro". Isso significa que nossa tarefa `post_test` n√£o foi executada. Podemos execut√°-la manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

Isso gera um relat√≥rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c√≥digo n√£o est√£o sendo testadas.

![navegador](/assets/02_navegador_com_pagina_inicial_do_coverage.png){: .center .shadow }

Se clicarmos no arquivo `fast_zero/app.py` podemos ver em vermelho as linhas que n√£o est√£o sendo testadas

![navegador](assets/02_navegador_com_pagina_de_cobertura_sem_testes.png){: .center .shadow }

Isto significa que precisamos testar todo esse arquivo.

### Escrevendo o teste

Agora, vamos escrever nosso primeiro teste com Pytest.

Para testar o fastAPI, precisamos de um cliente de teste. Isso pode ser obtido no m√≥dulo `fastapi.testclient` com o objeto `TestClient`, que precisa receber nosso app como par√¢metro:

```python title="tests/test_app.py" linenums="1"
from fastapi.testclient import TestClient
from fast_zero.app import app

client = TestClient(app)
```

S√≥ o fato de termos definido um cliente, j√° nos mostra uma cobertura bastante diferente:

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 9"
task test
# parte da mensagem foi omitida
collected 0 items

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      1    80%
-------------------------------------------
TOTAL                       5      1    80%
```


Devido ao fato de n√£o ter coletado nenhum teste, o pytest ainda retornou um "erro". Para ver a cobertura, precisaremos executar novamente o `post_test` manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

No navegador, podemos ver que a √∫nica linha n√£o "testada" √© aquela onde temos a l√≥gica do endpoint:

![browser](assets/02_navegador_com_pagina_de_cobertura_com_estrutuda_de_testes.png){: .center .shadow }

No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n√£o foi.

Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:

```python title="tests/test_app.py" linenums="1" hl_lines="8-10"
from fastapi.testclient import TestClient
from fast_zero.app import app

client = TestClient(app)


def test_root_deve_retornar_200_e_ola_mundo():
    response = client.get('/')
    assert response.status_code == 200
    assert response.json() == {'message': 'Ol√° Mundo!'}
```

Esse teste faz uma requisi√ß√£o GET no endpoint `/` e verifica se o c√≥digo de status da resposta √© 200 e se o conte√∫do da resposta √© `{'message': 'Ol√° Mundo!'}`.

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 5 11 16"
task test
# parte da mensagem foi omitida
collected 1 item

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      0   100%
-------------------------------------------
TOTAL                       5      0   100%

================ 1 passed in 1.39s ================
Wrote HTML report to htmlcov/index.html
```

Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n√£o deixou de abranger nenhuma linha de c√≥digo.

Como conseguimos coletar um item, o `post_test` foi executado e tamb√©m gerou um HTML com a cobertura atualizada.

![descri√ß√£o](assets/02_navegador_com_pagina_de_cobertura_com_teste.png){: .center .shadow }


## Criando nosso reposit√≥rio no git

Antes de concluirmos a aula, precisamos criar nosso reposit√≥rio no git e criar nosso arquivo `.gitignore`:

```shell title="$ Execu√ß√£o no terminal!"
ignr -p python > .gitignore
git init .
gh repo create
```


## Conclus√£o

Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come√ßar a trabalhar com FastAPI e j√° fizemos nossa primeira imers√£o no Desenvolvimento Orientado por Testes. Na pr√≥xima aula, vamos aprofundar na estrutura√ß√£o da nossa aplica√ß√£o FastAPI. At√© l√°!
