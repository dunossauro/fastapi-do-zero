---
title: Configurando o ambiente de desenvolvimento
description: Como instalar as depend√™ncia e ajustar nosso pyproject.toml
---

# Configurando o Ambiente de Desenvolvimento

---

Objetivos dessa aula:

- Introdu√ß√£o ao ambiente de desenvolvimento (terminal, ferramentas, etc.)
- Instala√ß√£o do FastAPI e suas depend√™ncias
- Configura√ß√£o das ferramentas de desenvolvimento
- Execu√ß√£o do primeiro "Hello, World!" com FastAPI com testes!

??? tip "Caso prefira ver a aula em v√≠deo"
	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](https://github.com/dunossauro/fastapi-do-zero/blob/main/slides/pdf/aula_01.pdf){ .md-button }
[C√≥digo :fontawesome-solid-code:](https://github.com/dunossauro/fast_zero/tree/01){ .md-button }

---

Nesta aula pr√°tica, vamos come√ßar nossa jornada na constru√ß√£o de uma API com FastAPI. Esse √© um moderno e r√°pido (altamente perform√°tico) framework web para constru√ß√£o de APIs com Python 3.7+ baseado em Python type hints.

Partiremos do b√°sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala√ß√£o da vers√£o correta do Python at√© a instala√ß√£o e configura√ß√£o do Poetry, um gerenciador de pacotes e depend√™ncias para Python. Al√©m disso, instalaremos e configuraremos uma s√©rie de ferramentas de desenvolvimento √∫teis, como Ruff, Blue, Isort, pytest e Taskipy.

Depois de configurado o nosso ambiente, criaremos nosso primeiro programa "Hello, World!" com FastAPI. Isso nos permitir√° confirmar que tudo est√° funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.


## Ambiente de Desenvolvimento

Para iniciar essa aula voc√™ vai precisar de algumas ferramentas.

1. Um editor de texto a sua escolha (Eu vou usar o [GNU/Emacs](https://www.gnu.org/software/emacs/){:target="_blank"})
2. Um terminal a sua escolha (Usarei o [Terminator](https://gnome-terminator.org/){:target="_blank"})
3. A vers√£o 3.11 do Python instalada.
	- Caso n√£o tenha essa vers√£o voc√™ pode baixar do [site oficial](https://www.python.org/downloads/){:target="_blank"}
	- Ou instalar via [pyenv](https://github.com/pyenv/pyenv){:target="_blank"}
	- Embora a vers√£o 3.7 seja suficiente para executar o FastAPI em si, neste curso usaremos recursos de Python que est√£o presentes apenas a partir da vers√£o 3.11. Portanto, essa √© a vers√£o m√≠nima obrigat√≥ria para o curso.
4. O [Poetry](https://python-poetry.org/){:target="_blank"} para gerenciar os pacotes e seu ambiente virtual (caso n√£o conhe√ßa o poetry temos uma [live de python sobre ele](https://youtu.be/ZOSWdktsKf0){:target="_blank"})
5. [Git](https://git-scm.com/){:target="_blank"}: Para gerenciar vers√µes
6. [Docker](https://www.docker.com/){:target="_blank"}: Para criar um container da nossa aplica√ß√£o (caso n√£o tenha nenhum experi√™ncia com docker a [Linuxtips](https://www.youtube.com/playlist?list=PLf-O3X2-mxDn1VpyU2q3fuI6YYeIWp5rR){:target="_blank"} tem uma playlist completa e gr√°tis sobre docker no canal deles no Youtube)
7. **OPCIONAL**: O [pipx](https://github.com/pypa/pipx){:target="_blank"} pode te
 ajudar bastante nesses momentos de instala√ß√µes
 8. **OPCIONAL**: O [ignr](https://github.com/Antrikshy/ignr.py){:target="_blank"} para criar nosso gitignore
 7. **OPCIONAL**: O [gh](https://cli.github.com/){:target="_blank"} para criar o reposit√≥rio e fazer altera√ß√µes sem precisar acessar a p√°gina do Github

## Instala√ß√£o do Python 3.11

Se voc√™ precisar reconstruir o ambiente usado nesse curso, √© recomendado que voc√™ use o [pyenv](https://github.com/pyenv/pyenv){:target="_blank"}.

Caso tenha problemas durante a instala√ß√£o. O pyenv conta com dois assistentes simplificados para sua configura√ß√£o. Para windows, use o [pyenv-windows](https://pyenv-win.github.io/pyenv-win/){:target="_blank"}. Para GNU/Linux e MacOS, use o [pyenv-installer](https://github.com/pyenv/pyenv-installer){:target="_blank"}.

Navegue at√© o diret√≥rio onde far√° os exerc√≠cios e executar√° os c√≥digos de exemplo no seu terminal e digite os seguintes comandos:

```shell title="$ Execu√ß√£o no terminal!"
pyenv update
pyenv install 3.11:latest
```

Certifique que a vers√£o do python 3.11 esteja instalada:


```shell title="$ Execu√ß√£o no terminal!" hl_lines="4"
pyenv versions
* system (set by /home/dunossauro/.pyenv/version)
  3.10.12
  3.11.4
  3.12.0b1
```

A resposta esperada √© que o `Python 3.11.4` (a maior vers√£o do python 3.11 enquanto escrevia esse material) esteja nessa lista.

## Gerenciamento de Depend√™ncias com Poetry

Ap√≥s instalar o Python, o pr√≥ximo passo √© instalar o Poetry, um gerenciador de pacotes e depend√™ncias para Python. O Poetry facilita a cria√ß√£o, o gerenciamento e a distribui√ß√£o de pacotes Python.

??? info "Caso esse seja seu primeiro contato com o Poetry"
	Temos uma live de python explicando somente ele

	![type:video](https://www.youtube.com/embed/ZOSWdktsKf0)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/ZOSWdktsKf0){ .md-button }


Para instalar o Poetry, voc√™ pode seguir as instru√ß√µes presentes na [documenta√ß√£o oficial](https://python-poetry.org/docs/#installation){:target="_blank"} do Poetry para o seu sistema operacional. Alternativamente, se voc√™ optou por usar o pipx, pode instalar o Poetry com o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
pipx install poetry
```

## Cria√ß√£o do Projeto FastAPI e Instala√ß√£o das Depend√™ncias

Agora que temos o Python e o Poetry prontos, podemos come√ßar a criar nosso projeto FastAPI.

Vamos inicialmente criar um novo diret√≥rio para nosso projeto e navegar para ele:

```shell title="$ Execu√ß√£o no terminal!"
poetry new fast_zero
cd fast_zero
```

Ele criar√° uma estrutura como essa:

```
.
‚îú‚îÄ‚îÄ fast_zero
‚îÇ  ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tests
   ‚îî‚îÄ‚îÄ __init__.py
```

Para que a vers√£o que instalamos com pyenv seja usada em nosso projeto criado com poetry, devemos dizer ao pyenv qual vers√£o do python ser√° usada nesse diret√≥rio:

```shell title="$ Execu√ß√£o no terminal!"
pyenv local 3.11.4  # Essa era a maior vers√£o do 3.11 quando escrevi
```

Em conjunto com essa instru√ß√£o, devemos dizer ao poetry que usaremos essa vers√£o em nosso projeto. Para isso vamos alterar o arquivo de configura√ß√£o do projeto o `pyproject.toml` na raiz do projeto:

```toml title="pyproject.toml" linenums="9"
[tool.poetry.dependencies]
python = "3.11.*"  # .* quer dizer qualquer vers√£o da 3.11
```

Desta forma, temos uma vers√£o do python selecionada para esse projeto e uma garantia que o poetry usar√° essa vers√£o para a cria√ß√£o do nosso ambiente virtual.


Em seguida, inicializaremos um novo projeto Python com Poetry e instalaremos as depend√™ncias necess√°rias - FastAPI e Uvicorn:

```shell title="$ Execu√ß√£o no terminal!"
poetry install
poetry add fastapi uvicorn
```

## Primeira Execu√ß√£o de um "Hello, World!"

Para garantir que tudo est√° configurado corretamente, vamos criar um pequeno programa "Hello, World!" com FastAPI. Em um novo arquivo chamado `app.py` no diret√≥rio `fast_zero` adicione o seguinte c√≥digo:


```python title="fast_zero/app.py" linenums="1"
from fastapi import FastAPI

app = FastAPI()

@app.get('/')
def read_root():
    return {'message': 'Ol√° Mundo!'}
```

Agora, podemos ativar o ambiente virtual e iniciar nosso servidor FastAPI com os seguintes comandos:

```shell title="$ Execu√ß√£o no terminal!"
poetry shell
uvicorn fast_zero.app:app --reload
```

Acesse http://localhost:8000 no seu navegador, e voc√™ deve ver a mensagem "Hello, World!" em formato JSON.

![descri√ß√£o](assets/02_nagevador_com_localhost.png){: .center .shadow }

## Instalando as ferramentas de desenvolvimento

As ferramentas de desenvolvimento escolhidas podem variar de acordo com a prefer√™ncia pessoal. Nesta aula, utilizaremos algumas que s√£o particularmente √∫teis para demonstrar certos conceitos:

- [taskipy](https://github.com/taskipy/taskipy){:target="_blank"}: Ferramenta para automatizar alguns comandos e simplificar o fluxo
- [ruff](https://beta.ruff.rs/docs/){:target="_blank"}: Um linter, para dizer se n√£o estamos fazendo nada esquisito no c√≥digo
- [blue](https://blue.readthedocs.io/en/latest/index.html){:target="_blank"}: Um formatador de c√≥digo bastante amig√°vel
- [isort](https://pycqa.github.io/isort/){:target="_blank"}: Uma ferramenta para ordenar os imports em ordem alfab√©tica
- [pytest](https://docs.pytest.org/en/7.4.x/){:target="_blank"}: Ferramenta para executar testes

Para instalar as depend√™ncias, podemos usar um grupo do poetry focado nelas, para n√£o serem usadas em produ√ß√£o:

```shell title="$ Execu√ß√£o no terminal!"
poetry add --group dev pytest pytest-cov taskipy blue ruff httpx isort
```

> O [HTTPX](https://www.python-httpx.org/){:target="_blank"} foi inclu√≠do, pois ele √© uma depend√™ncia do cliente de testes do FastAPI.

## Configurando as ferramentas de desenvolvimento

Ap√≥s a instala√ß√£o das depend√™ncias, vamos precisar configurar todas as ferramentas de desenvolvimento no arquivo `pyproject.toml`.

### Ruff

Come√ßando pelo ruff, vamos definir o comprimento de linha para 79 caracteres (conforme sugerido na PEP 8) e em seguida, informaremos que o diret√≥rio de ambiente virtual e o de migra√ß√µes de banco de dados dever√£o ser ignorados:

```toml title="pyproject.toml" linenums="23"
[tool.ruff]
line-length = 79
exclude = ['.venv', 'migrations']
```

### isort

Para evitar conflitos de formata√ß√£o entre o isort e o blue, definiremos o black como perfil de formata√ß√£o a ser seguido, j√° que o blue √© um fork dele.
Como o black utiliza 88 caracteres por linha, vamos alterar para 79 que √© o padr√£o que o blue segue e que tamb√©m estamos seguindo:

```toml title="pyproject.toml" linenums="27"
[tool.isort]
profile = "black"
line_length = 79
extend_skip = ['migrations']
```

### pytest

Configuraremos o pytest para reconhecer o caminho base para execu√ß√£o dos testes na raiz do projeto `.`:

```toml title="pyproject.toml" linenums="31"
[tool.pytest.ini_options]
pythonpath = "."
```

### blue

Configuraremos o blue para excluir o caminho das migra√ß√µes quando essas forem utilizadas:

```toml title="pyproject.toml" linenums="34"
[tool.blue]
extend-exclude = '(migrations/)'
```

### Taskipy

Para simplificar a execu√ß√£o de certos comandos, vamos criar algumas tarefas com o Taskipy.

```toml title="pyproject.toml" linenums="37"
[tool.taskipy.tasks]
lint = 'ruff . && blue --check . --diff'
format = 'blue .  && isort .'
run = 'uvicorn fast_zero.app:app --reload'
pre_test = 'task lint'
test = 'pytest -s -x --cov=fast_zero -vv'
post_test = 'coverage html'
```

Os comandos definidos fazem o seguinte:

- lint: executa o ruff para ver se n√£o temos nenhum problema com o c√≥digo e checa se estamos de acordo com a PEP-8
- format: formata o c√≥digo usando blue e isort
- run: executa o servidor de desenvolvimento do FastAPI
- pre_test: executa a camada de lint antes de executar os teste
- test: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c√≥digo como base de cobertura
- post_test: gera um report de cobertura ap√≥s os testes


Para executar um comando, √© bem mais simples, precisando somente passar a palavra `task <comando>`.

??? warning "Caso precise ver o arquivo todo"

	O meu est√° exatamente assim:

	```toml title="pyproject.toml" linenums="1"
	[tool.poetry]
	name = "fast-zero"
	version = "0.1.0"
	description = ""
	authors = ["dunossauro <mendesxeduardo@gmail.com>"]
	readme = "README.md"
	packages = [{include = "fast_zero"}]

	[tool.poetry.dependencies]
	python = "3.11.*"
	fastapi = "^0.100.0"
	uvicorn = "^0.22.0"

	[tool.poetry.group.dev.dependencies]
	pytest = "^7.4.0"
	pytest-cov = "^4.1.0"
	taskipy = "^1.11.0"
	blue = "^0.9.1"
	ruff = "^0.0.278"
	httpx = "^0.24.1"
	isort = "^5.12.0"

	[tool.ruff]
	line-length = 79
	exclude = ['.venv', 'migrations']

	[tool.isort]
	profile = "black"
	line_length = 79
	extend_skip = ['migrations']

	[tool.pytest.ini_options]
	pythonpath = "."

	[tool.blue]
	extend-exclude = '(migrations/)'

	[tool.taskipy.tasks]
	lint = 'ruff . && blue --check . --diff'
	format = 'blue .  && isort .'
	run = 'uvicorn fast_zero.app:app --reload'
	pre_test = 'task lint'
	test = 'pytest -s -x --cov=fast_zero -vv'
	post_test = 'coverage html'

	[build-system]
	requires = ["poetry-core"]
	build-backend = "poetry.core.masonry.api"
	```


## Os efeitos dessas configura√ß√µes de desenvolvimento

Caso voc√™ tenha copiado o c√≥digo que usamos para definir `fast_zero/app.py`, pode testar os comandos que criamos para o `taskipy`:

```shell title="$ Execu√ß√£o no terminal!"
task lint
```

Dessa forma, veremos que cometemos algumas infra√ß√µes na formata√ß√£o da PEP-8. O blue nos informar√° que dever√≠amos ter adicionado duas linhas antes de uma defini√ß√£o de fun√ß√£o:


```diff
--- fast_zero/app.py    2023-07-12 21:40:14.590616 +0000
+++ fast_zero/app.py    2023-07-12 21:48:17.017190 +0000
@@ -1,7 +1,8 @@
 from fastapi import FastAPI

 app = FastAPI()

+
 @app.get('/')
 def read_root():
     return {'message': 'Ol√° Mundo!'}
would reformat fast_zero/app.py

Oh no! üí• üíî üí•
1 file would be reformatted, 2 files would be left unchanged.
```

Para corrigir isso, podemos usar o nosso comando de formata√ß√£o de c√≥digo:

=== "Comando"

	```shell title="$ Execu√ß√£o no terminal!"
	task format
	reformatted fast_zero/app.py

	All done! ‚ú® üç∞ ‚ú®
	1 file reformatted, 2 files left unchanged.
	Skipped 2 files
	```

=== "Resultado"
	```py title="fast_zero/app.py" linenums="1" hl_lines="5"
	from fastapi import FastAPI

	app = FastAPI()


	@app.get('/')
	def read_root():
		return {'message': 'Ol√° Mundo!'}
	```

## Introdu√ß√£o ao Pytest: Testando o "Hello, World!"

Antes de entendermos a din√¢mica dos testes, precisamos entender o efeito que eles t√™m no nosso c√≥digo. Um bom lugar para come√ßar isso √© analisando a cobertura. Vamos executar os testes.

```shell title="$ Execu√ß√£o no terminal!"
task test
```

Teremos uma resposta como essa:

```shell title="$ Execu√ß√£o no terminal!"
All done! ‚ú® üç∞ ‚ú®
3 files would be left unchanged.
=========================== test session starts ===========================
platform linux -- Python 3.11.3, pytest-7.4.0, pluggy-1.2.
cachedir: .pytest_cache
rootdir: /home/dunossauro/git/fast_zero
configfile: pyproject.toml
plugins: cov-4.1.0, anyio-3.7.1
collected 0 items

/<path>/site-packages/coverage/control.py:860:
  CoverageWarning: No data was collected. (no-data-collected)
    self._warn("No data was collected.", slug="no-data-collected")

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      5     0%
-------------------------------------------
TOTAL                       5      5     0%
```

As primeiras duas linhas s√£o referentes ao comando do `taskipy` `pre_test` que executa o `blue` e o `ruff` antes de cada teste. As linhas seguintes s√£o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.

??? info "Caso n√£o tenha muita experi√™ncia com Pytest"
	Temos uma live de Python explicando os conceitos b√°sicos da biblioteca
	![type:video](https://www.youtube.com/embed/MjQCvJmc31A)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/MjQCvJmc31A){ .md-button }


A parte importante dessa Mensagem est√° na tabela gerada pelo `coverage`. Que diz que temos 5 linhas de c√≥digo (Stmts) no arquivo `fast_zero/app.py` e nenhuma delas est√° coberta pelos nossos testes. Como podemos ver na coluna `Miss`.

Por n√£o ter encontrado nenhum teste, o pytest retornou um "erro". Isso significa que nossa tarefa `post_test` n√£o foi executada. Podemos execut√°-la manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

Isso gera um relat√≥rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c√≥digo n√£o est√£o sendo testadas.

![navegador](/assets/02_navegador_com_pagina_inicial_do_coverage.png){: .center .shadow }

Se clicarmos no arquivo `fast_zero/app.py` podemos ver em vermelho as linhas que n√£o est√£o sendo testadas

![navegador](assets/02_navegador_com_pagina_de_cobertura_sem_testes.png){: .center .shadow }

Isto significa que precisamos testar todo esse arquivo.

### Escrevendo o teste

Agora, vamos escrever nosso primeiro teste com Pytest.

Para testar o FastAPI, precisamos de um cliente de teste. Isso pode ser obtido no m√≥dulo `fastapi.testclient` com o objeto `TestClient`, que precisa receber nosso app como par√¢metro:

```python title="tests/test_app.py" linenums="1"
from fastapi.testclient import TestClient
from fast_zero.app import app

client = TestClient(app)
```

S√≥ o fato de termos definido um cliente, j√° nos mostra uma cobertura bastante diferente:

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 9"
task test
# parte da mensagem foi omitida
collected 0 items

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      1    80%
-------------------------------------------
TOTAL                       5      1    80%
```


Devido ao fato de n√£o ter coletado nenhum teste, o pytest ainda retornou um "erro". Para ver a cobertura, precisaremos executar novamente o `post_test` manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

No navegador, podemos ver que a √∫nica linha n√£o "testada" √© aquela onde temos a l√≥gica do endpoint:

![browser](assets/02_navegador_com_pagina_de_cobertura_com_estrutuda_de_testes.png){: .center .shadow }

No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n√£o foi.

Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:

```python title="tests/test_app.py" linenums="1"
from fastapi.testclient import TestClient
from fast_zero.app import app

def test_root_deve_retornar_200_e_ola_mundo():
    client = TestClient(app)

    response = client.get('/')

    assert response.status_code == 200
    assert response.json() == {'message': 'Ol√° Mundo!'}
```

Esse teste faz uma requisi√ß√£o GET no endpoint `/` e verifica se o c√≥digo de status da resposta √© 200 e se o conte√∫do da resposta √© `{'message': 'Ol√° Mundo!'}`.

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 5 11 16"
task test
# parte da mensagem foi omitida
collected 1 item

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      0   100%
-------------------------------------------
TOTAL                       5      0   100%

================ 1 passed in 1.39s ================
Wrote HTML report to htmlcov/index.html
```

Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n√£o deixou de abranger nenhuma linha de c√≥digo.

Como conseguimos coletar um item, o `post_test` foi executado e tamb√©m gerou um HTML com a cobertura atualizada.

![descri√ß√£o](assets/02_navegador_com_pagina_de_cobertura_com_teste.png){: .center .shadow }


## Estrutura de um teste

Agora que escrevemos nosso teste de forma intuitiva, podemos entender o que cada passo do teste faz. Essa compreens√£o √© vital, pois pode nos ajudar a escrever testes no futuro com mais confian√ßa e efic√°cia. Para desvendar o m√©todo por tr√°s da nossa abordagem, vamos explorar a estrat√©gia conhecida como [AAA](https://xp123.com/articles/3a-arrange-act-assert/){:target="_blank"}, que divide o teste em tr√™s fases distintas: Arrange, Act, Assert.

??? info "Caso fazer testes ainda seja complicado para voc√™"
	Temos uma live de python focada em ensinar os primeiros passos no mundo dos testes.
	![type:video](https://www.youtube.com/embed/-8H2Pyxnoek)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/-8H2Pyxnoek){ .md-button }

Vamos pegar esse teste que fizemos e entender os passos que fizemos para conseguir testar esse endpoint:

```python title="tests/test_app.py" linenums="1"
from fastapi.testclient import TestClient
from fast_zero.app import app

def test_root_deve_retornar_200_e_ola_mundo():
    client = TestClient(app)  # Arrange

    response = client.get('/')  # Act

    assert response.status_code == 200  # Assert
    assert response.json() == {'message': 'Ol√° Mundo!'}  # Assert
```

Com base nesse c√≥digo, podemos observar as tr√™s fases:

### Fase 1 - Organizar (Arrange)

Nesta primeira etapa, estamos preparando o ambiente para o teste. No exemplo, a linha com o coment√°rio `Arrange` n√£o √© o teste em si, ela monta o ambiente para que o teste possa ser executado. Estamos configurando um `client` de testes para fazer a requisi√ß√£o ao `app`.

### Fase 2 - Agir (Act)

Aqui √© a etapa onde acontece a a√ß√£o principal do teste, que consiste em chamar o Sistema Sob Teste ([SUT](http://xunitpatterns.com/SUT.html){:target="_blank"}). No nosso caso, o SUT √© a rota `/`, e a a√ß√£o √© representada pela linha `response = client.get('/')`. Estamos exercitando a rota e armazenando sua resposta na vari√°vel `response`. √â a fase em que o c√≥digo de testes executa o c√≥digo de produ√ß√£o que est√° sendo testado. Agir aqui significa interagir diretamente com a parte do sistema que queremos avaliar, para ver como ela se comporta.

### Fase 3 - *Afirmar* (Assert)

Esta √© a etapa de verificar se tudo correu como esperado. √â f√°cil notar onde estamos fazendo a verifica√ß√£o, pois essa linha sempre tem a palavra reservada `assert`. A verifica√ß√£o √© booleana, ou est√° correta ou n√£o est√°. Por isso, um teste deve sempre incluir um `assert` para verificar se o comportamento esperado est√° correto.

---

Agora que compreendemos o que cada linha de teste faz em espec√≠fico, podemos nos orientar de forma clara nos testes que escreveremos no futuro. Cada uma das linhas usadas tem uma raz√£o de estar no teste, e conhecer essa estrutura n√£o s√≥ nos d√° uma compreens√£o mais profunda do que estamos fazendo, mas tamb√©m nos d√° confian√ßa para explorar e escrever testes mais complexos.


## Criando nosso reposit√≥rio no git

Antes de concluirmos a aula, precisamos criar nosso reposit√≥rio no git e criar nosso arquivo `.gitignore`:

```shell title="$ Execu√ß√£o no terminal!"
ignr -p python > .gitignore
git init .
gh repo create
git add .
git commit -m "Configura√ß√£o inicial do projeto"
git push
```


## Conclus√£o

Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come√ßar a trabalhar com FastAPI e j√° fizemos nossa primeira imers√£o no Desenvolvimento Orientado por Testes. Na pr√≥xima aula, vamos aprofundar na estrutura√ß√£o da nossa aplica√ß√£o FastAPI. At√© l√°!
