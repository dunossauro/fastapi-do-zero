---
title: Configurando o ambiente de desenvolvimento
description: Como instalar as depend√™ncia e ajustar nosso pyproject.toml
---

# Configurando o Ambiente de Desenvolvimento


---
Objetivos dessa aula:

- Introdu√ß√£o ao ambiente de desenvolvimento (terminal, ferramentas, etc.)
- Instala√ß√£o do FastAPI e suas depend√™ncias
- Configura√ß√£o das ferramentas de desenvolvimento
- Execu√ß√£o do primeiro "Hello, World!" com FastAPI com testes!

{%set aula = "01" %}
{%set link = "-Pi5AmOfL2s" %}
{% include "templates/cabecalho.md" %}

---

Nesta aula, iniciaremos nossa jornada na constru√ß√£o de uma API com FastAPI. Partiremos do b√°sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala√ß√£o da vers√£o correta do Python at√© a instala√ß√£o e configura√ß√£o do Poetry, um gerenciador de pacotes e depend√™ncias para Python. Al√©m disso, instalaremos e configuraremos uma s√©rie de ferramentas de desenvolvimento √∫teis, como Ruff, pytest e Taskipy.

Ap√≥s configurado o nosso ambiente, criaremos nosso primeiro programa "Hello, World!" com FastAPI. Isso nos permitir√° confirmar que tudo est√° funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.

## Ambiente de Desenvolvimento

Para iniciar esse curso voc√™ precisa de algumas ferramentas instaladas:

1. Um editor de texto a sua escolha (Usarei o [GNU/Emacs](https://www.gnu.org/software/emacs/){:target="_blank"})
2. Um terminal a sua escolha (Usarei o [Terminator](https://gnome-terminator.org/){:target="_blank"})
3. Python, em uma vers√£o [oficialmente suportada](https://devguide.python.org/versions/){:target="_blank"}, atualmente 3.9+
4. [Pipx](https://github.com/pypa/pipx){:target="_blank"}: Instalador de ferramentas python que n√£o fazem parte do projeto.
5. O [Poetry](https://python-poetry.org/){:target="_blank"} para gerenciar o projeto (pacotes e seu ambiente virtual) [caso n√£o conhe√ßa o poetry temos uma [live de python sobre ele](https://youtu.be/ZOSWdktsKf0){:target="_blank"}]
6. [Git](https://git-scm.com/){:target="_blank"}: Para gerenciar vers√µes do nosso projeto. (Caso precise de um tutorial legal sobre git, o [TeoMeWhy](https://www.youtube.com/playlist?list=PLvlkVRRKOYFQ3cfYPjLeQ0KvrQ8bG5H11){:target="_blank"} fez uma playlist muito legal, totalmente de gra√ßa)
7. [Docker](https://www.docker.com/){:target="_blank"}: Para criar um container da nossa aplica√ß√£o (caso n√£o tenha nenhuma experi√™ncia com docker a [Linuxtips](https://www.youtube.com/playlist?list=PLf-O3X2-mxDn1VpyU2q3fuI6YYeIWp5rR){:target="_blank"} tem uma playlist completa e gr√°tis sobre docker no canal deles no YouTube)[^1]
8. **OPCIONAL (extremamente recomendado)**: O [gh](https://cli.github.com/){:target="_blank"} para criar o reposit√≥rio e fazer altera√ß√µes sem precisar acessar a p√°gina do Github

[^1]: Voc√™ n√£o precisa se preocupar com o docker inicialmente, ele ser√° usado da aula 10 em diante.

> üö®üö® Caso voc√™ precise de ajuda com a instala√ß√£o dessas ferramentas, temos [um ap√™ndice especial para te ajudar com isso!](apendices/a_instalacoes.md){:target="_blank"}. Basta clicar em achar a ferramenta que deseja instalar! üö®üö®

{% include "templates/versoes.md" %}

> TODO: Introdu√ß√£o do poetry como uma ferramenta mais central!


> TODO: O pipx vai se fazer estritamente necess√°rio agora!

## Gerenciamento de Depend√™ncias com Poetry

Ap√≥s instalar o Python, o pr√≥ximo passo √© instalar o [Poetry](https://python-poetry.org/){:target="_blank"}, um gerenciador de pacotes e depend√™ncias para Python. O Poetry facilita a cria√ß√£o, o gerenciamento e a distribui√ß√£o de pacotes Python.

??? info "Caso esse seja seu primeiro contato com o Poetry"
	Temos uma live de python explicando somente ele:

	![type:video](https://www.youtube.com/embed/ZOSWdktsKf0)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/ZOSWdktsKf0){ .md-button }


Para fazer a instala√ß√£o do Poetry de forma global, mas isolada em um ambiente virtual, em sistema, vamos usar o `pipx`:

```shell title="$ Execu√ß√£o no terminal!"
pipx install poetry #(1)!
```

1. Cria um ambiente virtual isolado para poetry e o deixa dispon√≠vel no sistema.

???+ danger "Coment√°rios em blocos"
	Blocos de c√≥digo costumam ter coment√°rios com informa√ß√µes adicionais, como esse:
	![](/assets/01/blocos_de_explicacao.png){: .center .shadow }

    ---

	Ao clicar em :material-plus-circle: um bloco de coment√°rio se abrir√°, exibindo mais informa√ß√µes:

	![](/assets/01/tips_blocos_de_codigo.png){: .center .shadow }

E para facilitar nosso fluxo de trabalho com ambientes virtuais, vamos instalar uma extens√£o do poetry para habilitar o shell:

```shell title="$ Execu√ß√£o no terminal!"
poetry self add poetry-plugin-shell #(1)!
```

1. A fun√ß√£o `self add` do poetry instala extens√µes para podermos executar novos comandos com o poetry, nesse caso `poetry shell` para entrarmos nos ambientes virtuais.

Essa extens√£o instala um comando adicional ao poetry, o `poetry shell`, que habilita o ambiente virtual no terminal.


## Cria√ß√£o do Projeto FastAPI e Instala√ß√£o das Depend√™ncias

Agora que temos o Python e o Poetry prontos, podemos come√ßar a criar nosso projeto FastAPI.

Inicialmente criaremos um novo projeto python usando o Poetry, com o comando `poetry new` e em seguida navegaremos at√© o diret√≥rio criado:

```shell title="$ Execu√ß√£o no terminal!"
poetry new --flat fast_zero #(1)!
cd fast_zero
```

1. Cria um pacote python chamado `fast_zero` no formato `flat`. Por padr√£o o poetry utiliza o formato `src`. Mais informa√ß√µes sobre isso [aqui](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/){:target="_blank"}

Ele criar√° uma estrutura de arquivos e pastas como essa:

```
.
‚îú‚îÄ‚îÄ fast_zero
‚îÇ  ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tests
   ‚îî‚îÄ‚îÄ __init__.py
```

=== "Vers√£o 3.11"
{%set full_version = "3.11.9" %}
{%set short_version = 3.11 %}
{% include "templates/poetry.md" %}
=== "Vers√£o 3.12"
{%set full_version = "3.12.3" %}
{%set short_version = 3.12 %}
{% include "templates/poetry.md" %}
=== "Vers√£o 3.13"
{%set full_version = "3.13.0" %}
{%set short_version = 3.13 %}
{% include "templates/poetry.md" %}

Desta forma, temos uma vers√£o do python selecionada para esse projeto e uma garantia que o poetry usar√° essa vers√£o para a cria√ß√£o do nosso ambiente virtual.

Em seguida, inicializaremos nosso ambiente virtual com Poetry e instalaremos o FastAPI:

```shell title="$ Execu√ß√£o no terminal!"
poetry install # (1)!
poetry add 'fastapi[standard]' # (2)!
```

1. Cria o ambiente virtual (venv)
2. Adiciona o FastAPI no nosso ambiente virtual

## Primeira Execu√ß√£o de um "Hello, World!"

Uma coisa bastante interessante sobre o FastAPI √© que ele √© um framework web baseado em fun√ß√µes. Da mesma forma em que criamos fun√ß√µes tradicionalmente em python, podemos estender essas fun√ß√µes para que elas sejam servidas pelo servidor. Por exemplo:

```py title="fast_zero/app.py" linenums="1"
def read_root():
    return {'message': 'Ol√° Mundo!'}
```

Essa fun√ß√£o em python basicamente retorna um dicion√°rio com uma chave chamada `#!python 'message'` e uma mensagem `#!python 'Ol√° Mundo!'`. Se adicionarmos essa fun√ß√£o em novo arquivo chamado `app.py` no diret√≥rio `fast_zero`. Podemos fazer a chamada dela pelo terminal interativo (**REPL**):

```py title=">>> Terminal interativo!"
>>> read_root()
{'message': 'Ol√° Mundo!'}
```

De forma tradicional, como todas as fun√ß√µes em python.

??? tip "Dica: Como abrir o terminal interativo (REPL)"
	Para abrir o terminal interativo com o seu c√≥digo carregado, voc√™ deve chamar o Python no terminal usando -i:

	```shell title="$ Execu√ß√£o no terminal!"
	python -i <seu_arquivo.py>
	```

	O interpretador do Python executa o c√≥digo do arquivo e retorna o shell ap√≥s executar tudo que est√° escrito no arquivo.

	Para o nosso caso espec√≠fico, como o nome do arquivo √© `fast_zero/app.py`, devemos executar esse comando no terminal:

	```shell title="$ Execu√ß√£o no terminal!"
	python -i fast_zero/app.py
	```

Desta forma, usando somente um decorador do FastAPI, podemos fazer com que uma determinada fun√ß√£o seja acess√≠vel pela rede:

```python title="fast_zero/app.py" linenums="1" hl_lines="5"
from fastapi import FastAPI # (1)!

app = FastAPI()  # (2)!

@app.get('/')  # (3)!
def read_root():  # (4)!
	return {'message': 'Ol√° Mundo!'} # (5)!
```

1. Importando da biblioteca fastapi o objeto FastAPI
2. Iniciando uma aplica√ß√£o FastAPI
3. Definindo um endpoint com o endere√ßo `/` acess√≠vel pelo m√©todo HTTP `GET`
4. Fun√ß√£o que ser√° executada quando o endere√ßo `/` for acessado por um cliente
5. Os dados que ser√£o retornados pelo endere√ßo quando for chamado

A linha em destaque `#!python @app.get('/')` exp√µem a nossa fun√ß√£o para ser servida pelo FastAPI. Dizendo que quando um cliente acessar o nosso endere√ßo de rede no caminho `/`, usando o m√©todo HTTP GET[^2], a fun√ß√£o ser√° executada. Desta maneira, temos todo o c√≥digo necess√°rio para criar nossa primeira aplica√ß√£o web com FastAPI.

[^2]: Exploraremos mais a fundo a rela√ß√£o de m√©todos e o protocolo HTTP na pr√≥xima aula.

Antes de iniciarmos nossa aplica√ß√£o, temos que fazer um passo importante, habilitar o ambiente virtual, para que o python consiga enxergar nossas depend√™ncias instaladas. O poetry tem um comando espec√≠fico para isso:

```shell title="$ Execu√ß√£o no terminal!"
poetry shell
```

Agora com o ambiente virtual ativo, podemos iniciar nosso servidor FastAPI para iniciar nossa aplica√ß√£o:

```shell title="$ Execu√ß√£o no terminal!"
fastapi dev fast_zero/app.py
```

Esse comando diz ao FastAPI para iniciar o servidor de desenvolvimento (`dev`) usando o arquivo `fast_zero/app.py`

A resposta do comando no terminal deve ser parecida com essa:

```shell title="Resposta do comando `fastapi dev fast_zero/app.py`" hl_lines="27 38-42"
INFO     Using path fast_zero/app.py
INFO     Resolved absolute path /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01/fast_zero/app.py
INFO     Searching for package file structure from directories with __init__.py files
INFO     Importing from /home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01

 ‚ï≠‚îÄ Python package file structure ‚îÄ‚ïÆ
 ‚îÇ                                 ‚îÇ
 ‚îÇ  üìÅ fast_zero                   ‚îÇ
 ‚îÇ  ‚îú‚îÄ‚îÄ üêç __init__.py             ‚îÇ
 ‚îÇ  ‚îî‚îÄ‚îÄ üêç app.py                  ‚îÇ
 ‚îÇ                                 ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

INFO     Importing module fast_zero.app
INFO     Found importable FastAPI app

 ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ Importable FastAPI app ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
 ‚îÇ                                 ‚îÇ
 ‚îÇ  from fast_zero.app import app  ‚îÇ
 ‚îÇ                                 ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

INFO     Using import string fast_zero.app:app

 ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
 ‚îÇ                                                     ‚îÇ
 ‚îÇ  Serving at: http://127.0.0.1:8000                  ‚îÇ
 ‚îÇ                                                     ‚îÇ
 ‚îÇ  API docs: http://127.0.0.1:8000/docs               ‚îÇ
 ‚îÇ                                                     ‚îÇ
 ‚îÇ  Running in development mode, for production use:   ‚îÇ
 ‚îÇ                                                     ‚îÇ
 ‚îÇ  fastapi run                                        ‚îÇ
 ‚îÇ                                                     ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

INFO:     Will watch for changes in these directories: ['/home/dunossauro/git/fastapi-do-zero/codigo_das_aulas/01']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [893203] using WatchFiles
INFO:     Started server process [893207]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

A mensagem de resposta do CLI: `serving: http://127.0.0.1:8000` tem uma informa√ß√£o bastante importante.

![Figura representando a divis√£o para "protocolo" com "http://" , "endere√ßo" com "127.0.0.1" e "porta" com ":8000"](assets/01/endereco_http_black.png#only-light){: .center }
![Figura representando a divis√£o para "protocolo" com "http://" , "endere√ßo" com "127.0.0.1" e "porta" com ":8000"](assets/01/endereco_http_white.png#only-dark){: .center  }

1. Ela nos diz qual o protocolo que ele est√° servido `HTTP`, o protocolo padr√£o da web;
2. O endere√ßo de rede (IP) no qual ele est√° escutando `127.0.0.1`, endere√ßo especial ([loopback](https://pt.wikipedia.org/wiki/Loopback#Protocolo_de_Interface_de_Rede_Virtual_da_Internet){:target="_blank"}) que aponta para a nossa pr√≥pria m√°quina;
3. A porta `:8000`, a qual √© a porta da nossa m√°quina que est√° reservada para nossa aplica√ß√£o.

Agora, com o servidor inicializado, podemos usar um cliente para acessar o endere√ßo [http://127.0.0.1:8000](http://127.0.0.1:8000){:target="_blank"}.

O cliente mais tradicional da web √© o navegador, podemos digitar o endere√ßo na barra de navega√ß√£o e se tudo ocorreu corretamente, voc√™ deve ver a mensagem "Ol√° Mundo!" em formato JSON.

![Captura de tela do browser acessando "http://127.0.0.1"](assets/01/nagevador_com_localhost.png){: .center .shadow }

> Para parar a execu√ß√£o do fastapi no shell, voc√™ pode digitar ++ctrl+c++ e a mensagem `Shutting down` aparecer√° mostrando que o servidor foi finalizado.

??? example "Diferentes clientes para nossa aplica√ß√£o"
	Caso exista uma curiosidade sobre outros clientes HTTP que n√£o o browser, podemos usar aplica√ß√µes de linha de comando como tradicional [curl](https://curl.se/){:target="_blank"}:

	```shell title="$ Execu√ß√£o no terminal!"
	curl 127.0.0.1:8000
	{"message":"Ol√° Mundo!"}
	```

	Ou o meu cliente HTTP preferido (escrito em python), o [HTTPie](https://httpie.io/){:target="_blank"}:

	```shell title="$ Execu√ß√£o no terminal!"
	http 127.0.0.1:8000
	HTTP/1.1 200 OK
	content-length: 25
	content-type: application/json
	date: Thu, 11 Jan 2024 11:46:32 GMT
	server: uvicorn

	{
		"message": "Ol√° Mundo!"
	}
	```

	Existem at√© mesmo aplica√ß√µes gr√°ficas de c√≥digo aberto pensadas para serem clientes HTTP para APIs. Como o [hoppscotch](https://hoppscotch.io/){:target="_blank"}:

	![Captura de tela do hoppscotch](assets/01/cliente_grafico_para_apis_hoppscotch.png){: .center .shadow }

	Ou como o [Bruno](https://www.usebruno.com/){:target="_blank"}:
	![Captura de tela do bruno](assets/01/cliente_grafico_para_apis_bruno.png){: .center .shadow }


### Uvicorn

O FastAPI √© √≥timo para criar APIs, mas n√£o pode disponibiliz√°-las na rede sozinho. Embora o FastAPI tenha uma aplica√ß√£o de terminal que facilita a execu√ß√£o. Para podermos acessar essas APIs por um navegador ou de outras aplica√ß√µes clientes, √© necess√°rio um servidor. √â a√≠ que o Uvicorn entra em cena. Ele atua como esse servidor, disponibilizando a API do FastAPI em rede. Isso permite que a API seja acessada de outros dispositivos ou programas.

Como notamos na resposta do comando `fastapi dev fast_zero/app.py`:

```bash title="Fim da resposta de `fastapi dev fast_zero/app.py`"
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [893203] using WatchFiles
INFO:     Started server process [893207]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

Sempre que usarmos o fastapi para inicializar a aplica√ß√£o no shell, ele faz uma chamada interna para inicializar o uvicorn. Por esse motivo ele aparece nas respostas HTTP e tamb√©m na execu√ß√£o do comando.

??? tip "Voc√™ poderia chamar a aplica√ß√£o diretamente pelo Uvicorn tamb√©m"
	```shell title="$ Execu√ß√£o no terminal!"
	uvicorn fast_zero.app:app
	```
	Esse comando diz ao uvicorn o seguinte: na pasta fast_zero existe um arquivo chamado app. Dentro desse arquivo, temos uma aplica√ß√£o para ser servida com o nome de app. O comando √© composto por uvicorn pasta.arquivo:vari√°vel.

	A resposta do comando no terminal deve ser parecida com essa:
	
	```shell title="Resultado do comando"
	INFO:     Started server process [127946]
	INFO:     Waiting for application startup.
	INFO:     Application startup complete.
	INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
	```

## Instalando as ferramentas de desenvolvimento

As escolhas de ferramentas de desenvolvimento, de forma geral, s√£o escolhas bem particulares. N√£o costumam ser consensuais nem mesmo em times de desenvolvimento. Dito isso, selecionei algumas ferramentas que gosto de usar e alinhadas com a utilidade que elas apresentam no desenvolvimento do projeto.

As ferramentas escolhidas s√£o:

- [taskipy](https://github.com/taskipy/taskipy){:target="_blank"}: ferramenta usada para cria√ß√£o de comandos. Como executar a aplica√ß√£o, rodar os testes, etc.
- [pytest](https://docs.pytest.org/){:target="_blank"}: ferramenta para escrever e executar testes
- [ruff](https://docs.astral.sh/ruff/){:target="_blank"}: Uma ferramenta que tem duas fun√ß√µes no nosso c√≥digo:
    1. Um analisador est√°tico de c√≥digo (um [linter](https://pt.wikipedia.org/wiki/Linter_(computa%C3%A7%C3%A3o)){:target="_blank"}), para dizer se n√£o estamos infringido alguma [boa pr√°tica de programa√ß√£o](https://docs.astral.sh/ruff/rules/){:target="_blank"};
	2. Um formatador de c√≥digo. Para seguirmos um estilo √∫nico de c√≥digo. Vamos nos basear na [PEP-8](https://peps.python.org/pep-0008/){:target="_blank"}.

Para instalar essas ferramentas que usaremos em desenvolvimento, podemos usar um grupo (`--group dev`) do poetry focado nelas, para n√£o serem instaladas quando nossa aplica√ß√£o estiver em produ√ß√£o:

```shell title="$ Execu√ß√£o no terminal!"
poetry add --group dev pytest pytest-cov taskipy ruff
```

## Configurando as ferramentas de desenvolvimento

Ap√≥s a instala√ß√£o das ferramentas de desenvolvimento, precisamos definir as configura√ß√µes de cada uma individualmente no arquivo `pyproject.toml`.

### Ruff

O [Ruff](https://docs.astral.sh/ruff/){:target="_blank"} √© uma ferramenta moderna em python, escrita em rust, compat√≠vel[^2] com os projetos de an√°lise est√°tica escritos e mantidos originalmente pela comunidade no projeto [PYCQA](https://github.com/PyCQA/){:target="_blank"}[^3] e tem duas fun√ß√µes principais:

[^2]: Em alguns casos existe uma diverg√™ncia de opini√µes em os linter mais tradicionais. Mas, em geral funciona bem.
[^3]: Em vers√µes antigas do texto us√°vamos as ferramentas do PyCQA como o pylint e o isort.

1. Analisar o c√≥digo de forma est√°tica (Linter): Efetuar a verifica√ß√£o se estamos programando de acordo com boas pr√°ticas do python.
2. Formatar o c√≥digo (Formatter): Efetuar a verifica√ß√£o do c√≥digo para padronizar um estilo de c√≥digo pr√©-definido.


Para configurar o ruff montamos a configura√ß√£o em 3 [tabelas](https://toml.io/pt/v1.0.0#tabela){:target="_blank"} distintas no arquivo `pyproject.toml`. Uma para as configura√ß√µes globais, uma para o linter e uma para o formatador.

**Configura√ß√£o global**

Na configura√ß√£o global do Ruff queremos alterar somente duas coisas. O comprimento de linha para 79 caracteres (conforme sugerido na [PEP-8](https://peps.python.org/pep-0008/){:target="_blank"}) e em seguida, informaremos que o diret√≥rio de migra√ß√µes de banco de dados ser√° ignorado na checagem e na formata√ß√£o:

```toml title="pyproject.toml" linenums="21"
--8<-- "aulas/codigos/01/pyproject.toml:21:23"
```

???+ example "Nota sobre "migrations""
	Nessa fase de configura√ß√£o, excluiremos a pasta `migrations`, isso pode n√£o fazer muito sentido nesse momento. Contudo, quando iniciarmos o trabalho com o banco de dados, a ferramenta `Alembic` faz gera√ß√£o de c√≥digo autom√°tico. Por serem c√≥digos gerados automaticamente, n√£o queremos alterar a configura√ß√£o feita por ela.

**Linter**

Durante a an√°lise est√°tica do c√≥digo, queremos buscar por coisas espec√≠ficas. No Ruff, precisamos dizer exatamente o que ele deve analisar. Isso √© feito por c√≥digos. Usaremos estes:

- `I` ([Isort](https://pycqa.github.io/isort/){:target="_blank"}): Checagem de ordena√ß√£o de imports em ordem alfab√©tica
- `F` ([Pyflakes](https://github.com/PyCQA/pyflakes){:target="_blank"}): Procura por alguns erros em rela√ß√£o a boas pr√°ticas de c√≥digo
- `E` (Erros [pycodestyle](https://pycodestyle.pycqa.org/en/latest/){:target="_blank"}): Erros de estilo de c√≥digo
- `W` (Avisos [pycodestyle](https://pycodestyle.pycqa.org/en/latest/){:target="_blank"}): Avisos de coisas n√£o recomendadas no estilo de c√≥digo
- `PL` ([Pylint](https://pylint.pycqa.org/en/latest/index.html){:target="_blank"}): Como o `F`, tamb√©m procura por erros em rela√ß√£o a boas pr√°ticas de c√≥digo
- `PT` ([flake8-pytest](https://pypi.org/project/flake8-pytest-style/){:target="_blank"}): Checagem de boas pr√°ticas do Pytest

```toml title="pyproject.toml" linenums="25"
--8<-- "aulas/codigos/01/pyproject.toml:25:27"
```

> Para mais informa√ß√µes sobre a configura√ß√£o e sobre os c√≥digos do ruff e dos projetos do PyCQA, voc√™ pode checar a [documenta√ß√£o do ruff](https://docs.astral.sh/ruff/rules){:target="_blank"} ou as documenta√ß√µes originais dos projetos [PyQCA](https://github.com/PyCQA){:target="_blank"}.

**Formatter**

A formata√ß√£o do Ruff praticamente n√£o precisa ser alterada. Pois ele vai seguir as boas pr√°ticas e usar a configura√ß√£o global de `79` caracteres por linha. A √∫nica altera√ß√£o que farei √© o uso de aspas simples `'` no lugar de aspas duplas `"`:

```toml title="pyproject.toml" linenums="29"
--8<-- "aulas/codigos/01/pyproject.toml:29:31"
```

> Lembrando que a op√ß√£o de usar aspas simples √© totalmente pessoal, voc√™ pode usar aspas duplas se quiser.

### pytest

O [Pytest](https://docs.pytest.org/){:target="_blank"} √© uma framework de testes, que usaremos para escrever e executar nossos testes. O configuraremos para reconhecer o caminho base para execu√ß√£o dos testes na raiz do projeto `.`:

```toml title="pyproject.toml" linenums="33"
--8<-- "aulas/codigos/01/pyproject.toml:33:35"
```

Na segunda linha dizemos para o pytest adicionar a op√ß√£o `no:warnings`. Para ter uma visualiza√ß√£o mais limpa dos testes, caso alguma biblioteca exiba uma mensagem de warning, isso ser√° suprimido pelo pytest.

### Taskipy

A ideia do [Taskipy](https://github.com/taskipy/taskipy){:target="_blank"} √© ser um executor de tarefas (*task runner*) complementar em nossa aplica√ß√£o. No lugar de ter que lembrar comandos como o do fastapi, que vimos na execu√ß√£o da aplica√ß√£o, que tal substituir ele simplesmente por `task run`?

Isso funcionaria para qualquer comando complicado em nossa aplica√ß√£o. Simplificando as chamadas e tamb√©m para n√£o termos que lembrar de como executar todos os comandos de cabe√ßa.

Alguns comandos que criaremos agora no in√≠cio:

```toml title="pyproject.toml" linenums="37"
--8<-- "aulas/codigos/01/pyproject.toml:37:44"
```

Os comandos definidos fazem o seguinte:

- `lint`: Faz a checagem de boas pr√°ticas do c√≥digo python
- `pre_format`: Faz algumas corre√ß√µes de boas pr√°ticas automaticamente
- `format`: Executa a formata√ß√£o do c√≥digo em rela√ß√£o as conven√ß√µes de estilo de c√≥digo
- `run`: executa o servidor de desenvolvimento do FastAPI
- `pre_test`: executa a camada de lint antes de executar os testes
- `test`: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c√≥digo como base de cobertura
- `post_test`: gera um report de cobertura ap√≥s os testes

Para executar um comando, √© bem mais simples, precisando somente passar a palavra `task <comando>`.

#### Comandos com prefixo `pre` e `pos`

Todos os comandos do taskipy que apresentam prefixos como `pre_commando` ou `pos_commando` n√£o precisam ser executados diretamente. Por exemplo, se executarmos o comando `task test` ele executar√° o comando `pre_test` e caso tudo ocorra bem, sem erros, ele executar√° o `test`, caso n√£o aconte√ßam erros, o `pos_test` ser√° executado.

Nada impede que os comandos com prefixos sejam executados diretamente, mas eles s√£o montados para serem executados em cadeia.

---

??? warning "Caso precise ver o arquivo de configura√ß√£o por completo"

	O meu est√° exatamente assim:

	```toml title="pyproject.toml" linenums="1"
	--8<-- "aulas/codigos/01/pyproject.toml"
	```

	Um ponto importante √© que as vers√µes dos pacotes podem variar dependendo da data em que voc√™ fizer a instala√ß√£o dos pacotes. Esse arquivo √© somente um exemplo.


### Os efeitos dessas configura√ß√µes de desenvolvimento

Caso voc√™ tenha copiado o c√≥digo que usamos para definir `fast_zero/app.py`, pode testar os comandos que criamos para o `taskipy`:

```shell title="$ Execu√ß√£o no terminal!"
task lint
```

Dessa forma, veremos que cometemos algumas infra√ß√µes na formata√ß√£o da PEP-8. O ruff nos informar√° que dever√≠amos ter adicionado duas linhas antes de uma defini√ß√£o de fun√ß√£o:

```python
fast_zero/app.py:5:1: E302 [*] Expected 2 blank lines, found 1
  |
3 | app = FastAPI()
4 | 
5 | @app.get('/')
  | ^ E302
6 | def read_root():
7 |     return {'message': 'Ol√° Mundo!'}
  |
  = help: Add missing blank line(s)

Found 1 error.
[*] 1 fixable with the `--fix` option.
```

Para corrigir isso, podemos usar o nosso comando de formata√ß√£o de c√≥digo:

=== "Comando"
	```shell title="$ Execu√ß√£o no terminal!"
	task format
	Found 1 error (1 fixed, 0 remaining).
	3 files left unchanged
	```

=== "Resultado"
	```py title="fast_zero/app.py" linenums="1" hl_lines="5"
	from fastapi import FastAPI

	app = FastAPI()


	@app.get('/')
	def read_root():
		return {'message': 'Ol√° Mundo!'}
	```

## Introdu√ß√£o ao Pytest: Testando o "Hello, World!"

Antes de entendermos a din√¢mica dos testes, precisamos entender o efeito que eles t√™m no nosso c√≥digo. Podemos come√ßar analisando a cobertura (o quanto do nosso c√≥digo est√° sendo efetivamente testado). Vamos executar os testes:

```shell title="$ Execu√ß√£o no terminal!"
task test
```

Teremos uma resposta como essa:

```shell title="$ Execu√ß√£o no terminal!" hl_lines="7"
=========================== test session starts ===========================
platform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0
cachedir: .pytest_cache
rootdir: /home/dunossauro/git/fast_zero
configfile: pyproject.toml
plugins: cov-4.1.0, anyio-4.2.0
collected 0 items

---------- coverage: platform linux, python 3.11.7-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      5     0%
-------------------------------------------
TOTAL                       5      5     0%
```

As linhas no terminal s√£o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.

??? info "Caso n√£o tenha muita experi√™ncia com Pytest"
	Temos uma live de Python explicando os conceitos b√°sicos da biblioteca
	![type:video](https://www.youtube.com/embed/MjQCvJmc31A)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/MjQCvJmc31A){ .md-button }


A parte importante dessa Mensagem est√° na tabela gerada pelo `coverage`. Que diz que temos 5 linhas de c√≥digo (Stmts) no arquivo `fast_zero/app.py` e nenhuma delas est√° coberta pelos nossos testes. Como podemos ver na coluna `Miss`.

Por n√£o encontrar nenhum teste, o pytest retornou um "erro". Isso significa que nossa tarefa `post_test` n√£o foi executada. Podemos execut√°-la manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

Isso gera um relat√≥rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c√≥digo n√£o est√£o sendo testadas.

![navegador](assets/01/navegador_com_pagina_inicial_do_coverage.png){: .center }

Se clicarmos no arquivo `fast_zero/app.py` podemos ver em vermelho as linhas que n√£o est√£o sendo testadas:

![navegador](assets/01/navegador_com_pagina_de_cobertura_sem_testes.png){: .center  }

Isto significa que precisamos testar todo esse arquivo.

### Escrevendo o teste

Agora, escreveremos nosso primeiro teste com Pytest. Mas, antes de escrever o teste, precisamos criar um arquivo espec√≠fico para eles. Na pasta `tests`, vamos criar um arquivo chamado `test_app.py`.

> Por conven√ß√£o, todos os arquivos de teste do pytest devem iniciar com um prefixo test_<algo>.py

Para testar o c√≥digo feito com FastAPI, precisamos de um cliente de teste. A grande vantagem √© que o FastAPI j√° conta com um cliente de testes no m√≥dulo `fastapi.testclient` com o objeto `TestClient`, que precisa receber nosso app como par√¢metro:

```python title="tests/test_app.py" linenums="1"
--8<-- "aulas/codigos/01/tests/test_app.py::5"
```

1. Importa do m√≥dulo `testclient` o objeto `TestClient`
2. Importa o nosso `app` definido em `fast_zero`
3. Cria um cliente de testes usando a nossa aplica√ß√£o como base

S√≥ o fato de termos definido um cliente, j√° nos mostra uma cobertura bastante diferente:

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 9"
task test
# parte da mensagem foi omitida
collected 0 items

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      1    80%
-------------------------------------------
TOTAL                       5      1    80%
```


Por n√£o coletar nenhum teste, o pytest ainda retornou um "erro". Para ver a cobertura, precisaremos executar novamente o `post_test` manualmente:

```shell title="$ Execu√ß√£o no terminal!"
task post_test
Wrote HTML report to htmlcov/index.html
```

No navegador, podemos ver que a √∫nica linha n√£o "testada" √© aquela onde temos a l√≥gica (o corpo) da fun√ß√£o `read_root`. As linhas de defini√ß√£o est√£o todas verdes:

![browser](assets/01/navegador_com_pagina_de_cobertura_com_estrutuda_de_testes.png){: .center  }

No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n√£o foi.

Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:

```python title="tests/test_app.py" linenums="1"
--8<-- "aulas/codigos/01/tests/test_app.py:8:22"
```

1. No nome da fun√ß√£o, geralmente escrevemos o que o teste de fato faz. Aqui estamos dizendo que root deve retornar o status OK e a mensagem "ol√° mundo". Root √© o nome dado a raiz da URL. O caminho `/`, que colocamos na defini√ß√£o do `#!python @app.get('/')`. OK √© o status que diz que a requisi√ß√£o aconteceu com sucesso no protocolo HTTP.
2. Aqui criamos o cliente de teste do nosso app
3. Nesse ponto, o `client` faz uma requisi√ß√£o. Da mesma forma que o browser, um cliente da API. Nisso, chamamos o endere√ßo de root, usando o m√©todo GET.
4. Aqui fazemos a valida√ß√£o do c√≥digo de resposta, para saber se a resposta √© referente ao c√≥digo `200`, que significa `OK`. Mais informa√ß√µes sobre esse t√≥pico [aqui](02.md#boas-praticas-para-constantes){:target="_blank"}.
5. No final, validamos se o dicion√°rio que enviamos na fun√ß√£o √© o mesmo que recebemos quando fizemos a requisi√ß√£o.
6. Importa√ß√£o da biblioteca nativa do python que abstrai os c√≥digos de resposta e nos apresenta o status. Mais informa√ß√µes sobre esse t√≥pico [aqui](02.md#boas-praticas-para-constantes){:target="_blank"}.

Esse teste faz uma requisi√ß√£o GET no endpoint `/` e verifica se o c√≥digo de status da resposta √© 200 e se o conte√∫do da resposta √© `{'message': 'Ol√° Mundo!'}`.

```shell title="$ Execu√ß√£o no terminal!" hl_lines="3 5 11 16"
task test
# parte da mensagem foi omitida
collected 1 item

tests/test_app.py::test_root_deve_retornar_ok_e_ola_mundo PASSED

---------- coverage: platform linux, python 3.11.3-final-0 -----------
Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      0   100%
-------------------------------------------
TOTAL                       5      0   100%

================ 1 passed in 1.39s ================
Wrote HTML report to htmlcov/index.html
```

Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n√£o deixou de abranger nenhuma linha de c√≥digo.

Como conseguimos coletar um item, o `post_test` foi executado e tamb√©m gerou um HTML com a cobertura atualizada.

![descri√ß√£o](assets/01/navegador_com_pagina_de_cobertura_com_teste.png){: .center }


## Estrutura de um teste

Agora que escrevemos nosso primeiro teste de forma intuitiva, podemos entender o que cada passo do teste faz. Essa compreens√£o √© vital, pois nos ajudar√° a escrever testes com mais confian√ßa e efic√°cia. Para desvendar o m√©todo por tr√°s da nossa abordagem, exploraremos uma estrat√©gia conhecida como [AAA](https://xp123.com/articles/3a-arrange-act-assert/){:target="_blank"}, que divide o teste em tr√™s fases distintas: Arrange, Act, Assert.

??? info "Caso fazer testes ainda seja complicado para voc√™"
	Temos uma live de python focada em ensinar os primeiros passos no mundo dos testes.
	![type:video](https://www.youtube.com/embed/-8H2Pyxnoek)

	[:fontawesome-brands-youtube: Link direto](https://youtu.be/-8H2Pyxnoek){ .md-button }

Para analisar todas as etapas de um teste, usaremos como exemplo este primeiro teste que escrevemos:

```python title="tests/test_app.py" linenums="1"
--8<-- "aulas/codigos/01/tests/test_app.py:24"
```

Com base nesse c√≥digo, podemos observar as tr√™s fases:

### Fase 1 - Organizar (Arrange)

Nesta primeira etapa, estamos preparando o ambiente para o teste. No exemplo, a linha com o coment√°rio `Arrange` n√£o √© o teste em si, ela monta o ambiente para que o teste possa ser executado. Estamos configurando um `client` de testes para fazer a requisi√ß√£o ao `app`.

### Fase 2 - Agir (Act)

Aqui √© a etapa onde acontece a a√ß√£o principal do teste, que consiste em chamar o Sistema Sob Teste ([SUT](http://xunitpatterns.com/SUT.html){:target="_blank"}). No nosso caso, o SUT √© a rota `/`, e a a√ß√£o √© representada pela linha `response = client.get('/')`. Estamos exercitando a rota e armazenando sua resposta na vari√°vel `response`. √â a fase em que o c√≥digo de testes executa o c√≥digo de produ√ß√£o que est√° sendo testado. Agir aqui significa interagir diretamente com a parte do sistema que queremos avaliar, para ver como ela se comporta.

### Fase 3 - *Afirmar* (Assert)

Esta √© a etapa de verificar se tudo correu como esperado. √â f√°cil notar onde estamos fazendo a verifica√ß√£o, pois essa linha sempre tem a palavra reservada `assert`. A verifica√ß√£o √© booleana, ou est√° correta, ou n√£o est√°. Por isso, um teste deve sempre incluir um `assert` para verificar se o comportamento esperado est√° correto.

---

Agora que compreendemos o que cada linha de teste faz em espec√≠fico, podemos nos orientar de forma clara nos testes que escreveremos no futuro. Cada uma das linhas usadas tem uma raz√£o de estar no teste, e conhecer essa estrutura n√£o s√≥ nos d√° uma compreens√£o mais profunda do que estamos fazendo, mas tamb√©m nos d√° confian√ßa para explorar e escrever testes mais complexos.


## Criando nosso reposit√≥rio no git

Antes de concluirmos a aula, precisamos executar alguns passos:

1. Criar um arquivo `.gitignore` para n√£o adicionar o ambiente virtual e outros arquivos desnecess√°rios no versionamento de c√≥digo.
2. Criar um novo reposit√≥rio no GitHub para versionar o c√≥digo.
3. Subir o c√≥digo que fizemos para o GitHub.

**Criando o arquivo .gitignore**

Vamos iniciar com a cria√ß√£o de um arquivo `.gitignore` espec√≠fico para Python. Existem diversos modelos dispon√≠veis na internet, como os [dispon√≠veis pelo pr√≥prio GitHub](https://github.com/github/gitignore){:target="_blank"}, ou o [gitignore.io](https://gitignore.io){:target="_blank"}. Uma ferramenta √∫til √© a [`ignr`](https://github.com/Antrikshy/ignr.py){:target="_blank"}, feita em Python, que faz o download autom√°tico do arquivo para a nossa pasta de trabalho atual:

```shell title="$ Execu√ß√£o no terminal!"
pipx run ignr -p python > .gitignore #(1)!
```

1. O comando `pipx run` vai baixar o `ignr` vai executar o comando e vai desinstalar. N√£o existe a necessidade de termos ele instalado no sistema pois s√≥ ser√° executado dessa vez.

O `.gitignore` √© importante porque ele nos ajuda a evitar que arquivos desnecess√°rios ou sens√≠veis sejam enviados para o reposit√≥rio. Isso inclui o ambiente virtual, arquivos de configura√ß√£o pessoal, entre outros.

**Criando um reposit√≥rio no github**

Agora, com nossos arquivos indesejados ignorados, podemos iniciar o versionamento de c√≥digo usando o `git`. Para criar um reposit√≥rio local, usamos o comando `git init .`. Para criar esse reposit√≥rio no GitHub, utilizaremos o `gh`, um utilit√°rio de linha de comando que nos auxilia nesse processo:

```shell title="$ Execu√ß√£o no terminal!"
git init .
gh repo create
```

Ao executar `gh repo create`, algumas informa√ß√µes ser√£o solicitadas, como o nome do reposit√≥rio e se ele ser√° p√∫blico ou privado. Isso ir√° criar um reposit√≥rio tanto localmente quanto no GitHub.

**Subindo nosso c√≥digo para o github**

Com o reposit√≥rio pronto, vamos versionar nosso c√≥digo. Primeiro, adicionamos o c√≥digo ao pr√≥ximo commit com `git add .`. Em seguida, criamos um ponto na hist√≥ria do projeto com `git commit -m "Configura√ß√£o inicial do projeto"`. Por fim, sincronizamos o reposit√≥rio local com o remoto no GitHub usando `git push`:

```shell title="$ Execu√ß√£o no terminal!"
git add .
git commit -m "Configura√ß√£o inicial do projeto"
git push
```

> Caso seja a primeira vez que est√° utilizando o `git push`, talvez seja necess√°rio configurar suas credenciais do GitHub.

Esses passos garantem que todo o c√≥digo criado na aula esteja versionado e dispon√≠vel para compartilhamento no GitHub.

## Suplementar / Para pr√≥xima aula

Caso o mundo dos testes ainda seja um pouco nebuloso para voc√™, recomendo que antes de partir para a pr√≥xima aula, voc√™ d√™ uma assistida em algumas lives de python de fora desse curso:

- [Uma introdu√ß√£o aos testes: Como fazer? | Live de Python #232](https://youtu.be/-8H2Pyxnoek){:target="_blank"}
- [Pytest: Uma introdu√ß√£o - Live de Python #167](https://youtu.be/MjQCvJmc31A){:target="_blank"}
- [Pytest Fixtures - Live de Python #168](https://youtu.be/sidi9Z_IkLU){:target="_blank"}

## Exerc√≠cio

1. Crie um reposit√≥rio para acompanhar o curso e suba em alguma plataforma, como [Github](https://github.com/), [gitlab](https://gitlab.com/), [codeberg](https://codeberg.org/), etc. E compartilhe o link no [reposit√≥rio do curso](https://github.com/dunossauro/fastapi-do-zero/issues/91) para podermos aprender juntos.

{% include "templates/exercicios.md" %}

## Conclus√£o

Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come√ßar a trabalhar com FastAPI e j√° fizemos nossa primeira imers√£o no Desenvolvimento Orientado por Testes. Na pr√≥xima aula nos aprofundaremos na estrutura√ß√£o da nossa aplica√ß√£o FastAPI. At√© l√°!

{% include "templates/quiz.md" %}
