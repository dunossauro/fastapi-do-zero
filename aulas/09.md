---
title: Dockerizando a nossa aplica√ß√£o e introduzindo o PostgreSQL
description: Nossa aplica√ß√£o um passo mais pr√≥ximo do deploy
---

# Dockerizando a nossa aplica√ß√£o e introduzindo o PostgreSQL

---
Objetivos da aula:

- Compreender os conceitos b√°sicos do Docker
- Entender como criar uma imagem Docker para a nossa aplica√ß√£o FastAPI
- Aprender a rodar a aplica√ß√£o utilizando Docker
- Introduzir o conceito de Docker Compose para gerenciamento de m√∫ltiplos cont√™ineres
- Aprender o que √© um Dockerfile e sua estrutura
- Entender os benef√≠cios e motivos da mudan√ßa de SQLite para PostgreSQL

??? tip "Caso prefira ver a aula em v√≠deo"
	![type:video](https://www.youtube.com/embed/u31qwQUeGuM)

[Aula :fontawesome-brands-youtube:](#){ .md-button }
[Slides :fontawesome-solid-file-powerpoint:](#){ .md-button }
[C√≥digo :fontawesome-solid-code:](https://github.com/dunossauro/fastapi-do-zero/tree/main/codigo_das_aulas/08/){ .md-button }

---

Depois de implementar nosso gerenciador de tarefas na aula anterior, temos uma primeira vers√£o est√°vel da nossa aplica√ß√£o. Nesta aula, al√©m de aprendermos a "dockerizar" nossa aplica√ß√£o FastAPI, tamb√©m abordaremos a migra√ß√£o do banco de dados SQLite para o PostgreSQL.


## O Docker e a nossa aplica√ß√£o

[Docker](https://www.docker.com/){:target="_blank"} √© uma plataforma aberta que permite automatizar o processo de implanta√ß√£o, escalonamento e opera√ß√£o de aplica√ß√µes dentro de cont√™ineres. Ele serve para "empacotar" uma aplica√ß√£o e suas depend√™ncias em um cont√™iner virtual que pode ser executado em qualquer sistema operacional que suporte Docker. Isso facilita a implanta√ß√£o, o desenvolvimento e o compartilhamento de aplica√ß√µes, al√©m de proporcionar um ambiente isolado e consistente.

### Criando nosso Dockerfile

Para criar um container Docker, escrevemos uma lista de passos de como construir o ambiente para execu√ß√£o da nossa aplica√ß√£o em um arquivo chamado `Dockerfile`. Ele define o ambiente de execu√ß√£o, os comandos necess√°rios para preparar o ambiente e o comando a ser executado quando um cont√™iner √© iniciado a partir da imagem.

Uma das coisas interessantes sobre Docker √© que existe um [Hub de containers](https://hub.docker.com/){:target="_blank"} prontos onde a comunidade hospeda imagens "prontas", que podemos usar como ponto de partida. Por exemplo, a comunidade de python mant√©m um grupo de imagens com o [ambiente python](https://hub.docker.com/_/python){:target="_blank"} pronto para uso. Podemos partir dessa imagem com o python j√° instalado adicionar os passos para que nossa aplica√ß√£o seja executada.

Aqui est√° um exemplo de `Dockerfile` para executar nossa aplica√ß√£o:

```docker
FROM python:3.11-slim
ENV POETRY_VIRTUALENVS_CREATE=false

WORKDIR app/
COPY . .

RUN pip install poetry

RUN poetry config installer.max-workers 10
RUN poetry install --no-interaction --no-ansi

EXPOSE 800
CMD [ "poetry", "run", "uvicorn", "--host", "0.0.0.0", "fast_zero.app:app" ]
```

Aqui est√° o que cada linha faz:

1. `FROM python:3.11-slim`: Define a imagem base para nosso cont√™iner. Estamos usando a vers√£o slim da imagem do Python 3.11, que tem tudo que precisamos para rodar nossa aplica√ß√£o.
2. `ENV POETRY_VIRTUALENVS_CREATE=false`: Define uma vari√°vel de ambiente que diz ao Poetry para n√£o criar um ambiente virtual. (O container j√° √© um ambiente isolado)
3. `RUN pip install poetry`: Instala o Poetry, nosso gerenciador de pacotes.
4. `WORKDIR app/`: Define o diret√≥rio em que executaremos os comandos a seguir.
5. `COPY . .`: Copia todos os arquivos do diret√≥rio atual para o cont√™iner.
6. `RUN poetry config installer.max-workers 10`: Configura o Poetry para usar at√© 10 workers ao instalar pacotes.
7. `RUN poetry install --no-interaction --no-ansi`: Instala as depend√™ncias do nosso projeto sem intera√ß√£o e sem cores no output.
8. `EXPOSE 8000`: Informa ao Docker que o cont√™iner vai escutar na porta 8000.
9. `CMD [ "poetry", "run", "uvicorn", "--host", "0.0.0.0", "fast_zero.app:app" ]`: Define o comando que ser√° executado quando o cont√™iner for iniciado.

Vamos entender melhor esse √∫ltimo comando:

- `poetry run` define o comando que ser√° executado dentro do ambiente virtual criado pelo Poetry.
- `uvicorn` √© o servidor ASGI que usamos para rodar nossa aplica√ß√£o.
- `--host` define o host que o servidor vai escutar. Especificamente, `"0.0.0.0"` √© um endere√ßo IP que permite que o servidor aceite conex√µes de qualquer endere√ßo de rede dispon√≠vel, tornando-o acess√≠vel externamente.
- `fast_zero.app:app` define o `<m√≥dulo python>:<objeto>` que o servidor vai executar.

### Criando a imagem

Para criar uma imagem Docker a partir do Dockerfile, usamos o comando `docker build`. O comando a seguir cria uma imagem chamada "fast_zero":

```shell title="$ Execu√ß√£o no terminal!"
docker build -t "fast_zero" .
```

Este comando l√™ o Dockerfile no diret√≥rio atual (indicado pelo `.`) e cria uma imagem com a tag "fast_zero", (indicada pelo `-t`).

Vamos ent√£o verificar se a imagem foi criada com sucesso usando o comando:

```shell title="$ Execu√ß√£o no terminal!"
docker images
```

Este comando lista todas as imagens Docker dispon√≠veis no seu sistema.

### Executando o container

Para executar o cont√™iner, usamos o comando `docker run`. Especificamos o nome do cont√™iner com a flag `--name`, indicamos a imagem que queremos executar e a tag que queremos usar `<nome_da_imagem>:<tag>`. A flag `-p` serve para mapear a porta do host para a porta do cont√™iner `<porta_do_host>:<porta_do_cont√™iner>`. Portanto, teremos o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
docker run --name fastzeroapp -p 8000:8000 fast_zero:latest
```

Este comando iniciar√° nossa aplica√ß√£o dentro de um cont√™iner Docker, que estar√° escutando na porta 8000. Para testar se tudo est√° funcionando corretamente, voc√™ pode acessar `http://localhost:8000` em um navegador ou usar um comando como:

```shell title="$ Execu√ß√£o no terminal!"
curl http://localhost:8000
```

???+ danger "Caso voc√™ fique preso no terminal"

	Caso voc√™ tenha a aplica√ß√£o travada no terminal e n√£o consiga sair, voc√™ pode teclar ++ctrl+"C"++ para parar a execu√ß√£o do container.


### Gerenciando Containers docker

Quando voc√™ trabalha com Docker, √© importante saber como gerenciar os cont√™ineres. Aqui est√£o algumas opera√ß√µes b√°sicas para gerenci√°-los:

1. **Rodar um cont√™iner em background**: Se voc√™ deseja executar o cont√™iner em segundo plano para que n√£o ocupe o terminal, pode usar a op√ß√£o `-d`:

    ```shell title="$ Execu√ß√£o no terminal!"
    docker run -d --name fastzeroapp -p 8000:8000 fast_zero:latest
    ```

2. **Parar um cont√™iner**: Quando voc√™ "para" um cont√™iner, est√° essencialmente interrompendo a execu√ß√£o do processo principal do cont√™iner. Isso significa que o cont√™iner n√£o est√° mais ativo, mas ainda existe no sistema, junto com seus dados associados e configura√ß√£o. Isso permite que voc√™ reinicie o cont√™iner posteriormente, se desejar.

	```shell title="$ Execu√ß√£o no terminal!"
    docker stop fastzeroapp
    ```

3. **Remover um cont√™iner**: Ao "remover" um cont√™iner, voc√™ est√° excluindo o cont√™iner do sistema. Isso significa que todos os dados associados ao cont√™iner s√£o apagados. Uma vez que um cont√™iner √© removido, voc√™ n√£o pode reinici√°-lo; no entanto, voc√™ pode sempre criar um novo cont√™iner a partir da mesma imagem.

	```shell title="$ Execu√ß√£o no terminal!"
    docker rm fastzeroapp
    ```

Ambos os comandos (stop e rm) usam o nome do cont√™iner que definimos anteriormente com a flag `--name`. √â uma boa pr√°tica manter a gest√£o dos seus cont√™ineres, principalmente durante o desenvolvimento, para evitar um uso excessivo de recursos ou conflitos de nomes e portas.

## Introduzindo o postgreSQL

O [PostgreSQL](https://www.postgresql.org/) √© um Sistema de Gerenciamento de Banco de Dados Objeto-Relacional (ORDBMS) poderoso e de c√≥digo aberto. Ele √© amplamente utilizado em produ√ß√£o em muitos projetos devido √† sua robustez, escalabilidade e conjunto de recursos extensos.

Mudar para um banco de dados como PostgreSQL tem v√°rios benef√≠cios:

- **Escalabilidade**: SQLite n√£o √© ideal para aplica√ß√µes em larga escala ou com grande volume de dados. PostgreSQL foi projetado para lidar com uma grande quantidade de dados e requisi√ß√µes.
- **Concorr√™ncia**: Diferentemente do SQLite, que tem limita√ß√µes para grava√ß√µes simult√¢neas, o PostgreSQL suporta m√∫ltiplas opera√ß√µes simult√¢neas.
- **Funcionalidades avan√ßadas**: PostgreSQL vem com v√°rias extens√µes e funcionalidades que o SQLite pode n√£o oferecer.

Al√©m disso, SQLite tem algumas limita√ß√µes que podem torn√°-lo inadequado para produ√ß√£o em alguns casos. Por exemplo, ele n√£o suporta alta concorr√™ncia e pode ter problemas de performance com grandes volumes de dados.

!!! note "Nota"
	Embora para o escopo da nossa aplica√ß√£o e os objetivos de aprendizado o SQLite pudesse ser suficiente, √© sempre bom nos prepararmos para cen√°rios de produ√ß√£o real. A ado√ß√£o de PostgreSQL nos d√° uma pr√©via das pr√°ticas do mundo real e garante que nossa aplica√ß√£o possa escalar sem grandes modifica√ß√µes de infraestrutura.

### Como executar o postgres?

Embora o PostgreSQL seja poderoso, sua instala√ß√£o direta em uma m√°quina real pode ser desafiadora e pode resultar em configura√ß√µes diferentes entre os ambientes de desenvolvimento. Felizmente, podemos utilizar o Docker para resolver esse problema. No Docker Hub, est√£o dispon√≠veis imagens pr√©-constru√≠das do PostgreSQL, permitindo-nos executar o PostgreSQL com um √∫nico comando. Confira a [imagem oficial do PostgreSQL](https://hub.docker.com/_/postgres).

Para executar um cont√™iner do PostgreSQL, use o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
docker run -d \
    --name app_database \
    -e POSTGRES_USER=app_user \
    -e POSTGRES_DB=app_db \
    -e POSTGRES_PASSWORD=app_password \
    -p 5432:5432 \
    postgres
```

#### Explicando as Flags e Configura√ß√µes

- **Flag `-e`**:

  Esta flag √© usada para definir vari√°veis de ambiente no cont√™iner. No contexto do PostgreSQL, essas vari√°veis s√£o essenciais. Elas configuram o nome de usu√°rio, nome do banco de dados, e senha durante a primeira execu√ß√£o do cont√™iner. Sem elas, o PostgreSQL pode n√£o iniciar da forma esperada. √â uma forma pr√°tica de configurar o PostgreSQL sem interagir manualmente ou criar arquivos de configura√ß√£o.

- **Porta `5432`**:

  O PostgreSQL, por padr√£o, escuta por conex√µes na porta `5432`. Mapeando esta porta do cont√™iner para a mesma porta no host (usando `-p`), fazemos com que o PostgreSQL seja acess√≠vel nesta porta na m√°quina anfitri√£, permitindo que outras aplica√ß√µes se conectem a ele.

!!! warning "Sobre as vari√°veis"

	Os valores acima (`app_user`, `app_db`, e `app_password`) s√£o padr√µes gen√©ricos para facilitar a inicializa√ß√£o do PostgreSQL em um ambiente de desenvolvimento. No entanto, √© altamente recomend√°vel que voc√™ altere esses valores, especialmente `app_password`, para garantir a seguran√ßa do seu banco de dados.

#### Volumes e Persist√™ncia de Dados

Para garantir a persist√™ncia dos dados entre execu√ß√µes do cont√™iner, utilizamos volumes. Um volume mapeia um diret√≥rio do sistema host para um diret√≥rio no cont√™iner. Isso √© crucial para bancos de dados, pois sem um volume, ao remover o cont√™iner, todos os dados armazenados dentro dele se perderiam.

No PostgreSQL, o diret√≥rio padr√£o para armazenamento de dados √© `/var/lib/postgresql/data`. Mapeamos esse diret√≥rio para um volume (neste caso "pgdata") em nossa m√°quina host para garantir a persist√™ncia dos dados:

```shell title="$ Execu√ß√£o no terminal!"
docker run -d \
    --name app_database \
    -e POSTGRES_USER=app_user \
    -e POSTGRES_DB=app_db \
    -e POSTGRES_PASSWORD=app_password \
    -v pgdata:/var/lib/postgresql/data \
    -p 5432:5432 \
    postgres
```

O par√¢metro do volume √© passado ao cont√™iner usando o par√¢metro `-v` Dessa forma, os dados do banco continuar√£o existindo, mesmo que o cont√™iner seja reiniciado ou removido.

### Adicionando o suporte ao PostgreSQL na nossa aplica√ß√£o

Para que o SQLAlchemy suporte o PostgreSQL, precisamos instalar uma depend√™ncia chamada `psycopg2-binary`. Este √© o adaptador PostgreSQL para Python e √© crucial para fazer a comunica√ß√£o.

Para instalar essa depend√™ncia, utilize o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
poetry add psycopg2-binary
```

Uma das vantagens do SQLAlchemy enquanto ORM √© a flexibilidade. Com apenas algumas altera√ß√µes m√≠nimas, como a atualiza√ß√£o da string de conex√£o, podemos facilmente transicionar para um banco de dados diferente. Assim, ap√≥s ajustar o arquivo `.env` com a string de conex√£o do PostgreSQL, a aplica√ß√£o dever√° operar normalmente, mas desta vez utilizando o PostgreSQL.

Para ajustar a conex√£o com o PostgreSQL, modifique seu arquivo `.env` para incluir a seguinte string de conex√£o:

```bash title=".env"
DATABASE_URL="postgresql://app_user:app_password@localhost:5432/app_db"
```

!!! failure "Caso tenha alterado as vari√°veis de ambiente do cont√™iner"

	Se voc√™ alterou `app_user`, `app_password` ou `app_db` ao inicializar o cont√™iner PostgreSQL, garanta que esses valores sejam refletidos na string de conex√£o acima. A palavra `localhost` indica que o banco de dados PostgreSQL est√° sendo executado na mesma m√°quina que sua aplica√ß√£o. Se o banco de dados estiver em uma m√°quina diferente, substitua `localhost` pelo endere√ßo IP correspondente e, se necess√°rio, ajuste a porta `5432`.


### Executando as migra√ß√µes

Migra√ß√µes s√£o como vers√µes para seu banco de dados, permitindo que voc√™ atualize sua estrutura de forma ordenada e controlada. Sempre que mudamos de banco de dados, ou at√© mesmo quando alteramos sua estrutura, as migra√ß√µes precisam ser executadas para garantir que a base de dados esteja em sincronia com nosso c√≥digo.

No contexto de cont√™ineres, rodar as migra√ß√µes se torna ainda mais simples. Quando mudamos de banco de dados, como √© o caso de termos sa√≠do de um SQLite (por exemplo) para um PostgreSQL, as migra√ß√µes s√£o essenciais. O motivo √© simples: o novo banco de dados n√£o ter√° a estrutura e os dados do antigo, a menos que migremos. As migra√ß√µes ir√£o garantir que o novo banco de dados tenha a mesma estrutura e rela√ß√µes que o anterior.

??? warning "Antes de executar o proximo comando"
	Assegure-se de que ambos os cont√™ineres, tanto da aplica√ß√£o quanto do banco de dados, estejam ativos. O cont√™iner do banco de dados deve estar rodando para que a aplica√ß√£o possa se conectar a ele.
	
    Assegure-se de que o cont√™iner da aplica√ß√£o esteja ativo. Estamos usando a flag `--network=host` para que o cont√™iner use a rede do host. Isso pode ser essencial para evitar problemas de conex√£o, j√° que n√£o podemos prever como est√° configurada a rede do computador onde este comando ser√° executado.

    ```bash title="execu√ß√£o no terminal"
    docker run -d --network=host --name fastzeroapp -p 8000:8000 fast_zero:latest
    ```

Para aplicar migra√ß√µes em um ambiente com cont√™ineres, frequentemente temos comandos espec√≠ficos associados ao servi√ßo. Vejamos como executar migra√ß√µes usando o Docker:

```shell title="$ Execu√ß√£o no terminal!"
docker exec -it fastzeroapp poetry run alembic upgrade head
```

O comando `docker exec` √© usado para invocar um comando espec√≠fico dentro de um cont√™iner em execu√ß√£o. A op√ß√£o `-it` √© uma combina√ß√£o de `-i` (interativo) e `-t` (pseudo-TTY), que juntas garantem um terminal interativo, permitindo a comunica√ß√£o direta com o cont√™iner.

Ap√≥s executar as migra√ß√µes, voc√™ pode verificar a cria√ß√£o das tabelas utilizando um sistema de gerenciamento de banco de dados. A seguir, apresentamos um exemplo com o Beekeeper Studio:

![Tabelas do PostgreSQL no Beekeeper Studio](assets/10_beekeeper_postgres.png)

**Lembre-se**: Embora as tabelas estejam agora criadas e estruturadas, o banco de dados ainda n√£o cont√©m os dados anteriormente presentes no SQLite ou em qualquer outro banco que voc√™ estivesse utilizando antes.


## Simplificando nosso fluxo com `docker-compose`

Docker Compose √© uma ferramenta que permite definir e gerenciar aplicativos multi-cont√™iner com Docker. **√â como se voc√™ tivesse um maestro conduzindo uma orquestra: o maestro (ou Docker Compose) garante que todos os m√∫sicos (ou cont√™ineres) toquem em harmonia.** Definimos nossa aplica√ß√£o e servi√ßos relacionados, como o PostgreSQL, em um arquivo `docker-compose.yml` e os gerenciamos juntos atrav√©s de comandos simplificados.

Ao adotar o Docker Compose, facilitamos o desenvolvimento e a execu√ß√£o da nossa aplica√ß√£o com seus servi√ßos dependentes utilizando um √∫nico comando.

### Cria√ß√£o do `docker-compose.yml`

```yaml linenums="1" title="docker-compose.yaml"
version: '3'

services:
  fastzero_database:
    image: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: app_user
      POSTGRES_DB: app_db
      POSTGRES_PASSWORD: app_password
    ports:
      - "5432:5432"

  fastzero_app:
    image: fastzero_app
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    depends_on:
      - fastzero_database
    environment:
      DATABASE_URL: postgresql://app_user:app_password@fastzero_database:5432/app_db

volumes:
  pgdata:
```


**Explica√ß√£o linha a linha:**

1. `version: '3'`: Especifica a vers√£o do formato do arquivo Compose. O n√∫mero '3' √© uma das vers√µes mais recentes e amplamente usadas.

2. `services:`: Define os servi√ßos (cont√™ineres) que ser√£o gerenciados.

3. `fastzero_database:`: Define nosso servi√ßo de banco de dados PostgreSQL.

4. `image: postgres`: Usa a imagem oficial do PostgreSQL.

5. `volumes:`: Mapeia volumes para persist√™ncia de dados.

   - `pgdata:/var/lib/postgresql/data`: Cria ou usa um volume chamado "pgdata" e o mapeia para o diret√≥rio `/var/lib/postgresql/data` no cont√™iner.

6. `environment:`: Define vari√°veis de ambiente para o servi√ßo.

7. `fastzero_app:`: Define o servi√ßo para nossa aplica√ß√£o.

8. `image: fastzero_app`: Usa a imagem Docker da nossa aplica√ß√£o.

9. `build:` : Instru√ß√µes para construir a imagem se n√£o estiver dispon√≠vel, nosso `Dockerfile`.

10. `ports:`: Mapeia portas do cont√™iner para o host.

   - `"8000:8000"`: Mapeia a porta 8000 do cont√™iner para a porta 8000 do host.

11. `depends_on:`: Especifica que `fastzero_app` depende de `fastzero_database`. Isto garante que o banco de dados seja iniciado antes da aplica√ß√£o.

12. `DATABASE_URL: ...`: √â uma vari√°vel de ambiente que nossa aplica√ß√£o usar√° para se conectar ao banco de dados. Aqui, ele se conecta ao servi√ßo `fastzero_database` que definimos anteriormente.

13. `volumes:` (n√≠vel superior): Define volumes que podem ser usados pelos servi√ßos.

14. `pgdata:`: Define um volume chamado "pgdata". Este volume √© usado para persistir os dados do PostgreSQL entre as execu√ß√µes do cont√™iner.

!!! warning "Sobre o docker-compose"
	Para usar o Docker Compose, voc√™ precisa t√™-lo instalado em seu sistema. Ele n√£o est√° inclu√≠do na instala√ß√£o padr√£o do Docker, ent√£o lembre-se de instal√°-lo separadamente!

	O guia oficial de instala√ß√£o pode ser encontrado [aqui](https://docs.docker.com/compose/install/){:target="_blank"}

Com este arquivo `docker-compose.yml`, voc√™ pode iniciar ambos os servi√ßos (aplica√ß√£o e banco de dados) simultaneamente usando:

```bash
docker-compose up
```

Para parar os servi√ßos e manter os dados seguros nos volumes definidos, use:

```bash
docker-compose down
```

Esses comandos simplificam o fluxo de trabalho e garantem que os servi√ßos iniciem corretamente e se comuniquem conforme o esperado.

!!! note "Execu√ß√£o em modo desanexado"
	Voc√™ pode iniciar os servi√ßos em segundo plano com a flag `-d` usando `docker-compose up -d`. Isso permite que os cont√™ineres rodem em segundo plano, liberando o terminal para outras tarefas.

### Rodando as migra√ß√µes de forma autom√°tica

Automatizar as migra√ß√µes do banco de dados √© uma pr√°tica recomendada para garantir que sua aplica√ß√£o esteja sempre sincronizada com o estado mais atual do seu esquema de banco de dados. √â como preparar todos os ingredientes antes de come√ßar a cozinhar: voc√™ garante que tudo o que √© necess√°rio est√° pronto para ser usado.

Para automatizar as migra√ß√µes em nossos cont√™ineres Docker, utilizamos um `entrypoint`. O `entrypoint` define o comando que ser√° executado quando o cont√™iner iniciar. Em outras palavras, √© o primeiro ponto de entrada de execu√ß√£o do cont√™iner.

**Por que usar o Entrypoint?**

No Docker, o `entrypoint` permite que voc√™ configure um ambiente de cont√™iner que ser√° executado como um execut√°vel. √â √∫til para preparar o ambiente, como realizar migra√ß√µes de banco de dados, antes de iniciar a aplica√ß√£o propriamente dita. Isso significa que qualquer comando definido no `CMD` do Dockerfile n√£o ser√° executado automaticamente se um `entrypoint` estiver definido. Em vez disso, precisamos incluir explicitamente esse comando no script de `entrypoint`.


**Implementando o Entrypoint**

Criamos um script chamado `entrypoint.sh` que ir√° preparar nosso ambiente antes de a aplica√ß√£o iniciar:

```bash title="entrypoin.sh" linenums="1"
#!/bin/sh

# Executa as migra√ß√µes do banco de dados
poetry run alembic upgrade head

# Inicia a aplica√ß√£o
poetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app
```

**Explica√ß√£o Detalhada do Script**:

- `#!/bin/sh`: Indica ao sistema operacional que o script deve ser executado no shell Unix.
- `poetry run alembic upgrade head`: Roda as migra√ß√µes do banco de dados at√© a √∫ltima vers√£o.
- `poetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app`: Inicia a aplica√ß√£o. Este √© o comando que normalmente estaria no `CMD` do Dockerfile, mas agora est√° inclu√≠do no `entrypoint` para garantir que as migra√ß√µes sejam executadas antes do servidor iniciar.

**Como Funciona na Pr√°tica?**

Quando o cont√™iner √© iniciado, o Docker executa o script de `entrypoint`, que por sua vez executa as migra√ß√µes e s√≥ ent√£o inicia a aplica√ß√£o. Isso garante que o banco de dados esteja atualizado com as √∫ltimas migra√ß√µes antes de qualquer intera√ß√£o com a aplica√ß√£o.

**Visualizando o Processo**:

Voc√™ pode pensar no `entrypoint.sh` como o ato de aquecer e verificar todos os instrumentos antes de uma apresenta√ß√£o musical. Antes de a m√∫sica come√ßar, cada instrumento √© afinado e testado. Da mesma forma, nosso script assegura que o banco de dados est√° em harmonia com a aplica√ß√£o antes de ela come√ßar a receber requisi√ß√µes.


**Adicionando o Entrypoint ao Docker Compose**:

Inclu√≠mos o `entrypoint` no nosso servi√ßo no arquivo `docker-compose.yml`, garantindo que esteja apontando para o script correto:


```yaml title="docker-compose.yaml" linenums="15" hl_lines="3"
  fastzero_app:
    image: fastzero_app
    entrypoint: ./entrypoint.sh
    build:
      context: .
      dockerfile: Dockerfile
```

**Reconstruindo e Executando com Novas Configura√ß√µes**:

Para aplicar as altera√ß√µes, reconstru√≠mos e executamos os servi√ßos com a op√ß√£o `--build`:

```shell title="$ Execu√ß√£o no terminal!"
docker-compose up --build
```

**Observando o Comportamento Esperado**:

Quando o cont√™iner √© iniciado, voc√™ deve ver as migra√ß√µes sendo aplicadas, seguidas pela inicializa√ß√£o da aplica√ß√£o:

```shell title="$ Exemplo do resultado no terminal!" hl_lines="1 2 6"
fastzero_app-1  | INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
fastzero_app-1  | INFO  [alembic.runtime.migration] Will assume transactional DDL.
fastzero_app-1  | INFO:     Started server process [10]
fastzero_app-1  | INFO:     Waiting for application startup.
fastzero_app-1  | INFO:     Application startup complete.
fastzero_app-1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
```

Este processo garante que as migra√ß√µes do banco de dados s√£o realizadas automaticamente, mantendo a base de dados alinhada com a aplica√ß√£o e pronta para a√ß√£o assim que o servidor Uvicorn entra em cena.

---

??? info "Nota de revis√£o sobre vari√°veis de ambiente"
	Utilizar vari√°veis de ambiente definidas em um arquivo `.env` √© uma pr√°tica recomendada para cen√°rios de produ√ß√£o devido √† seguran√ßa que oferece. No entanto, para manter a simplicidade e o foco nas funcionalidades do FastAPI neste curso, optamos por explicitar essas vari√°veis no `docker-compose.yml`. Isso √© particularmente relevante, pois o Docker Compose √© utilizado apenas para o ambiente de desenvolvimento; no deploy para [fly.io](http://fly.io), o qual √© o nosso foco, o compose n√£o ser√° utilizado em produ√ß√£o.

	Ainda assim, √© valioso mencionar como essa configura√ß√£o mais segura seria realizada, especialmente para aqueles que planejam utilizar o Docker Compose em produ√ß√£o.

	---

    Em ambientes de produ√ß√£o com Docker Compose, √© uma boa pr√°tica gerenciar vari√°veis de ambiente sens√≠veis, como credenciais, por meio de um arquivo `.env`. Isso previne a exposi√ß√£o dessas informa√ß√µes diretamente no arquivo `docker-compose.yml`, contribuindo para a seguran√ßa do projeto.

    As vari√°veis de ambiente podem ser definidas em nosso arquivo `.env` localizado na raiz do projeto:

    ```plaintext title=".env"
    POSTGRES_USER=app_user
    POSTGRES_DB=app_db
    POSTGRES_PASSWORD=app_password
    DATABASE_URL=postgresql://app_user:app_password@fastzero_database:5432/app_db
    ```

	Para aplicar essas vari√°veis, referencie o arquivo `.env` no `docker-compose.yml`:

	```yaml title="docker-compose.yaml" hl_lines="4 5 10 11"
    services:
      fastzero_database:
        image: postgres
        env_file:
          - .env
        # Restante da configura√ß√£o...

      fastzero_app:
        build: .
        env_file:
          - .env
        # Restante da configura√ß√£o...
    ```

	Adotar essa abordagem evita a exposi√ß√£o das vari√°veis de ambiente no arquivo de configura√ß√£o. Esta n√£o foi a abordagem padr√£o no curso devido √† complexidade adicional e √† inten√ß√£o de evitar confus√µes. Dependendo do ambiente estabelecido pela equipe de DevOps/SRE em um projeto real, essa gest√£o pode variar entre vari√°veis de ambiente, arquivos `.env` ou solu√ß√µes mais avan√ßadas como [Vault](https://www.hashicorp.com/products/vault){:target="_blank"}.

	Se optar por utilizar um arquivo `.env` com as configura√ß√µes do PostgreSQL, configure o Pydantic para ignorar vari√°veis de ambiente que n√£o s√£o necess√°rias, adicionando `#!py extra='ignore'` a chamada de `SettingsConfigDic`:

	```py title="fast_zero/settings.py" linenums="1"
	from pydantic_settings import BaseSettings, SettingsConfigDict


	class Settings(BaseSettings):
		model_config = SettingsConfigDict(
			env_file='.env', env_file_encoding='utf-8', extra='ignore'
		)

        DATABASE_URL: str
		SECRET_KEY: str
		ALGORITHM: str
		ACCESS_TOKEN_EXPIRE_MINUTES: int
	```

    Com essa configura√ß√£o, o Pydantic ir√° ignorar quaisquer vari√°veis no `.env` que n√£o sejam explicitamente declaradas na classe `Settings`, evitando assim conflitos e erros inesperados.

	>  Agradecimentos especiais a [@vcwild](https://github.com/vcwild) e [@williangl](https://github.com/williangl) pelas revis√µes valiosas nesta aula que me fizeram criar essa nota. :heart:


## Testes com Docker

Agora que temos o `docker-compose` configurado, realizar testes tornou-se uma tarefa simplificada. Podemos executar toda a su√≠te de testes com um √∫nico comando, sem a necessidade de ajustes adicionais ou configura√ß√µes complexas. Isso √© poss√≠vel devido √† maneira como o `docker-compose` gerencia os servi√ßos e suas depend√™ncias.

Para executar os testes, utilizamos o comando:

```shell title="$ Execu√ß√£o no terminal!"
docker-compose run --entrypoint="poetry run task test" fastzero_app
```

Vamos entender melhor o que cada parte do comando faz:

- `docker-compose run`: Este comando executa um servi√ßo √∫nico definido no seu arquivo `docker-compose.yml`. Ao contr√°rio do `docker-compose up`, que inicia todos os servi√ßos, o `run` permite que voc√™ inicie um servi√ßo espec√≠fico.

- `--entrypoint`: A flag `--entrypoint` substitui o ponto de entrada padr√£o do container. O ponto de entrada padr√£o √© especificado no `Dockerfile` ou no `docker-compose.yml` e normalmente √© o comando que inicia sua aplica√ß√£o. Ao substituir o entrypoint, voc√™ pode executar comandos diferentes, como neste caso, onde queremos rodar nossos testes.

- `"poetry run task test"`: Este √© o comando que substituir√° o entrypoint padr√£o. Ele diz ao Docker para iniciar o container e executar a nossa su√≠te de testes com o Poetry, uma ferramenta para gerenciamento de depend√™ncias e pacotes em Python.

- `fastzero_app`: Este √© o nome do servi√ßo que definimos no `docker-compose.yml`. √â o servi√ßo que cont√©m a nossa aplica√ß√£o FastAPI e onde nossos testes ser√£o executados.

Ao utilizar esse comando, o Docker Compose cuidar√° de iniciar os servi√ßos dos quais `fastzero_app` depende, neste caso, o servi√ßo `fastzero_database` do PostgreSQL. Isso √© importante porque nossos testes podem depender de um banco de dados ativo para funcionar corretamente. O Compose garante que a ordem de inicializa√ß√£o dos servi√ßos seja respeitada e que o servi√ßo do banco de dados esteja pronto antes de iniciar os testes.

Se executarmos o comando podemos ver que ele inicia o banco de dados, inicia o container da aplica√ß√£o e na sequ√™ncia executa o comando que passamos no `--entreypoint` que √© exatamente como executar os testes:

```shell title="$ Execu√ß√£o no terminal!"
docker-compose run --entrypoint="poetry run task test" fastzero_app

# Resulado esperado
[+] Building 0.0s (0/0)                                           docker:default
[+] Creating 2/2
 ‚úî Network default                Created                      0.1s 
 ‚úî Container fastzero_database-1  Created                      0.1s 
[+] Running 1/1
 ‚úî Container fastzero_database-1  Started                      0.3s 
[+] Building 0.0s (0/0)                                           docker:default
All done! ‚ú® üç∞ ‚ú®
18 files would be left unchanged.
================ test session starts ================
platform linux - Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 - /app/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
plugins: cov-4.1.0, anyio-4.1.0, Faker-20.1.0
collected 27 items

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
...
```

√â importante notar que, embora o `docker-compose run` inicie as depend√™ncias necess√°rias para a execu√ß√£o do servi√ßo especificado, ele n√£o finaliza essas depend√™ncias ap√≥s a conclus√£o do comando. Isso significa que ap√≥s a execu√ß√£o dos testes, o servi√ßo do banco de dados continuar√° ativo. Voc√™ precisar√° finaliz√°-lo manualmente com `docker-compose down` para encerrar todos os servi√ßos e limpar o ambiente:

```shell title="$ Execu√ß√£o no terminal!"
docker-compose down
[+] Running 2/2
 ‚úî Container 09-fastzero_database-1  Removed    0.4s 
 ‚úî Network 09_default                Removed
```

Assim tendo o ambiente limpo novamente.

### Executando os testes no PostgreSQL

Embora nosso `docker-compose` esteja configurado para levantar o banco de dados PostgreSQL ao executar os testes, √© importante ressaltar que o container do PostgreSQL n√£o est√° sendo utilizado durante a execu√ß√£o dos testes. Isso acontece porque a fixture respons√°vel por criar a sess√£o do banco de dados est√° com as instru√ß√µes "hardcoded" para o SQLite, como no c√≥digo abaixo:

```py title="tests/conftest.py" linenums="1" hl_lines="3-7"
@pytest.fixture
def session():
    engine = create_engine(
        'sqlite:///:memory:',
        connect_args={'check_same_thread': False},
        poolclass=StaticPool,
    )
    Base.metadata.create_all(engine)

    Session = sessionmaker(bind=engine)

    yield Session()

    Base.metadata.drop_all(engine)
```

Por conta disso, os testes t√™m sido executados no SQLite, mesmo com a presen√ßa do PostgreSQL no ambiente do Docker.

No entanto, √© importante que os testes sejam executados no mesmo ambiente que o que rodar√° em produ√ß√£o, para que n√£o encontremos problemas relacionados a incompatibilidade de opera√ß√µes no banco de dados. A altera√ß√£o √© relativamente simples, temos que tornar a nossa fixture o mais pr√≥ximo poss√≠vel do cliente da sess√£o de produ√ß√£o. Para fazer isso, precisamos alterar somente a chamada `create_engine` para carregar a var√°vel de ambiente do banco de dados de testes. Desta forma:


```py title="tests/conftest.py" linenums="1" hl_lines="9 17"
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from fast_zero.app import app
from fast_zero.database import get_session
from fast_zero.models import Base
from fast_zero.settings import Settings
from fast_zero.security import get_password_hash
from tests.factories import UserFactory


@pytest.fixture
def session():
    database = 
    engine = create_engine(Settings().DATABASE_URL)
    Session = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    with Session() as session:
        yield session
        session.rollback()

    Base.metadata.drop_all(engine)
```

Com essa modifica√ß√£o, agora estamos apontando para o banco de dados PostgreSQL, conforme definido nas configura√ß√µes da nossa aplica√ß√£o (`Settings().DATABASE_URL`). A transi√ß√£o do SQLite para o PostgreSQL √© facilitada pela abstra√ß√£o fornecida pelo SQLAlchemy, que nos permite mudar de um banco para outro sem problemas. √â importante notar que essa flexibilidade se deve ao fato de n√£o termos utilizado recursos espec√≠ficos do PostgreSQL que n√£o s√£o suportados pelo SQLite. Caso contr√°rio, a mudan√ßa poderia n√£o ser t√£o direta.

Agora, com a nova configura√ß√£o, os testes utilizar√£o o PostgreSQL, proporcionando um ambiente de testes mais fiel ao ambiente de produ√ß√£o e, consequentemente, aumentando a confiabilidade dos testes executados:

```shell title="$ Execu√ß√£o no terminal!"
docker-compose run --entrypoint="poetry run task test" fastzero_app

# resultado esperado
docker-compose run --entrypoint="poetry run task test" fastzero_app
[+] Building 0.0s (0/0)                                          docker:default
[+] Creating 1/0
 ‚úî Container 09-fastzero_database-1  Running                     0.0s 
[+] Building 0.0s (0/0)                                          docker:default
All done! ‚ú® üç∞ ‚ú®
18 files would be left unchanged.
======================= test session starts =======================
platform linux - Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 - /app/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app
configfile: pyproject.toml
plugins: cov-4.1.0, anyio-4.1.0, Faker-20.1.0
collected 27 items

tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED
```

Dessa forma temos um ambiente mais coeso e podemos reproduzir nossas configura√ß√µes de forma bastante simples em qualquer ambiente.

## Commit

Ap√≥s criar nosso arquivo `Dockerfile` e `docker-compose.yaml`, executar os testes e construir nosso ambiente, podemos fazer o commit das altera√ß√µes no Git:

1. Adicionando todos os arquivos modificados nessa aula com `git add .`
2. Fa√ßa o commit das altera√ß√µes com `git commit -m "Dockerizando nossa aplica√ß√£o e alterando os testes para serem executados no PostgreSQL"`
3. Envie as altera√ß√µes para o reposit√≥rio remoto com `git push`

## Conclus√£o

Dockerizar nossa aplica√ß√£o FastAPI, junto com o PostgreSQL, nos permite garantir consist√™ncia em diferentes ambientes. A combina√ß√£o de Docker e Docker Compose simplifica o processo de desenvolvimento e implanta√ß√£o. Na pr√≥xima aula, vamos aprender como levar nossa aplica√ß√£o para o pr√≥ximo n√≠vel executando os testes de forma remota com a integra√ß√£o cont√≠nua do GitHub Actions.
