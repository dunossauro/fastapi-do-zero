# [WIP] Fazendo deploy no Fly.io e configurando o PostgreSQL

Aula em manutenção. Discussões no tópico de manutenção na issue [#58](https://github.com/dunossauro/fastapi-do-zero/issues/58){:target="_blank"} do repositório.

---

**Objetivos da aula:**

- Entender o que é o Fly.io e como instalar sua CLI
- Aprender a fazer o deploy de uma aplicação Docker no Fly.io
- Configurar uma instância do PostgreSQL no Fly.io
- Configurar as variáveis de ambiente
- Rodar as migrações do Alembic
- Configurar o deploy contínuo no Github Actions

---

Agora que temos uma API criada com integração ao banco de dados e testes sendo executados via integração contínua. Chegou a tão esperada hora de colocar nossa aplicação em produção para que todas as pessoas possam acessá-la. Colacaremos nossa aplicação em produção usando um serviço de [PaaS](https://pt.wikipedia.org/wiki/Plataforma_como_servi%C3%A7o){:target="_blank"}, chamado [Fly.io](https://fly.io){:target="_blank"}.


## O Fly.io

O Fly.io é uma plataforma de deploy que nos permite lançar nossas aplicações na nuvem e que oferece serviços para diversas linguagens de programação e frameworks como Python e Django, PHP e Laravel, Ruby e Rails, Elixir e Phoenix, etc. 

Ao mesmo tempo, em que permite que o deploy de aplicações em containers docker também possam ser utilizadas, como é o nosso caso. Além disso, o Fly disponibiliza bancos de dados para serem usados em nossas aplicações, como PostgreSQL e [Redis](https://redis.io/){:target="_blank"}.

O motivo pela escolha do Fly é que ele permite que façamos deploys de aplicações em desenvolvimento / provas de conceito de forma gratuita - o que vamos usar para "colocar nossa aplicação no mundo".

> Para fazer o uso do fly.io é necessário que você [crie uma conta no serviço](https://fly.io/app/sign-in){:target="_blank"}.


### Flyclt

Uma das formas de interagir com a plataforma é via uma aplicação de linha de comando disponibilizada pelo Fly, o [flyctl](https://fly.io/docs/flyctl/){:target="_blank"}.

O flyctl precisa ser instalado em seu computador. Em algumas distribuições linux o flyctl está disponível nos repositórios de aplicações. Para Mac/Windows ou distribuições linux que não contam com o pacote no repositório, você pode seguir o guia de [instalação oficial](https://fly.io/docs/hands-on/install-flyctl/){:target="_blank"}.

Após a instalação, você pode verificar se o flyctl está instalado em seu sistema operacional digitando o seguinte comando no terminal:


```shell title="$ Execução no terminal!"
flyctl version

flyctl v0.1.134 linux/amd64 Commit: ... BuildDate: 2023-12-08T18:58:44Z
```

A versão instalada no meu sistema é a `0.1.134`. No momento da sua instalação, você pode se deparar com uma versão mais recente do que a minha no momento, mas os comandos devem funcionar da mesma forma em qualquer versão menor que `0.2.0`.


#### Fazendo login via terminal

Após a instalação do `flyctl` é importante que você efetue o login usando suas credenciais, para que o `flyctl` consiga vincular suas credenciais com a linha de comando. Para isso podemos executar o seguinte comando:

```shell title="$ Execução no terminal!"
flyctl auth login
Opening https://fly.io/app/auth/cli/91283719231023123 ...

Waiting for session...
```

Isso abrirá uma janela em seu browser pedindo que você efetue o login:

![Captura de tela da tela inicial de login do fly.io](assets/11_auth_login_fly.png){: .center .shadow width="500" }

Após inserir suas credenciais, você pode fechar o browser e no shell a execução do comando terminará mostrando a conta em que você está logado:

```shell title="$ Continuação da resposta do terminal"
Waiting for session... Done
successfully logged in as <seu-email@de-login.com>
```

Desta forma, toda a configuração necessária para o iniciar o deploy está pronta!

## Configurações para o deploy

Agora com o `flyctl` devidamente configurado. Podemos iniciar o processo de lançamento da nossa aplicação. O `flyctl` tem um comando específico para lançamento, o `launch`. Contudo, o comando `launch` é bastante interativo e ao final dele, o deploy da aplicação é executado. Para evitar o deploy no primeiro momento, pois ainda existem coisas para serem configuradas, vamos executá-lo da seguinte forma:

```shell title="$ Execução no terminal!"
flyctl launch --no-deploy
```

Como resultado desse comando, o `flyctl` iniciará o modo interativo e exibirá uma resposta próxima a essa:

```shell title="$ Resposta do comando `launch`"
Detected a Dockerfile app
Creating app in /home/dunossauro/ci-example-fastapi
We're about to launch your app on Fly.io. Here's what you're getting:

Organization: <Seu Nome>             (fly launch defaults to the personal org)
Name:         fast-zero              (derived from your directory name)
Region:       Sao Paulo, Brazil      (this is the fastest region for you)
App Machines: shared-cpu-1x, 1GB RAM (most apps need about 1GB of RAM)
Postgres:     <none>                 (not requested)
Redis:        <none>                 (not requested)

? Do you want to tweak these settings before proceeding? (y/N) 
```

Nesse texto estão destacadas as configurações padrões do Fly. Como a Região onde seu deploy será feito (`Sao Paulo, Brazil`, o mais próximo a mim nesse momento), a configuração da máquina do deploy `App Machines: shared-cpu-1x, 1GB RAM` e a opção padrão do Postgres: `Postgres: <none>`.

A pergunta feita ao final dessa seção `Do you want to tweak these settings before proceeding?` pode ser traduzida como: `Você deseja ajustar essas configuração antes de prosseguir?`. Diremos que sim, digitando ++y++ e em seguida ++return++.

Assim, a configuração do lançamento deve avançar e travar novamente com um texto parecido com esse:

```shell title="$ Continuação do comando `launch`"
? Do you want to tweak these settings before proceeding? Yes
Opening https://fly.io/cli/launch/59f08b31a5efd30bdf5536ac516de5ga ...

Waiting for launch data...⣽
```

Nesse momento, ele abrirá o browser novamente exibira uma tela de ajustes de configurações:

![captura de tela da janela de tweak da aplicação](assets/11_fly_lauch_tweak.png){: .center .shadow width="500" }

Nesse momento faremos alguns ajustes em nossa configuração:

1. Seção `Basics`: adicionaremos o nome da nossa aplicação no Fly. (Usarei `fastzeroapp`)
2. Seção `Memory & CPU`: alteraremos o campo `VM Memory` para 256MB
3. Seção `Database`:
    - alteraremos o campo `Postgres` para `Fly Posgres`
	- criaremos um nome para o nosso serviço de banco de dados. (Usarei `fastzerodb`)
	- no campo `Configuration` alteraremos para `Development - Single node, 1x shared CPU, 256MB RAM, 1GB disk`
4. Por fim, clicamos em `Confirm Settings`!

Após esse ajuste, você pode fechar a janela do browser e voltar ao terminal, pois a parte interativa do `launch` ainda estará em execução. Como a resposta a seguir é bastante grande, colarei `...` para pular algumas linhas que não nos interessam nesse momento:

```shell title="$ Continuação do comando `launch`" hl_lines="2 16 22"
Created app 'fastzeroapp' in organization 'personal'
Admin URL: https://fly.io/apps/fastzeroapp
Hostname: fastzeroapp.fly.dev
Creating postgres cluster in organization personal
Creating app...

...

Postgres cluster fastzerodb created
  Username:    postgres
  Password:    t0Vf35P21eDlIVS
  Hostname:    fastzerodb.internal
  Flycast:     fdaa:2:77b0:0:1::a
  Proxy port:  5432
  Postgres port:  5433
  Connection string: postgres://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432

...

Postgres cluster fastzerodb is now attached to fastzeroapp
The following secret was added to fastzeroapp:
  DATABASE_URL=postgres://fastzeroapp:zHgBlc6JNaslGtz@fastzerodb.flycast:5432/fastzeroapp?sslmode=disable
Postgres cluster fastzerodb is now attached to fastzeroapp
? Create .dockerignore from .gitignore files? (y/N)
```

Nas linhas em destaque, vemos que o Fly se encarregou de criar um dashboard para vermos o status atual da nossa aplicação (https://fly.io/apps/nome-do-seu-app), inicializou um banco de dados postgres para usarmos em conjunto com nossa aplicação e também adicionou a url do banco de dados a variável de ambiente `DATABASE_URL` com a configuração do postgres referente a nossa aplicação.

**A `Connection string` do banco de dados deve ser armazenada por você, essa informação não será disponibilizada novamente, nem mesmo na parte web do Fly. Por isso {++guarde-a com cuidado e não compartilhem de forma alguma++}.**

Assim sendo, para prosseguir com o `launch` devemos responder a seguinte pergunta: `Create .dockerignore from .gitignore files? (y/N)`, que pode ser traduzida como `Crie um .dockerignore partindo do arquivo .gitignore?`. Vamos novamente responder que sim. Digitando ++y++ e em seguida ++return++.

```shell title="$ Continuação do comando `launch`"
Created <seu-path>/.dockerignore from 6 .gitignore files.
Wrote config file fly.toml
Validating <seu-path>/fly.toml
Platform: machines
✓ Configuration is valid
Your app is ready! Deploy with `flyctl deploy`
```

Agora o `flyctl` criou um arquivo `.dockerignore` que não copia os arquivos do `.gitignore` para dentro do container docker e também criou um arquivo de configuração do Fly, o arquivo `fly.toml`.

Na última linha ele nos disse que nossa aplicação está pronta para o deploy. Mas ainda temos mais configurações a fazer!

### Configuração dos segredos

Para que nossa aplicação funcione de maneira adequada, todas as variáveis de ambiente precisam estar configuradas no ambiente. O `flyctl` tem um comando para vermos as variáveis que já foram definidas no ambiente e também para definir novas. O comando `secrets`.

Para vermos as variáveis já configuradas no ambiente, podemos executar o seguinte comando:

```shell title="$ Execução no terminal!"
flyctl secrets list

NAME        	DIGEST          	CREATED AT 
DATABASE_URL	f803df294e7326fa	22m43s ago
```

Uma coisa que podemos notar na resposta do `secrets` é que ele leu nosso arquivo `.env` e adicionou a variável de ambiente `DATABASE_URL` com base no postgres que foi criado durante o comando `launch`. Um ponto de atenção que devemos tomar nesse momento, é que a variável criada é iniciada com o prefixo `postgres://`. Para que o sqlalchemy reconheça esse endereço como válido, o prefixo deve ser alterado para `postgresql://`. Para isso, usaremos a url fornecida pelo comando `launch` e alterar o prefixo.

Desta forma, podemos registar a variável de ambiente `DATABASE_URL` novamente. Agora com o valor correto:


```shell title="$ Execução no terminal!"
flyctl secrets set DATABASE_URL=postgresql://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432
Secrets are staged for the first deployment
```

Contudo, não é somente a variável de ambiente do postgres que é importante para que nossa aplicação seja executada. Temos que adicionar as outras variáveis contidas no nosso `.env` ao Fly.

Iniciaremos adicionando a variável `ALGORITHM`:

```shell title="$ Execução no terminal!"
flyctl secrets set ALGORITHM="HS256"
Secrets are staged for the first deployment
```

Seguida pela variável `SECRET_KEY`:

```shell title="$ Execução no terminal!"
flyctl secrets set SECRET_KEY="your-secret-key"
Secrets are staged for the first deployment
```

E por fim a variável `ACCESS_TOKEN_EXPIRE_MINUTES`:

```shell title="$ Execução no terminal!"
flyctl secrets set ACCESS_TOKEN_EXPIRE_MINUTES=30
Secrets are staged for the first deployment
```

Com isso, todos os segredos da nossa aplicação já estão configurados no nosso ambiente do Fly. Agora podemos partir para o nosso tão aguardado deploy.


### Deploy da aplicação

Para efetuarmos o deploy da aplicação, podemos usar o comando `deploy` do`flyctl`. Uma coisa interessante nessa parte do processo é que o Fly pode fazer o deploy de duas formas:

1. Copiar seus arquivos e fazer o build do docker na nuvem;
2. Você pode fazer o build localmente e subir apenas o container para um [repositório](https://docs.docker.com/docker-hub/repos/){:target="_blank"} disponível no Fly.

Optaremos por fazer o build localmente para que não sejam alocados duas máquinas em nossa aplicação[^1]. Para executar o build localmente usamos a flag `--local-only`:

[^1]: No plano gratuito existe uma limitação de máquinas disponíveis por aplicação. Quando usamos mais de uma máquina, temos que ter um plano pago, por esse motivo, vamos fazer o build localmente.

```shell title="$ Execução no terminal!"
fly deploy --local-only
```

> [RPA]

```
fly deploy --local-only
==> Verifying app config
Validating /home/dunossauro/ci-example-fastapi/fly.toml
Platform: machines
✓ Configuration is valid
--> Verified app config
==> Building image
==> Building image with Docker
...
 => exporting to image                                                  0.0s
 => => exporting layers                                                 0.0s
 => => writing image sha256:b95a9d9f8abcea085550449a720a0bb9176e195fe4  0.0s
 => => naming to registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN4  0.0s
--> Building image done
==> Pushing image to fly
The push refers to repository [registry.fly.io/fastzeroapp]
...
deployment-01HHKKDMF87FN441VA6H0JR4BS: digest: sha256:153a13e2931f923ab60df7e9dd0f18e2cc89fff7833ac18443935c7d0763a329 size: 2419
--> Pushing image done
image: registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN441VA6H0JR4BS
image size: 349 MB

Watch your deployment at https://fly.io/apps/fastzeroapp/monitoring

-------
Updating existing machines in 'fastzeroapp' with rolling strategy

-------
 ✔ Machine 1781551ad22489 [app] update succeeded
-------

Visit your newly deployed app at https://fastzeroapp.fly.dev/
```


Resultado:

![descrição](assets/11_resposta_do_servidor.png){: .center .shadow }


![descrição](assets/11_erro_na_aplicação_falta_de_migração.png){: .center .shadow }

![descrição](assets/11_erro_no_monitoramento.png){: .center .shadow }


### Migrations

> [WIP] - Explicar aqui o conceito da migração na web

```shell title="$ Execução no terminal!"
fly ssh console -a fastzeroapp -C "poetry run alembic upgrade head"

Connecting to fdaa:2:77b0:a7b:1f60:3f74:a755:2... complete
Skipping virtualenv creation, as specified in config file.
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> e018397cecf4, create users table
INFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -> de865434f506, create todos table
```


---
> Texto antigo

## O Fly.io e a instalação da CLI

Para iniciar, precisamos instalar a CLI do Fly.io, chamada `flyctl`. Você pode baixá-la no site oficial do Fly.io. Com o `flyctl` instalado, precisamos fazer login na nossa conta do Fly.io usando o comando:

```shell title="$ Execução no terminal!"
fly auth login
```

Este comando irá abrir o navegador para você entrar com suas credenciais do Fly.io.

## Criando a aplicação no Fly.io e fazendo o deploy

Depois de logado, podemos criar uma nova aplicação no Fly.io usando o comando:

```shell title="$ Execução no terminal!"
fly launch
```

Este comando irá perguntar algumas informações sobre sua aplicação e então criará uma nova aplicação no Fly.io. Com nossa aplicação criada, podemos agora fazer o deploy da nossa imagem Docker usando o comando:

```shell title="$ Execução no terminal!"
fly deploy --local-only
```

A opção `--local-only` diz para o `flyctl` construir a imagem Docker localmente e depois fazer o upload dela para o Fly.io.

## Configurando a instância do PostgreSQL no Fly.io

Antes de avançarmos, é importante mencionar uma especificidade do Fly.io: para criar uma instância do PostgreSQL, a plataforma requer que um cartão de crédito seja fornecido. Esta é uma medida de segurança adotada para evitar o uso indevido de seus serviços, como a execução de ferramentas de mineração. Apesar dessa exigência, o serviço de PostgreSQL é oferecido de forma gratuita. Mais detalhes podem ser encontrados [neste artigo](https://fly.io/blog/free-postgres/).

Agora, vamos criar uma instância do PostgreSQL. O Fly.io fornece um serviço PostgreSQL que podemos usar para criar uma nova instância do PostgreSQL com apenas alguns comandos.

## Configurando as variáveis de ambiente e rodando as migrações do Alembic

Com a instância criada, algumas variáveis de ambiente serão automaticamente definidas para nós. Para que o Alembic possa executar as migrações, precisamos configurar a variável `DATABASE_URL` no nosso aplicativo para apontar para a instância do PostgreSQL do Fly.io.

```shell title="$ Execução no terminal!"
fly secrets set DATABASE_URL=<value>
```

Substitua `<value>` pela string de conexão do seu banco de dados PostgreSQL.

Finalmente, podemos executar nossas migrações Alembic. Usaremos a CLI do Fly.io para executar o comando dentro de um contêiner do nosso aplicativo:

```shell title="$ Execução no terminal!"
fly ssh console --app <your-app-name> 'poetry run alembic upgrade head'
```

Substitua `<your-app-name>` pelo nome do seu aplicativo no Fly.io.

## Configurando o deploy contínuo no Github Actions

Agora que temos nosso aplicativo funcionando no Fly.io, podemos configurar o Github Actions para fazer o deploy automático sempre que fizermos um push no nosso repositório. Para isso, precisaremos adicionar alguns passos ao nosso arquivo de pipeline do Github Actions:

```yaml
- name: Build and push Docker image to Fly.io
  run: |
    flyctl deploy --local-only
    flyctl deploy
```

Com isso, nossa aplicação está pronta para uso no Fly.io!

## Conclusão

Ao longo desta aula, nós mergulhamos no mundo do deploy de aplicações com o Fly.io, uma plataforma que facilita imensamente a tarefa de colocar nossas aplicações para funcionar na nuvem. Além disso, também tivemos a chance de entender como gerenciar variáveis de ambiente de forma segura e eficiente, permitindo a nossa aplicação se adaptar a diferentes contextos de execução.

Aprendemos como subir nossa imagem Docker no Fly.io e como este processo pode ser simplificado e automatizado. Também vimos como é possível ter nosso banco de dados rodando no mesmo ambiente da nossa aplicação, facilitando a manutenção e a escalabilidade.

Configuramos e utilizamos o PostgreSQL no Fly.io, o que nos deu uma visão prática de como gerenciar bancos de dados em um ambiente de produção. Ao fazer isso, pudemos integrar ainda mais a nossa aplicação ao ambiente em que ela está rodando.

Além disso, exploramos a importância das migrações e como elas podem ser gerenciadas usando o Alembic, que nos permitiu atualizar nosso banco de dados de forma controlada e rastreável.

Finalmente, vimos como podemos automatizar todo o processo de deploy usando o Github Actions. Esta é uma prática extremamente útil e poderosa, pois permite que a nossa aplicação esteja sempre atualizada com as últimas alterações que fizemos, sem a necessidade de qualquer intervenção manual.

Com todas essas peças, temos agora uma aplicação robusta e pronta para escalar, com todos os elementos necessários para ser operada em um ambiente de produção real. Estas são ferramentas e práticas que estão no coração do desenvolvimento de software moderno, e dominá-las nos permitirá construir aplicações cada vez mais complexas e eficientes.

Na próxima aula, faremos uma recapitulação de tudo o que aprendemos neste curso e discutiremos os próximos passos. Continue acompanhando para fortalecer ainda mais seus conhecimentos em desenvolvimento de aplicações com FastAPI, Docker, CI/CD e muito mais. Até a próxima aula!
