---
title: Automatizando os testes com Integra√ß√£o Cont√≠nua
description: Cria√ß√£o de rotinas de CI com Github Actions
---

# Automatizando os testes com Integra√ß√£o Cont√≠nua (CI)

---
Objetivos da aula:

- Compreender a pr√°tica de Integra√ß√£o Cont√≠nua (CI) e sua import√¢ncia no processo de desenvolvimento de software.
- Aprender a usar o GitHub Actions para criar workflows de CI que automatizem a execu√ß√£o de testes a cada commit.
- Configurar um pipeline de CI para nossa aplica√ß√£o FastAPI que execute testes automaticamente.
- Reconhecer a import√¢ncia de manter uma cobertura de testes abrangente e consistente.

{%set aula = "11" %}
{%set link = "xb_jtnYiPUQ" %}
{% include "templates/cabecalho.md" %}

---

Na aula anterior, preparamos nossa aplica√ß√£o para execu√ß√£o em containers Docker, um passo fundamental para replicar o ambiente de produ√ß√£o. Agora, vamos garantir que nossa aplica√ß√£o mantenha sua integridade a cada mudan√ßa, implementando Integra√ß√£o Cont√≠nua.

## Integra√ß√£o Cont√≠nua (CI)

Integra√ß√£o Cont√≠nua (CI) √© uma pr√°tica de desenvolvimento que envolve a integra√ß√£o regular do c√≥digo-fonte ao reposit√≥rio principal, acompanhada de testes automatizados para garantir a qualidade. O objetivo dessa pr√°tica √© identificar e corrigir erros de forma precoce, facilitando o desenvolvimento cont√≠nuo e colaborativo. Pois, caso algu√©m esque√ßa de rodar os testes ou exista algum problema na integra√ß√£o entre dois commits, ou em algum merge, isso seja detectado no momento em que a integra√ß√£o cont√≠nua √© executada.


### GitHub Actions

Entre as ferramentas dispon√≠veis para CI, o [GitHub Actions](https://github.com/features/actions){:target="_blank"} √© um servi√ßo do GitHub que automatiza workflows dentro do seu reposit√≥rio. Voc√™ pode configurar o GitHub Actions para executar a√ß√µes espec√≠ficas ‚Äî como testes automatizados ‚Äî cada vez que um novo c√≥digo √© commitado no reposit√≥rio.

### Exemplo de workflow

Workflows no GitHub Actions come√ßam com a constru√ß√£o de um ambiente (escolher um sistema operacional e instalar suas depend√™ncias) e criar diversos passos (*steps* em ingl√™s) para executar todas as etapas que fazemos no nosso computador durante o desenvolvimento. √â uma forma de garantir que o sistema funciona em um ambiente controlado. Dessa forma, todas √†s vezes que subimos o c√≥digo para o reposit√≥rio (damos push) esse ambiente e a sequ√™ncia de passos ser√° executada.

Por exemplo, como nosso sistema usar√° um sistema operacional GNU/Linux, podemos selecionar uma distribui√ß√£o como [Ubuntu](https://ubuntu.com/){:target="_blank"} para executar todos os passos da execu√ß√£o dos nossos testes. Isso inclui diversas etapas como preparar o banco de dados, ler as vari√°veis de ambiente, instalar o python e o poetry, etc.

Antes de mergulharmos na configura√ß√£o do YAML, vamos visualizar o processo de constru√ß√£o do nosso ambiente de CI com um fluxograma. Este diagrama mostra os passos essenciais, desde a instala√ß√£o do Python at√© a execu√ß√£o dos testes, ajudando a entender a sequ√™ncia de opera√ß√µes no GitHub Actions.

```mermaid
flowchart LR
    Push -- Inicia --> Ubuntu
    Ubuntu -- Execute os --> Passos
	Ubuntu --> Z[Configure as vari√°veis de ambiente]
	subgraph Passos
      A[Instale a vers√£o 3.11 do Python] --> B[Copie os arquivos do reposit√≥rio para o ambiente]
	  B --> C[Instale o Poetry]
	  C --> D[Instale as depend√™ncia do projeto com Poetry]
	  D --> E[Poetry execute os testes do projeto]
	end
```

Com o fluxograma em mente, nosso objetivo de aula √© traduzir esses passos para a configura√ß√£o pr√°tica no GitHub Actions. Agora que temos uma vis√£o clara do que nosso workflow envolve, nos aprofundaremos em como transformar essa teoria em pr√°tica. 

## Configurando o workflow de CI

As configura√ß√µes dos workflows no GitHub Actions s√£o definidas em um arquivo [YAML](https://yaml.org/){:target="_blank"} localizado em um path especificado pelo github no reposit√≥rio `.github/workflows/`. Dentro desse diret√≥rio podemos criar quantos workflows quisermos. Iniciaremos nossa configura√ß√£o com um √∫nico arquivo que chamaremos de `pipeline.yaml`:

=== "Vers√£o 3.11"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="1"
    name: Pipeline
    on: [push, pull_request]
     
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.11'
    ```

=== "Vers√£o 3.12"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="1"
    name: Pipeline
    on: [push, pull_request]
     
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.12'
    ```
=== "Vers√£o 3.13"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="1"
    name: Pipeline
    on: [push, pull_request]
     
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.13'
    ```

Basicamente um arquivo de workflow precisa de tr√™s componentes essenciais para serem definidos:

- Um nome para o workflow (`name`);
- Uma condi√ß√£o de execu√ß√£o (a chave `on`) para sabermos o que iniciar√° o processo de workflow; e
- Um `job`: Onde escolheremos um sistema e descreveremos a lista de passos para serem executados.

Nesse bloco de c√≥digo definimos que toda vez em que um `push` ou um `pull_request` ocorrer no nosso reposit√≥rio o `Pipeline` ser√° executado. Esse workflow tem um job chamado `test` que roda na √∫ltima vers√£o do Ubuntu `runs-on: ubuntu-latest`. Nesse job chamado `test` temos uma lista de passos para serem executados, os `steps`.

O √∫nico step que definimos √© a instala√ß√£o do Python na vers√£o "3.11":

=== "Vers√£o 3.11"
    ```yaml linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.11'
    ```

=== "Vers√£o 3.12"
    ```yaml linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.12'
    ```
=== "Vers√£o 3.13"
    ```yaml linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.13'
    ```

Nesse momento, se executarmos um commit do arquivo `.github/workflows/pipeline.yaml` e um push em nosso reposit√≥rio, um workflow ser√° iniciado.

```shell title="$ Execu√ß√£o no terminal!"
git add .
git commit -m "Instala√ß√£o do Python"
git push
```

Nisso, podemos ir at√© a p√°gina do nosso reposit√≥rio no github e clicar na aba `Actions`, isso exibir√° todas √†s vezes que um workflow for executado. Se clicarmos no wokflow seremos levados a p√°gina dos jobs executados e se clicarmos nos jobs, temos uma descri√ß√£o dos steps executados:

=== "Guia Actions ->"
	![Captura de tela da aba Actions do reposit√≥rio exibindo o workflow "instala√ß√£o do python" e mostrando que foi executado com sucesso](assets/11/print_da_aba_actions_go_reposit√≥rio.png){: .center .shadow }

=== "Jobs executados ->"

	![descri√ß√£o](assets/11/print_do_status_geral_do_workflow_no_actions.png){: .center .shadow }

=== "Steps executados"
	![descri√ß√£o](assets/11/print_dos_passos_executados_no_workflow_parte_1.png){: .center .shadow }


Isso nos mostra que tudo que configuramos no arquivo `pipelines.yaml` foi executado pelo actions no momento que em executamos um `push` no git.

Agora que temos essa vis√£o geral de como o Actions monta e executa workflows, podemos nos concentrar em construir o nosso ambiente.

### Constru√ß√£o do nosso ambiente de CI

Para executar nossos testes no workflow, precisamos seguir alguns passos essenciais:

1. **Instalar o Python**: fundamental para executar nosso c√≥digo e testes, por ser a linguagem base da nossa aplica√ß√£o.
2. **Instalar o Poetry**: pois toda a nossa aplica√ß√£o e depend√™ncias foram constru√≠das com ele.
3. **Instalar as depend√™ncias do projeto**: far√£o com que todas as bibliotecas necess√°rias estejam dispon√≠veis para a execu√ß√£o dos testes.
4. **Executar os testes**: passo crucial para validar a integridade e funcionalidade do c√≥digo antes de integr√°-lo ao reposit√≥rio principal.

```mermaid
flowchart LR
   Python["1: Python instalado"] --> Poetry["2: Poetry instalado"]
   Poetry --> Deps["3: Instalar as depend√™ncias via Poetry"]
   Deps --> Testes["4: Executar os testes via Poetry"]
```

Cada um desses passos contribui para estabelecer um ambiente de CI robusto e confi√°vel, assegurando que cada mudan√ßa no c√≥digo seja validada automaticamente, mantendo a qualidade e a estabilidade da nossa aplica√ß√£o.


Para isso, devemos criar um `step` para cada uma dessas a√ß√µes no nosso job `test`. Desta:

=== "Vers√£o 3.11"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.11'
     
          - name: Instalar o poetry
            run: pipx install poetry
     
          - name: Instalar depend√™ncias
            run: poetry install
     
          - name: Executar testes
            run: poetry run task test
    ```

=== "Vers√£o 3.12"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.12'
     
          - name: Instalar o poetry
            run: pipx install poetry
     
          - name: Instalar depend√™ncias
            run: poetry install
     
          - name: Executar testes
            run: poetry run task test
    ```
=== "Vers√£o 3.13"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="8"
        steps:
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.13'
     
          - name: Instalar o poetry
            run: pipx install poetry
     
          - name: Instalar depend√™ncias
            run: poetry install
     
          - name: Executar testes
            run: poetry run task test
    ```

Para testar essa implementa√ß√£o no Actions, temos que fazer um commit[^1], para executar o trigger do CI:

[^1]: H√° alternativas para testar o workflow de CI sem fazer um commit, como a ferramenta [Act](https://github.com/nektos/act){:target="_blank"} que simula a execu√ß√£o do workflow localmente usando Docker.

```shell title="$ Execu√ß√£o no terminal!"
git add .
git commit -m "Adicionando passos para executar os testes no CI"
git push
```

Assim, podemos avaliar o impacto desses passos no nosso workflow:

![descri√ß√£o](assets/11/print_do_pipeline_quebrado_ao_executar_os_testes.png){: .center .shadow }

Se analisarmos com calma o resultado, veremos que a execu√ß√£o do nosso workflow apresenta um erro de execu√ß√£o. O erro est√° descrito na linha `#!py 12`: `Poetry could not find a pyproject.toml file in <path> or its parents`. Se traduzirmos de maneira literal, a linha nos disse `Poetry n√£o encontrou o arquivo pyproject.toml no <path> ou em seus parentes`.

Para solucionar esse problema, adicionaremos um passo antes da execu√ß√£o dos testes para copiar o c√≥digo do nosso reposit√≥rio para o ambiente do workflow. O GitHub Actions oferece uma a√ß√£o espec√≠fica para isso, chamada actions/checkout. Vamos inclu√≠-la como o primeiro passo:

=== "Vers√£o 3.11"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="4" hl_lines="6-7"
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Copia os arquivos do reposit√≥rio
            uses: actions/checkout@v3
     
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.11'
     
          # continua com os passos anteriormente definidos
    ```

=== "Vers√£o 3.12"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="4" hl_lines="6-7"
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Copia os arquivos do reposit√≥rio
            uses: actions/checkout@v3
     
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.12'
     
          # continua com os passos anteriormente definidos
    ```
=== "Vers√£o 3.13"
    ```yaml title=".github/workflows/pipeline.yaml" linenums="4" hl_lines="6-7"
    jobs:
      test:
        runs-on: ubuntu-latest
     
        steps:
          - name: Copia os arquivos do reposit√≥rio
            uses: actions/checkout@v3
     
          - name: Instalar o python
            uses: actions/setup-python@v5
            with:
              python-version: '3.13'
     
          # continua com os passos anteriormente definidos
    ```

Para testar a execu√ß√£o desse passo faremos um novo commit para triggar o Actions:

```shell title="$ Execu√ß√£o no terminal!"
git add .
git commit -m "Adicionando o checkout ao pipeline"
git push
```

Com isso, o erro anterior deve ser resolvido e teremos os testes sendo executados no workflow:

![descri√ß√£o](assets/11/execucao_dos_testes_com_erro_de_ambiente.png){: .center .shadow }

Ap√≥s resolver este problema, nos deparamos com outro desafio. Evidenciado no bloco a seguir:

```py title="Erro do CI!" hl_lines="9-15"
ImportError while loading conftest '/home/runner/work/<path>/tests/conftest.py'.
tests/conftest.py:6: in <module>
    from fast_zero.app import app
fast_zero/app.py:3: in <module>
    from fast_zero.routes import auth, todos, users
fast_zero/routes/auth.py:8: in <module>
    from fast_zero.database import get_session
fast_zero/database.py:6: in <module>
    engine = create_engine(Settings().DATABASE_URL)
../../../.cache/pypoetry/virtualenvs/fast-zero-IubsqyUK-py3.11/lib/python3.11/site-packages/pydantic_settings/main.py:61: in __init__
    super().__init__(
E   pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings
E   DATABASE_URL
E     Field required [type=missing, input_value={}, input_type=dict]
E       For further information visit https://errors.pydantic.dev/2.1.2/v/missing
```

??? tip "Erro completo no CI"
	![Captura de tela da messangem de erro completo no Actions](assets/11/print_do_erro_completo_por_variaveis_de_ambiente.png){: .center .shadow }


Ao iniciar a execu√ß√£o dos testes, encontramos um erro relacionado √† nossa classe `settings.Settings`. Isso ocorreu porque as vari√°veis de ambiente necess√°rias, como `DATABASE_URL`, n√£o estavam definidas no workflow do CI. Este problema √© comum quando as vari√°veis do arquivo `.env`, que utilizamos localmente, n√£o s√£o transferidas para o ambiente de CI.

### Configura√ß√£o de vari√°veis de ambiente no Actions

Como vimos anteriormente, nossa configura√ß√£o de CI encontrou um problema devido √† aus√™ncia de vari√°veis de ambiente. Para resolver isso, utilizaremos uma funcionalidade dos reposit√≥rios do GitHub chamada 'Secrets'. Os 'Secrets' s√£o uma maneira segura de armazenar informa√ß√µes confidenciais, como vari√°veis de ambiente, de forma criptografada. Eles s√£o acess√≠veis dentro do nosso workflow, permitindo que o GitHub Actions utilize esses valores sem exp√¥-los publicamente.

#### Definindo Secrets no Reposit√≥rio

Para definirmos as vari√°veis de ambiente como 'Secrets', temos duas alternativas. A primeira √© acessar a aba `Settings -> Secrets and variables` do nosso reposit√≥rio no GitHub. Neste local, podemos inserir manualmente cada 'Secret', como URLs de banco de dados e chaves secretas.

A segunda alternativa √© utilizar o CLI do GitHub (`gh`) para adicionar todas as vari√°veis de ambiente que temos no nosso arquivo `.env`. Isso pode ser feito com o seguinte comando:

```shell title="$ Execu√ß√£o no terminal!"
gh secret set -f .env
```

Este comando pega todas as vari√°veis de ambiente do arquivo `.env` e as configura como 'Secrets' no seu reposit√≥rio GitHub.

??? info "Configurando Secrets pela Interface Web"
	Se preferir configurar 'Secrets' pela interface web do GitHub, siga estes passos:

	=== "1 - Acesse Settings no seu reposit√≥rio"
		Acesse Settings no seu reposit√≥rio GitHub. Em seguida clique na guia "Secrets and variables". Ap√≥s isso clique em "New Repository secret":

		![descri√ß√£o](assets/11/passo_1_secrets.png){: .center .shadow }
	=== "2 - Adicione um novo segredo"
		Para adicionar um novo scregredo no campo `Name` colocamos o nome de um de nossas vari√°veis de ambientes. No campo `Secret` adicione o valor de uma vari√°vel. Como, por exemplo:
		![descri√ß√£o](assets/11/passo_2_secrets.png){: .center .shadow }

		Em seguida clique em `Add secret`.
	=== "3 - Visualiza√ß√£o dos segredos"
		Ap√≥s adicionar todos os segredos, sua p√°gina de segredos deve se parecer com isso:
		![descri√ß√£o](assets/11/passo_3_com_todas_as_variaveis_adicionadas.png){: .center .shadow }

#### Implementa√ß√£o no Arquivo YAML

{% raw %}

Ap√≥s definir as 'Secrets', o pr√≥ximo passo √© integr√°-las ao nosso arquivo de workflow (`.github/workflows/pipeline.yaml`). Aqui, utilizamos uma sintaxe especial para acessar os valores armazenados como 'Secrets'. Cada 'Secret' √© mapeado para uma vari√°vel de ambiente no job do nosso workflow, tornando esses valores seguros e acess√≠veis durante a execu√ß√£o do workflow. Vejamos como isso √© feito:

```yaml title=".github/workflows/pipeline.yaml" linenums="4" hl_lines="5-9"
jobs:
  test:
    runs-on: ubuntu-latest

    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      SECRET_KEY: ${{ secrets.SECRET_KEY }}
      ALGORITHM: ${{ secrets.ALGORITHM }}
      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}
```

Neste trecho de c√≥digo, a sintaxe `${{ secrets.NOME_DA_VARIAVEL }}` √© usada para referenciar os 'Secrets' que definimos no reposit√≥rio. Por exemplo, `secrets.DATABASE_URL` buscar√° o valor da 'Secret' chamada `DATABASE_URL` que definimos. Assim que o workflow √© acionado, esses valores s√£o injetados no ambiente do job, permitindo que nosso c√≥digo os acesse como vari√°veis de ambiente normais.

Essa abordagem n√£o s√≥ mant√©m nossos dados confidenciais seguros, mas tamb√©m nos permite gerenciar configura√ß√µes sens√≠veis de forma centralizada, facilitando atualiza√ß√µes e manuten√ß√£o.

{% endraw %}

#### Atualizando o Workflow

Com as 'Secrets' agora configuradas, precisamos atualizar o nosso workflow para incorporar essas mudan√ßas. Isso √© feito por meio de um novo commit e push para o reposit√≥rio, que acionar√° o workflow com as novas configura√ß√µes.

```shell title="$ Execu√ß√£o no terminal!"
git add .
git commit -m "Adicionando as vari√°veis de ambiente para o CI"
git push
```

A execu√ß√£o do workflow com as novas 'Secrets' nos permitir√° verificar se os problemas anteriores foram resolvidos.

![descri√ß√£o](assets/11/ci_rodando_com_sucesso.png){: .center .shadow }

E **SIM**, tudo funcionou como esper√°vamos üéâ

Agora a cada novo commit ou PR em nossa aplica√ß√£o, os testes ser√£o executados para garantir que a integra√ß√£o pode acontecer sem problemas.

## Conclus√£o

Atrav√©s deste m√≥dulo sobre Integra√ß√£o Cont√≠nua com GitHub Actions, ganhamos uma compreens√£o s√≥lida de como a CI √© vital no desenvolvimento moderno de software. Vimos como o GitHub Actions, uma ferramenta poderosa e vers√°til, pode ser utilizada para automatizar nossos testes e garantir a qualidade e estabilidade do c√≥digo a cada commit. Esta pr√°tica n√£o apenas otimiza nosso fluxo de trabalho, mas tamb√©m nos ajuda a identificar e resolver problemas precocemente.

No pr√≥ximo m√≥dulo, o foco ser√° na prepara√ß√£o da nossa aplica√ß√£o FastAPI para o deployment em produ√ß√£o. Exploraremos as etapas necess√°rias e as melhores pr√°ticas para tornar nossa aplica√ß√£o pronta para o uso no mundo real, abordando desde configura√ß√µes at√© estrat√©gias de deployment eficazes.

{% include "templates/quiz.md" %}
